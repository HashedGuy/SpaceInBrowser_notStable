{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TreeBuilder = void 0;\n\nvar cst_1 = require(\"../../cst/cst\");\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar cst_visitor_1 = require(\"../../cst/cst_visitor\");\n\nvar parser_1 = require(\"../parser\");\n/**\n * This trait is responsible for the CST building logic.\n */\n\n\nvar TreeBuilder =\n/** @class */\nfunction () {\n  function TreeBuilder() {}\n\n  TreeBuilder.prototype.initTreeBuilder = function (config) {\n    this.CST_STACK = []; // outputCst is no longer exposed/defined in the pubic API\n\n    this.outputCst = config.outputCst;\n    this.nodeLocationTracking = (0, utils_1.has)(config, \"nodeLocationTracking\") ? config.nodeLocationTracking : parser_1.DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n\n    if (!this.outputCst) {\n      this.cstInvocationStateUpdate = utils_1.NOOP;\n      this.cstFinallyStateUpdate = utils_1.NOOP;\n      this.cstPostTerminal = utils_1.NOOP;\n      this.cstPostNonTerminal = utils_1.NOOP;\n      this.cstPostRule = utils_1.NOOP;\n    } else {\n      if (/full/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = cst_1.setNodeLocationFull;\n          this.setNodeLocationFromNode = cst_1.setNodeLocationFull;\n          this.cstPostRule = utils_1.NOOP;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n        } else {\n          this.setNodeLocationFromToken = utils_1.NOOP;\n          this.setNodeLocationFromNode = utils_1.NOOP;\n          this.cstPostRule = this.cstPostRuleFull;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n        }\n      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = cst_1.setNodeLocationOnlyOffset;\n          this.setNodeLocationFromNode = cst_1.setNodeLocationOnlyOffset;\n          this.cstPostRule = utils_1.NOOP;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\n        } else {\n          this.setNodeLocationFromToken = utils_1.NOOP;\n          this.setNodeLocationFromNode = utils_1.NOOP;\n          this.cstPostRule = this.cstPostRuleOnlyOffset;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\n        }\n      } else if (/none/i.test(this.nodeLocationTracking)) {\n        this.setNodeLocationFromToken = utils_1.NOOP;\n        this.setNodeLocationFromNode = utils_1.NOOP;\n        this.cstPostRule = utils_1.NOOP;\n        this.setInitialNodeLocation = utils_1.NOOP;\n      } else {\n        throw Error(\"Invalid <nodeLocationTracking> config option: \\\"\" + config.nodeLocationTracking + \"\\\"\");\n      }\n    }\n  };\n\n  TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function (cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      endOffset: NaN\n    };\n  };\n\n  TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function (cstNode) {\n    cstNode.location = {\n      // without error recovery the starting Location of a new CstNode is guaranteed\n      // To be the next Token's startOffset (for valid inputs).\n      // For invalid inputs there won't be any CSTOutput so this potential\n      // inaccuracy does not matter\n      startOffset: this.LA(1).startOffset,\n      endOffset: NaN\n    };\n  };\n\n  TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function (cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      startLine: NaN,\n      startColumn: NaN,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  };\n  /**\n     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n        * @param cstNode\n     */\n\n\n  TreeBuilder.prototype.setInitialNodeLocationFullRegular = function (cstNode) {\n    var nextToken = this.LA(1);\n    cstNode.location = {\n      startOffset: nextToken.startOffset,\n      startLine: nextToken.startLine,\n      startColumn: nextToken.startColumn,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  };\n\n  TreeBuilder.prototype.cstInvocationStateUpdate = function (fullRuleName, shortName) {\n    var cstNode = {\n      name: fullRuleName,\n      children: {}\n    };\n    this.setInitialNodeLocation(cstNode);\n    this.CST_STACK.push(cstNode);\n  };\n\n  TreeBuilder.prototype.cstFinallyStateUpdate = function () {\n    this.CST_STACK.pop();\n  };\n\n  TreeBuilder.prototype.cstPostRuleFull = function (ruleCstNode) {\n    var prevToken = this.LA(0);\n    var loc = ruleCstNode.location; // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n      loc.endLine = prevToken.endLine;\n      loc.endColumn = prevToken.endColumn;\n    } // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN;\n      loc.startLine = NaN;\n      loc.startColumn = NaN;\n    }\n  };\n\n  TreeBuilder.prototype.cstPostRuleOnlyOffset = function (ruleCstNode) {\n    var prevToken = this.LA(0);\n    var loc = ruleCstNode.location; // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n    } // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN;\n    }\n  };\n\n  TreeBuilder.prototype.cstPostTerminal = function (key, consumedToken) {\n    var rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n    (0, cst_1.addTerminalToCst)(rootCst, consumedToken, key); // This is only used when **both** error recovery and CST Output are enabled.\n\n    this.setNodeLocationFromToken(rootCst.location, consumedToken);\n  };\n\n  TreeBuilder.prototype.cstPostNonTerminal = function (ruleCstResult, ruleName) {\n    var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n    (0, cst_1.addNoneTerminalToCst)(preCstNode, ruleName, ruleCstResult); // This is only used when **both** error recovery and CST Output are enabled.\n\n    this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n  };\n\n  TreeBuilder.prototype.getBaseCstVisitorConstructor = function () {\n    if ((0, utils_1.isUndefined)(this.baseCstVisitorConstructor)) {\n      var newBaseCstVisitorConstructor = (0, cst_visitor_1.createBaseSemanticVisitorConstructor)(this.className, (0, utils_1.keys)(this.gastProductionsCache));\n      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n      return newBaseCstVisitorConstructor;\n    }\n\n    return this.baseCstVisitorConstructor;\n  };\n\n  TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function () {\n    if ((0, utils_1.isUndefined)(this.baseCstVisitorWithDefaultsConstructor)) {\n      var newConstructor = (0, cst_visitor_1.createBaseVisitorConstructorWithDefaults)(this.className, (0, utils_1.keys)(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n      this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n      return newConstructor;\n    }\n\n    return this.baseCstVisitorWithDefaultsConstructor;\n  };\n\n  TreeBuilder.prototype.getLastExplicitRuleShortName = function () {\n    var ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 1];\n  };\n\n  TreeBuilder.prototype.getPreviousExplicitRuleShortName = function () {\n    var ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 2];\n  };\n\n  TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function () {\n    var occurrenceStack = this.RULE_OCCURRENCE_STACK;\n    return occurrenceStack[occurrenceStack.length - 1];\n  };\n\n  return TreeBuilder;\n}();\n\nexports.TreeBuilder = TreeBuilder;","map":{"version":3,"mappings":"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","names":["TreeBuilder","config","CST_STACK","outputCst","nodeLocationTracking","parser_1","cstInvocationStateUpdate","utils_1","cstFinallyStateUpdate","cstPostTerminal","cstPostNonTerminal","cstPostRule","test","recoveryEnabled","setNodeLocationFromToken","cst_1","setNodeLocationFromNode","setInitialNodeLocation","setInitialNodeLocationFullRecovery","cstPostRuleFull","setInitialNodeLocationFullRegular","setInitialNodeLocationOnlyOffsetRecovery","cstPostRuleOnlyOffset","setInitialNodeLocationOnlyOffsetRegular","Error","cstNode","location","startOffset","NaN","endOffset","LA","startLine","startColumn","endLine","endColumn","nextToken","fullRuleName","shortName","name","children","push","pop","ruleCstNode","prevToken","loc","key","consumedToken","rootCst","length","ruleCstResult","ruleName","preCstNode","baseCstVisitorConstructor","newBaseCstVisitorConstructor","className","gastProductionsCache","baseCstVisitorWithDefaultsConstructor","newConstructor","getBaseCstVisitorConstructor","ruleStack","RULE_STACK","occurrenceStack","RULE_OCCURRENCE_STACK","exports"],"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/chevrotain/src/parse/parser/traits/tree_builder.ts"],"sourcesContent":["import {\n  addNoneTerminalToCst,\n  addTerminalToCst,\n  setNodeLocationFull,\n  setNodeLocationOnlyOffset\n} from \"../../cst/cst\"\nimport { has, isUndefined, keys, NOOP } from \"@chevrotain/utils\"\nimport {\n  createBaseSemanticVisitorConstructor,\n  createBaseVisitorConstructorWithDefaults\n} from \"../../cst/cst_visitor\"\nimport {\n  CstNode,\n  CstNodeLocation,\n  ICstVisitor,\n  IParserConfig,\n  IToken,\n  nodeLocationTrackingOptions\n} from \"@chevrotain/types\"\nimport { MixedInParser } from \"./parser_traits\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\"\n\n/**\n * This trait is responsible for the CST building logic.\n */\nexport class TreeBuilder {\n  outputCst: boolean\n  CST_STACK: CstNode[]\n  baseCstVisitorConstructor: Function\n  baseCstVisitorWithDefaultsConstructor: Function\n\n  // dynamically assigned Methods\n  setNodeLocationFromNode: (\n    nodeLocation: CstNodeLocation,\n    locationInformation: CstNodeLocation\n  ) => void\n  setNodeLocationFromToken: (\n    nodeLocation: CstNodeLocation,\n    locationInformation: CstNodeLocation\n  ) => void\n  cstPostRule: (this: MixedInParser, ruleCstNode: CstNode) => void\n\n  setInitialNodeLocation: (cstNode: CstNode) => void\n  nodeLocationTracking: nodeLocationTrackingOptions\n\n  initTreeBuilder(this: MixedInParser, config: IParserConfig) {\n    this.CST_STACK = []\n\n    // outputCst is no longer exposed/defined in the pubic API\n    this.outputCst = (config as any).outputCst\n\n    this.nodeLocationTracking = has(config, \"nodeLocationTracking\")\n      ? config.nodeLocationTracking\n      : DEFAULT_PARSER_CONFIG.nodeLocationTracking\n\n    if (!this.outputCst) {\n      this.cstInvocationStateUpdate = NOOP\n      this.cstFinallyStateUpdate = NOOP\n      this.cstPostTerminal = NOOP\n      this.cstPostNonTerminal = NOOP\n      this.cstPostRule = NOOP\n    } else {\n      if (/full/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = setNodeLocationFull\n          this.setNodeLocationFromNode = setNodeLocationFull\n          this.cstPostRule = NOOP\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery\n        } else {\n          this.setNodeLocationFromToken = NOOP\n          this.setNodeLocationFromNode = NOOP\n          this.cstPostRule = this.cstPostRuleFull\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular\n        }\n      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = <any>setNodeLocationOnlyOffset\n          this.setNodeLocationFromNode = <any>setNodeLocationOnlyOffset\n          this.cstPostRule = NOOP\n          this.setInitialNodeLocation =\n            this.setInitialNodeLocationOnlyOffsetRecovery\n        } else {\n          this.setNodeLocationFromToken = NOOP\n          this.setNodeLocationFromNode = NOOP\n          this.cstPostRule = this.cstPostRuleOnlyOffset\n          this.setInitialNodeLocation =\n            this.setInitialNodeLocationOnlyOffsetRegular\n        }\n      } else if (/none/i.test(this.nodeLocationTracking)) {\n        this.setNodeLocationFromToken = NOOP\n        this.setNodeLocationFromNode = NOOP\n        this.cstPostRule = NOOP\n        this.setInitialNodeLocation = NOOP\n      } else {\n        throw Error(\n          `Invalid <nodeLocationTracking> config option: \"${config.nodeLocationTracking}\"`\n        )\n      }\n    }\n  }\n\n  setInitialNodeLocationOnlyOffsetRecovery(\n    this: MixedInParser,\n    cstNode: any\n  ): void {\n    cstNode.location = {\n      startOffset: NaN,\n      endOffset: NaN\n    }\n  }\n\n  setInitialNodeLocationOnlyOffsetRegular(\n    this: MixedInParser,\n    cstNode: any\n  ): void {\n    cstNode.location = {\n      // without error recovery the starting Location of a new CstNode is guaranteed\n      // To be the next Token's startOffset (for valid inputs).\n      // For invalid inputs there won't be any CSTOutput so this potential\n      // inaccuracy does not matter\n      startOffset: this.LA(1).startOffset,\n      endOffset: NaN\n    }\n  }\n\n  setInitialNodeLocationFullRecovery(this: MixedInParser, cstNode: any): void {\n    cstNode.location = {\n      startOffset: NaN,\n      startLine: NaN,\n      startColumn: NaN,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    }\n  }\n\n  /**\n     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n\n     * @param cstNode\n     */\n  setInitialNodeLocationFullRegular(this: MixedInParser, cstNode: any): void {\n    const nextToken = this.LA(1)\n    cstNode.location = {\n      startOffset: nextToken.startOffset,\n      startLine: nextToken.startLine,\n      startColumn: nextToken.startColumn,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    }\n  }\n\n  cstInvocationStateUpdate(\n    this: MixedInParser,\n    fullRuleName: string,\n    shortName: string | number\n  ): void {\n    const cstNode: CstNode = {\n      name: fullRuleName,\n      children: {}\n    }\n\n    this.setInitialNodeLocation(cstNode)\n    this.CST_STACK.push(cstNode)\n  }\n\n  cstFinallyStateUpdate(this: MixedInParser): void {\n    this.CST_STACK.pop()\n  }\n\n  cstPostRuleFull(this: MixedInParser, ruleCstNode: CstNode): void {\n    const prevToken = this.LA(0)\n    const loc = ruleCstNode.location\n\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset\n      loc.endLine = prevToken.endLine\n      loc.endColumn = prevToken.endColumn\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN\n      loc.startLine = NaN\n      loc.startColumn = NaN\n    }\n  }\n\n  cstPostRuleOnlyOffset(this: MixedInParser, ruleCstNode: CstNode): void {\n    const prevToken = this.LA(0)\n    const loc = ruleCstNode.location\n\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN\n    }\n  }\n\n  cstPostTerminal(\n    this: MixedInParser,\n    key: string,\n    consumedToken: IToken\n  ): void {\n    const rootCst = this.CST_STACK[this.CST_STACK.length - 1]\n    addTerminalToCst(rootCst, consumedToken, key)\n    // This is only used when **both** error recovery and CST Output are enabled.\n    this.setNodeLocationFromToken(rootCst.location, <any>consumedToken)\n  }\n\n  cstPostNonTerminal(\n    this: MixedInParser,\n    ruleCstResult: CstNode,\n    ruleName: string\n  ): void {\n    const preCstNode = this.CST_STACK[this.CST_STACK.length - 1]\n    addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult)\n    // This is only used when **both** error recovery and CST Output are enabled.\n    this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location)\n  }\n\n  getBaseCstVisitorConstructor<IN = any, OUT = any>(\n    this: MixedInParser\n  ): {\n    new (...args: any[]): ICstVisitor<IN, OUT>\n  } {\n    if (isUndefined(this.baseCstVisitorConstructor)) {\n      const newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(\n        this.className,\n        keys(this.gastProductionsCache)\n      )\n      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor\n      return newBaseCstVisitorConstructor\n    }\n\n    return <any>this.baseCstVisitorConstructor\n  }\n\n  getBaseCstVisitorConstructorWithDefaults<IN = any, OUT = any>(\n    this: MixedInParser\n  ): {\n    new (...args: any[]): ICstVisitor<IN, OUT>\n  } {\n    if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n      const newConstructor = createBaseVisitorConstructorWithDefaults(\n        this.className,\n        keys(this.gastProductionsCache),\n        this.getBaseCstVisitorConstructor()\n      )\n      this.baseCstVisitorWithDefaultsConstructor = newConstructor\n      return newConstructor\n    }\n\n    return <any>this.baseCstVisitorWithDefaultsConstructor\n  }\n\n  getLastExplicitRuleShortName(this: MixedInParser): string {\n    const ruleStack = this.RULE_STACK\n    return ruleStack[ruleStack.length - 1]\n  }\n\n  getPreviousExplicitRuleShortName(this: MixedInParser): string {\n    const ruleStack = this.RULE_STACK\n    return ruleStack[ruleStack.length - 2]\n  }\n\n  getLastExplicitRuleOccurrenceIndex(this: MixedInParser): number {\n    const occurrenceStack = this.RULE_OCCURRENCE_STACK\n    return occurrenceStack[occurrenceStack.length - 1]\n  }\n}\n"]},"metadata":{},"sourceType":"script"}