{"ast":null,"code":"import _get from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _classCallCheck from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry } from 'three';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nvar boundingBox = /* @__PURE__ */new Box3();\n\nvar MeshBVHRootVisualizer = /*#__PURE__*/function (_Object3D) {\n  _inherits(MeshBVHRootVisualizer, _Object3D);\n\n  var _super = _createSuper(MeshBVHRootVisualizer);\n\n  function MeshBVHRootVisualizer(mesh, material) {\n    var _this;\n\n    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n    var group = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n    _classCallCheck(this, MeshBVHRootVisualizer);\n\n    _this = _super.call(this);\n    _this.material = material;\n    _this.geometry = new BufferGeometry();\n    _this.name = 'MeshBVHRootVisualizer';\n    _this.depth = depth;\n    _this.displayParents = false;\n    _this.mesh = mesh;\n    _this.displayEdges = true;\n    _this._group = group;\n    return _this;\n  }\n\n  _createClass(MeshBVHRootVisualizer, [{\n    key: \"isMesh\",\n    get: function get() {\n      return !this.displayEdges;\n    }\n  }, {\n    key: \"isLineSegments\",\n    get: function get() {\n      return this.displayEdges;\n    }\n  }, {\n    key: \"isLine\",\n    get: function get() {\n      return this.displayEdges;\n    }\n  }, {\n    key: \"raycast\",\n    value: function raycast() {}\n  }, {\n    key: \"update\",\n    value: function update() {\n      var geometry = this.geometry;\n      var boundsTree = this.mesh.geometry.boundsTree;\n      var group = this._group;\n      geometry.dispose();\n      this.visible = false;\n\n      if (boundsTree) {\n        // count the number of bounds required\n        var targetDepth = this.depth - 1;\n        var displayParents = this.displayParents;\n        var boundsCount = 0;\n        boundsTree.traverse(function (depth, isLeaf) {\n          if (depth === targetDepth || isLeaf) {\n            boundsCount++;\n            return true;\n          } else if (displayParents) {\n            boundsCount++;\n          }\n        }, group); // fill in the position buffer with the bounds corners\n\n        var posIndex = 0;\n        var positionArray = new Float32Array(8 * 3 * boundsCount);\n        boundsTree.traverse(function (depth, isLeaf, boundingData) {\n          var terminate = depth === targetDepth || isLeaf;\n\n          if (terminate || displayParents) {\n            arrayToBox(0, boundingData, boundingBox);\n            var min = boundingBox.min,\n                max = boundingBox.max;\n\n            for (var x = -1; x <= 1; x += 2) {\n              var xVal = x < 0 ? min.x : max.x;\n\n              for (var y = -1; y <= 1; y += 2) {\n                var yVal = y < 0 ? min.y : max.y;\n\n                for (var z = -1; z <= 1; z += 2) {\n                  var zVal = z < 0 ? min.z : max.z;\n                  positionArray[posIndex + 0] = xVal;\n                  positionArray[posIndex + 1] = yVal;\n                  positionArray[posIndex + 2] = zVal;\n                  posIndex += 3;\n                }\n              }\n            }\n\n            return terminate;\n          }\n        }, group);\n        var indexArray;\n        var indices;\n\n        if (this.displayEdges) {\n          // fill in the index buffer to point to the corner points\n          indices = new Uint8Array([// x axis\n          0, 4, 1, 5, 2, 6, 3, 7, // y axis\n          0, 2, 1, 3, 4, 6, 5, 7, // z axis\n          0, 1, 2, 3, 4, 5, 6, 7]);\n        } else {\n          indices = new Uint8Array([// X-, X+\n          0, 1, 2, 2, 1, 3, 4, 6, 5, 6, 7, 5, // Y-, Y+\n          1, 4, 5, 0, 4, 1, 2, 3, 6, 3, 7, 6, // Z-, Z+\n          0, 2, 4, 2, 6, 4, 1, 5, 3, 3, 5, 7]);\n        }\n\n        if (positionArray.length > 65535) {\n          indexArray = new Uint32Array(indices.length * boundsCount);\n        } else {\n          indexArray = new Uint16Array(indices.length * boundsCount);\n        }\n\n        var indexLength = indices.length;\n\n        for (var i = 0; i < boundsCount; i++) {\n          var posOffset = i * 8;\n          var indexOffset = i * indexLength;\n\n          for (var j = 0; j < indexLength; j++) {\n            indexArray[indexOffset + j] = posOffset + indices[j];\n          }\n        } // update the geometry\n\n\n        geometry.setIndex(new BufferAttribute(indexArray, 1, false));\n        geometry.setAttribute('position', new BufferAttribute(positionArray, 3, false));\n        this.visible = true;\n      }\n    }\n  }]);\n\n  return MeshBVHRootVisualizer;\n}(Object3D);\n\nvar MeshBVHVisualizer = /*#__PURE__*/function (_Group) {\n  _inherits(MeshBVHVisualizer, _Group);\n\n  var _super2 = _createSuper(MeshBVHVisualizer);\n\n  function MeshBVHVisualizer(mesh) {\n    var _this2;\n\n    var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n\n    _classCallCheck(this, MeshBVHVisualizer);\n\n    _this2 = _super2.call(this);\n    _this2.name = 'MeshBVHVisualizer';\n    _this2.depth = depth;\n    _this2.mesh = mesh;\n    _this2.displayParents = false;\n    _this2.displayEdges = true;\n    _this2._roots = [];\n    var edgeMaterial = new LineBasicMaterial({\n      color: 0x00FF88,\n      transparent: true,\n      opacity: 0.3,\n      depthWrite: false\n    });\n    var meshMaterial = new MeshBasicMaterial({\n      color: 0x00FF88,\n      transparent: true,\n      opacity: 0.3,\n      depthWrite: false\n    });\n    meshMaterial.color = edgeMaterial.color;\n    _this2.edgeMaterial = edgeMaterial;\n    _this2.meshMaterial = meshMaterial;\n\n    _this2.update();\n\n    return _this2;\n  }\n\n  _createClass(MeshBVHVisualizer, [{\n    key: \"color\",\n    get: function get() {\n      return this.edgeMaterial.color;\n    }\n  }, {\n    key: \"opacity\",\n    get: function get() {\n      return this.edgeMaterial.opacity;\n    },\n    set: function set(v) {\n      this.edgeMaterial.opacity = v;\n      this.meshMaterial.opacity = v;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var bvh = this.mesh.geometry.boundsTree;\n      var totalRoots = bvh ? bvh._roots.length : 0;\n\n      while (this._roots.length > totalRoots) {\n        this._roots.pop();\n      }\n\n      for (var i = 0; i < totalRoots; i++) {\n        if (i >= this._roots.length) {\n          var _root = new MeshBVHRootVisualizer(this.mesh, this.edgeMaterial, this.depth, i);\n\n          this.add(_root);\n\n          this._roots.push(_root);\n        }\n\n        var root = this._roots[i];\n        root.depth = this.depth;\n        root.mesh = this.mesh;\n        root.displayParents = this.displayParents;\n        root.displayEdges = this.displayEdges;\n        root.material = this.displayEdges ? this.edgeMaterial : this.meshMaterial;\n        root.update();\n      }\n    }\n  }, {\n    key: \"updateMatrixWorld\",\n    value: function updateMatrixWorld() {\n      var _get2;\n\n      this.position.copy(this.mesh.position);\n      this.rotation.copy(this.mesh.rotation);\n      this.scale.copy(this.mesh.scale);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      (_get2 = _get(_getPrototypeOf(MeshBVHVisualizer.prototype), \"updateMatrixWorld\", this)).call.apply(_get2, [this].concat(args));\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      this.depth = source.depth;\n      this.mesh = source.mesh;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new MeshBVHVisualizer(this.mesh, this.depth);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.edgeMaterial.dispose();\n      this.meshMaterial.dispose();\n      var children = this.children;\n\n      for (var i = 0, l = children.length; i < l; i++) {\n        children[i].geometry.dispose();\n      }\n    }\n  }]);\n\n  return MeshBVHVisualizer;\n}(Group);\n\nexport { MeshBVHVisualizer };","map":{"version":3,"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/three-mesh-bvh/src/objects/MeshBVHVisualizer.js"],"names":["LineBasicMaterial","BufferAttribute","Box3","Group","MeshBasicMaterial","Object3D","BufferGeometry","arrayToBox","boundingBox","MeshBVHRootVisualizer","mesh","material","depth","group","geometry","name","displayParents","displayEdges","_group","boundsTree","dispose","visible","targetDepth","boundsCount","traverse","isLeaf","posIndex","positionArray","Float32Array","boundingData","terminate","min","max","x","xVal","y","yVal","z","zVal","indexArray","indices","Uint8Array","length","Uint32Array","Uint16Array","indexLength","i","posOffset","indexOffset","j","setIndex","setAttribute","MeshBVHVisualizer","_roots","edgeMaterial","color","transparent","opacity","depthWrite","meshMaterial","update","v","bvh","totalRoots","pop","root","add","push","position","copy","rotation","scale","args","source","children","l"],"mappings":"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","sourcesContent":["import { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry } from 'three';\r\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\r\n\r\nconst boundingBox = /* @__PURE__ */ new Box3();\r\nclass MeshBVHRootVisualizer extends Object3D {\r\n\r\n\tget isMesh() {\r\n\r\n\t\treturn ! this.displayEdges;\r\n\r\n\t}\r\n\r\n\tget isLineSegments() {\r\n\r\n\t\treturn this.displayEdges;\r\n\r\n\t}\r\n\r\n\tget isLine() {\r\n\r\n\t\treturn this.displayEdges;\r\n\r\n\t}\r\n\r\n\tconstructor( mesh, material, depth = 10, group = 0 ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.material = material;\r\n\t\tthis.geometry = new BufferGeometry();\r\n\t\tthis.name = 'MeshBVHRootVisualizer';\r\n\t\tthis.depth = depth;\r\n\t\tthis.displayParents = false;\r\n\t\tthis.mesh = mesh;\r\n\t\tthis.displayEdges = true;\r\n\t\tthis._group = group;\r\n\r\n\t}\r\n\r\n\traycast() {}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst boundsTree = this.mesh.geometry.boundsTree;\r\n\t\tconst group = this._group;\r\n\t\tgeometry.dispose();\r\n\t\tthis.visible = false;\r\n\t\tif ( boundsTree ) {\r\n\r\n\t\t\t// count the number of bounds required\r\n\t\t\tconst targetDepth = this.depth - 1;\r\n\t\t\tconst displayParents = this.displayParents;\r\n\t\t\tlet boundsCount = 0;\r\n\t\t\tboundsTree.traverse( ( depth, isLeaf ) => {\r\n\r\n\t\t\t\tif ( depth === targetDepth || isLeaf ) {\r\n\r\n\t\t\t\t\tboundsCount ++;\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t} else if ( displayParents ) {\r\n\r\n\t\t\t\t\tboundsCount ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, group );\r\n\r\n\t\t\t// fill in the position buffer with the bounds corners\r\n\t\t\tlet posIndex = 0;\r\n\t\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\r\n\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData ) => {\r\n\r\n\t\t\t\tconst terminate = depth === targetDepth || isLeaf;\r\n\t\t\t\tif ( terminate || displayParents ) {\r\n\r\n\t\t\t\t\tarrayToBox( 0, boundingData, boundingBox );\r\n\r\n\t\t\t\t\tconst { min, max } = boundingBox;\r\n\t\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\r\n\r\n\t\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\r\n\t\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\r\n\r\n\t\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\r\n\t\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\r\n\r\n\t\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\r\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 0 ] = xVal;\r\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 1 ] = yVal;\r\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 2 ] = zVal;\r\n\r\n\t\t\t\t\t\t\t\tposIndex += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn terminate;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, group );\r\n\r\n\t\t\tlet indexArray;\r\n\t\t\tlet indices;\r\n\t\t\tif ( this.displayEdges ) {\r\n\r\n\t\t\t\t// fill in the index buffer to point to the corner points\r\n\t\t\t\tindices = new Uint8Array( [\r\n\t\t\t\t\t// x axis\r\n\t\t\t\t\t0, 4,\r\n\t\t\t\t\t1, 5,\r\n\t\t\t\t\t2, 6,\r\n\t\t\t\t\t3, 7,\r\n\r\n\t\t\t\t\t// y axis\r\n\t\t\t\t\t0, 2,\r\n\t\t\t\t\t1, 3,\r\n\t\t\t\t\t4, 6,\r\n\t\t\t\t\t5, 7,\r\n\r\n\t\t\t\t\t// z axis\r\n\t\t\t\t\t0, 1,\r\n\t\t\t\t\t2, 3,\r\n\t\t\t\t\t4, 5,\r\n\t\t\t\t\t6, 7,\r\n\t\t\t\t] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tindices = new Uint8Array( [\r\n\r\n\t\t\t\t\t// X-, X+\r\n\t\t\t\t\t0, 1, 2,\r\n\t\t\t\t\t2, 1, 3,\r\n\r\n\t\t\t\t\t4, 6, 5,\r\n\t\t\t\t\t6, 7, 5,\r\n\r\n\t\t\t\t\t// Y-, Y+\r\n\t\t\t\t\t1, 4, 5,\r\n\t\t\t\t\t0, 4, 1,\r\n\r\n\t\t\t\t\t2, 3, 6,\r\n\t\t\t\t\t3, 7, 6,\r\n\r\n\t\t\t\t\t// Z-, Z+\r\n\t\t\t\t\t0, 2, 4,\r\n\t\t\t\t\t2, 6, 4,\r\n\r\n\t\t\t\t\t1, 5, 3,\r\n\t\t\t\t\t3, 5, 7,\r\n\r\n\t\t\t\t] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( positionArray.length > 65535 ) {\r\n\r\n\t\t\t\tindexArray = new Uint32Array( indices.length * boundsCount );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tindexArray = new Uint16Array( indices.length * boundsCount );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst indexLength = indices.length;\r\n\t\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\r\n\r\n\t\t\t\tconst posOffset = i * 8;\r\n\t\t\t\tconst indexOffset = i * indexLength;\r\n\t\t\t\tfor ( let j = 0; j < indexLength; j ++ ) {\r\n\r\n\t\t\t\t\tindexArray[ indexOffset + j ] = posOffset + indices[ j ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// update the geometry\r\n\t\t\tgeometry.setIndex(\r\n\t\t\t\tnew BufferAttribute( indexArray, 1, false ),\r\n\t\t\t);\r\n\t\t\tgeometry.setAttribute(\r\n\t\t\t\t'position',\r\n\t\t\t\tnew BufferAttribute( positionArray, 3, false ),\r\n\t\t\t);\r\n\t\t\tthis.visible = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nclass MeshBVHVisualizer extends Group {\r\n\r\n\tget color() {\r\n\r\n\t\treturn this.edgeMaterial.color;\r\n\r\n\t}\r\n\r\n\tget opacity() {\r\n\r\n\t\treturn this.edgeMaterial.opacity;\r\n\r\n\t}\r\n\r\n\tset opacity( v ) {\r\n\r\n\t\tthis.edgeMaterial.opacity = v;\r\n\t\tthis.meshMaterial.opacity = v;\r\n\r\n\t}\r\n\r\n\tconstructor( mesh, depth = 10 ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.name = 'MeshBVHVisualizer';\r\n\t\tthis.depth = depth;\r\n\t\tthis.mesh = mesh;\r\n\t\tthis.displayParents = false;\r\n\t\tthis.displayEdges = true;\r\n\t\tthis._roots = [];\r\n\r\n\t\tconst edgeMaterial = new LineBasicMaterial( {\r\n\t\t\tcolor: 0x00FF88,\r\n\t\t\ttransparent: true,\r\n\t\t\topacity: 0.3,\r\n\t\t\tdepthWrite: false,\r\n\t\t} );\r\n\r\n\t\tconst meshMaterial = new MeshBasicMaterial( {\r\n\t\t\tcolor: 0x00FF88,\r\n\t\t\ttransparent: true,\r\n\t\t\topacity: 0.3,\r\n\t\t\tdepthWrite: false,\r\n\t\t} );\r\n\r\n\t\tmeshMaterial.color = edgeMaterial.color;\r\n\r\n\t\tthis.edgeMaterial = edgeMaterial;\r\n\t\tthis.meshMaterial = meshMaterial;\r\n\r\n\t\tthis.update();\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst bvh = this.mesh.geometry.boundsTree;\r\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\r\n\t\twhile ( this._roots.length > totalRoots ) {\r\n\r\n\t\t\tthis._roots.pop();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\r\n\r\n\t\t\tif ( i >= this._roots.length ) {\r\n\r\n\t\t\t\tconst root = new MeshBVHRootVisualizer( this.mesh, this.edgeMaterial, this.depth, i );\r\n\t\t\t\tthis.add( root );\r\n\t\t\t\tthis._roots.push( root );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst root = this._roots[ i ];\r\n\t\t\troot.depth = this.depth;\r\n\t\t\troot.mesh = this.mesh;\r\n\t\t\troot.displayParents = this.displayParents;\r\n\t\t\troot.displayEdges = this.displayEdges;\r\n\t\t\troot.material = this.displayEdges ? this.edgeMaterial : this.meshMaterial;\r\n\t\t\troot.update();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateMatrixWorld( ...args ) {\r\n\r\n\t\tthis.position.copy( this.mesh.position );\r\n\t\tthis.rotation.copy( this.mesh.rotation );\r\n\t\tthis.scale.copy( this.mesh.scale );\r\n\r\n\t\tsuper.updateMatrixWorld( ...args );\r\n\r\n\t}\r\n\r\n\tcopy( source ) {\r\n\r\n\t\tthis.depth = source.depth;\r\n\t\tthis.mesh = source.mesh;\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new MeshBVHVisualizer( this.mesh, this.depth );\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis.edgeMaterial.dispose();\r\n\t\tthis.meshMaterial.dispose();\r\n\r\n\t\tconst children = this.children;\r\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tchildren[ i ].geometry.dispose();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport { MeshBVHVisualizer };\r\n"]},"metadata":{},"sourceType":"module"}