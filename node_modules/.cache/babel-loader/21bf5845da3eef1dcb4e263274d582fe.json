{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ErrorHandler = void 0;\n\nvar exceptions_public_1 = require(\"../../exceptions_public\");\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar lookahead_1 = require(\"../../grammar/lookahead\");\n\nvar parser_1 = require(\"../parser\");\n/**\n * Trait responsible for runtime parsing errors.\n */\n\n\nvar ErrorHandler =\n/** @class */\nfunction () {\n  function ErrorHandler() {}\n\n  ErrorHandler.prototype.initErrorHandler = function (config) {\n    this._errors = [];\n    this.errorMessageProvider = (0, utils_1.has)(config, \"errorMessageProvider\") ? config.errorMessageProvider : parser_1.DEFAULT_PARSER_CONFIG.errorMessageProvider;\n  };\n\n  ErrorHandler.prototype.SAVE_ERROR = function (error) {\n    if ((0, exceptions_public_1.isRecognitionException)(error)) {\n      error.context = {\n        ruleStack: this.getHumanReadableRuleStack(),\n        ruleOccurrenceStack: (0, utils_1.cloneArr)(this.RULE_OCCURRENCE_STACK)\n      };\n\n      this._errors.push(error);\n\n      return error;\n    } else {\n      throw Error(\"Trying to save an Error which is not a RecognitionException\");\n    }\n  };\n\n  Object.defineProperty(ErrorHandler.prototype, \"errors\", {\n    get: function get() {\n      return (0, utils_1.cloneArr)(this._errors);\n    },\n    set: function set(newErrors) {\n      this._errors = newErrors;\n    },\n    enumerable: false,\n    configurable: true\n  }); // TODO: consider caching the error message computed information\n\n  ErrorHandler.prototype.raiseEarlyExitException = function (occurrence, prodType, userDefinedErrMsg) {\n    var ruleName = this.getCurrRuleFullName();\n    var ruleGrammar = this.getGAstProductions()[ruleName];\n    var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOptionalProd)(occurrence, ruleGrammar, prodType, this.maxLookahead);\n    var insideProdPaths = lookAheadPathsPerAlternative[0];\n    var actualTokens = [];\n\n    for (var i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n\n    var msg = this.errorMessageProvider.buildEarlyExitMessage({\n      expectedIterationPaths: insideProdPaths,\n      actual: actualTokens,\n      previous: this.LA(0),\n      customUserDescription: userDefinedErrMsg,\n      ruleName: ruleName\n    });\n    throw this.SAVE_ERROR(new exceptions_public_1.EarlyExitException(msg, this.LA(1), this.LA(0)));\n  }; // TODO: consider caching the error message computed information\n\n\n  ErrorHandler.prototype.raiseNoAltException = function (occurrence, errMsgTypes) {\n    var ruleName = this.getCurrRuleFullName();\n    var ruleGrammar = this.getGAstProductions()[ruleName]; // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n\n    var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOr)(occurrence, ruleGrammar, this.maxLookahead);\n    var actualTokens = [];\n\n    for (var i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n\n    var previousToken = this.LA(0);\n    var errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n      expectedPathsPerAlt: lookAheadPathsPerAlternative,\n      actual: actualTokens,\n      previous: previousToken,\n      customUserDescription: errMsgTypes,\n      ruleName: this.getCurrRuleFullName()\n    });\n    throw this.SAVE_ERROR(new exceptions_public_1.NoViableAltException(errMsg, this.LA(1), previousToken));\n  };\n\n  return ErrorHandler;\n}();\n\nexports.ErrorHandler = ErrorHandler;","map":{"version":3,"mappings":"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","names":["ErrorHandler","config","_errors","errorMessageProvider","parser_1","error","context","ruleStack","getHumanReadableRuleStack","ruleOccurrenceStack","RULE_OCCURRENCE_STACK","push","Error","Object","newErrors","occurrence","prodType","userDefinedErrMsg","ruleName","getCurrRuleFullName","ruleGrammar","getGAstProductions","lookAheadPathsPerAlternative","maxLookahead","insideProdPaths","actualTokens","i","LA","msg","buildEarlyExitMessage","expectedIterationPaths","actual","previous","customUserDescription","SAVE_ERROR","exceptions_public_1","errMsgTypes","previousToken","errMsg","buildNoViableAltMessage","expectedPathsPerAlt","exports"],"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/chevrotain/src/parse/parser/traits/error_handler.ts"],"sourcesContent":["import {\n  IParserConfig,\n  IParserErrorMessageProvider,\n  IRecognitionException\n} from \"@chevrotain/types\"\nimport {\n  EarlyExitException,\n  isRecognitionException,\n  NoViableAltException\n} from \"../../exceptions_public\"\nimport { cloneArr, has } from \"@chevrotain/utils\"\nimport {\n  getLookaheadPathsForOptionalProd,\n  getLookaheadPathsForOr,\n  PROD_TYPE\n} from \"../../grammar/lookahead\"\nimport { MixedInParser } from \"./parser_traits\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\"\n\n/**\n * Trait responsible for runtime parsing errors.\n */\nexport class ErrorHandler {\n  _errors: IRecognitionException[]\n  errorMessageProvider: IParserErrorMessageProvider\n\n  initErrorHandler(config: IParserConfig) {\n    this._errors = []\n    this.errorMessageProvider = has(config, \"errorMessageProvider\")\n      ? config.errorMessageProvider\n      : DEFAULT_PARSER_CONFIG.errorMessageProvider\n  }\n\n  SAVE_ERROR(\n    this: MixedInParser,\n    error: IRecognitionException\n  ): IRecognitionException {\n    if (isRecognitionException(error)) {\n      error.context = {\n        ruleStack: this.getHumanReadableRuleStack(),\n        ruleOccurrenceStack: cloneArr(this.RULE_OCCURRENCE_STACK)\n      }\n      this._errors.push(error)\n      return error\n    } else {\n      throw Error(\"Trying to save an Error which is not a RecognitionException\")\n    }\n  }\n\n  get errors(): IRecognitionException[] {\n    return cloneArr(this._errors)\n  }\n\n  set errors(newErrors: IRecognitionException[]) {\n    this._errors = newErrors\n  }\n\n  // TODO: consider caching the error message computed information\n  raiseEarlyExitException(\n    this: MixedInParser,\n    occurrence: number,\n    prodType: PROD_TYPE,\n    userDefinedErrMsg: string\n  ): void {\n    const ruleName = this.getCurrRuleFullName()\n    const ruleGrammar = this.getGAstProductions()[ruleName]\n    const lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(\n      occurrence,\n      ruleGrammar,\n      prodType,\n      this.maxLookahead\n    )\n    const insideProdPaths = lookAheadPathsPerAlternative[0]\n    const actualTokens = []\n    for (let i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i))\n    }\n    const msg = this.errorMessageProvider.buildEarlyExitMessage({\n      expectedIterationPaths: insideProdPaths,\n      actual: actualTokens,\n      previous: this.LA(0),\n      customUserDescription: userDefinedErrMsg,\n      ruleName: ruleName\n    })\n\n    throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)))\n  }\n\n  // TODO: consider caching the error message computed information\n  raiseNoAltException(\n    this: MixedInParser,\n    occurrence: number,\n    errMsgTypes: string\n  ): void {\n    const ruleName = this.getCurrRuleFullName()\n    const ruleGrammar = this.getGAstProductions()[ruleName]\n    // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n    const lookAheadPathsPerAlternative = getLookaheadPathsForOr(\n      occurrence,\n      ruleGrammar,\n      this.maxLookahead\n    )\n\n    const actualTokens = []\n    for (let i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i))\n    }\n    const previousToken = this.LA(0)\n\n    const errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n      expectedPathsPerAlt: lookAheadPathsPerAlternative,\n      actual: actualTokens,\n      previous: previousToken,\n      customUserDescription: errMsgTypes,\n      ruleName: this.getCurrRuleFullName()\n    })\n\n    throw this.SAVE_ERROR(\n      new NoViableAltException(errMsg, this.LA(1), previousToken)\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"script"}