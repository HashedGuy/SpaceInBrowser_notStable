{"ast":null,"code":"import _classCallCheck from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { DataTextureLoader, HalfFloatType, FloatType, RGBAFormat, LinearEncoding, RedFormat, LinearFilter, DataUtils } from 'three';\nimport { unzlibSync } from 'fflate';\n/**\n * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n// // End of OpenEXR license -------------------------------------------------\n\nvar EXRLoader = /*#__PURE__*/function (_DataTextureLoader) {\n  _inherits(EXRLoader, _DataTextureLoader);\n\n  var _super = _createSuper(EXRLoader);\n\n  function EXRLoader(manager) {\n    var _this;\n\n    _classCallCheck(this, EXRLoader);\n\n    _this = _super.call(this, manager);\n    _this.type = HalfFloatType;\n    return _this;\n  }\n\n  _createClass(EXRLoader, [{\n    key: \"parse\",\n    value: function parse(buffer) {\n      var USHORT_RANGE = 1 << 16;\n      var BITMAP_SIZE = USHORT_RANGE >> 3;\n      var HUF_ENCBITS = 16; // literal (value) bit length\n\n      var HUF_DECBITS = 14; // decoding bit size (>= 8)\n\n      var HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1; // encoding table size\n\n      var HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size\n\n      var HUF_DECMASK = HUF_DECSIZE - 1;\n      var NBITS = 16;\n      var A_OFFSET = 1 << NBITS - 1;\n      var MOD_MASK = (1 << NBITS) - 1;\n      var SHORT_ZEROCODE_RUN = 59;\n      var LONG_ZEROCODE_RUN = 63;\n      var SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n      var ULONG_SIZE = 8;\n      var FLOAT32_SIZE = 4;\n      var INT32_SIZE = 4;\n      var INT16_SIZE = 2;\n      var INT8_SIZE = 1;\n      var STATIC_HUFFMAN = 0;\n      var DEFLATE = 1;\n      var UNKNOWN = 0;\n      var LOSSY_DCT = 1;\n      var RLE = 2;\n      var logBase = Math.pow(2.7182818, 2.2);\n\n      function reverseLutFromBitmap(bitmap, lut) {\n        var k = 0;\n\n        for (var i = 0; i < USHORT_RANGE; ++i) {\n          if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n            lut[k++] = i;\n          }\n        }\n\n        var n = k - 1;\n\n        while (k < USHORT_RANGE) {\n          lut[k++] = 0;\n        }\n\n        return n;\n      }\n\n      function hufClearDecTable(hdec) {\n        for (var i = 0; i < HUF_DECSIZE; i++) {\n          hdec[i] = {};\n          hdec[i].len = 0;\n          hdec[i].lit = 0;\n          hdec[i].p = null;\n        }\n      }\n\n      var getBitsReturn = {\n        l: 0,\n        c: 0,\n        lc: 0\n      };\n\n      function getBits(nBits, c, lc, uInt8Array, inOffset) {\n        while (lc < nBits) {\n          c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n          lc += 8;\n        }\n\n        lc -= nBits;\n        getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n        getBitsReturn.c = c;\n        getBitsReturn.lc = lc;\n      }\n\n      var hufTableBuffer = new Array(59);\n\n      function hufCanonicalCodeTable(hcode) {\n        for (var i = 0; i <= 58; ++i) {\n          hufTableBuffer[i] = 0;\n        }\n\n        for (var i = 0; i < HUF_ENCSIZE; ++i) {\n          hufTableBuffer[hcode[i]] += 1;\n        }\n\n        var c = 0;\n\n        for (var i = 58; i > 0; --i) {\n          var nc = c + hufTableBuffer[i] >> 1;\n          hufTableBuffer[i] = c;\n          c = nc;\n        }\n\n        for (var i = 0; i < HUF_ENCSIZE; ++i) {\n          var l = hcode[i];\n          if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n        }\n      }\n\n      function hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {\n        var p = inOffset;\n        var c = 0;\n        var lc = 0;\n\n        for (; im <= iM; im++) {\n          if (p.value - inOffset.value > ni) return false;\n          getBits(6, c, lc, uInt8Array, p);\n          var l = getBitsReturn.l;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n          hcode[im] = l;\n\n          if (l == LONG_ZEROCODE_RUN) {\n            if (p.value - inOffset.value > ni) {\n              throw 'Something wrong with hufUnpackEncTable';\n            }\n\n            getBits(8, c, lc, uInt8Array, p);\n            var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n            c = getBitsReturn.c;\n            lc = getBitsReturn.lc;\n\n            if (im + zerun > iM + 1) {\n              throw 'Something wrong with hufUnpackEncTable';\n            }\n\n            while (zerun--) {\n              hcode[im++] = 0;\n            }\n\n            im--;\n          } else if (l >= SHORT_ZEROCODE_RUN) {\n            var zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n            if (im + zerun > iM + 1) {\n              throw 'Something wrong with hufUnpackEncTable';\n            }\n\n            while (zerun--) {\n              hcode[im++] = 0;\n            }\n\n            im--;\n          }\n        }\n\n        hufCanonicalCodeTable(hcode);\n      }\n\n      function hufLength(code) {\n        return code & 63;\n      }\n\n      function hufCode(code) {\n        return code >> 6;\n      }\n\n      function hufBuildDecTable(hcode, im, iM, hdecod) {\n        for (; im <= iM; im++) {\n          var c = hufCode(hcode[im]);\n          var l = hufLength(hcode[im]);\n\n          if (c >> l) {\n            throw 'Invalid table entry';\n          }\n\n          if (l > HUF_DECBITS) {\n            var pl = hdecod[c >> l - HUF_DECBITS];\n\n            if (pl.len) {\n              throw 'Invalid table entry';\n            }\n\n            pl.lit++;\n\n            if (pl.p) {\n              var p = pl.p;\n              pl.p = new Array(pl.lit);\n\n              for (var i = 0; i < pl.lit - 1; ++i) {\n                pl.p[i] = p[i];\n              }\n            } else {\n              pl.p = new Array(1);\n            }\n\n            pl.p[pl.lit - 1] = im;\n          } else if (l) {\n            var plOffset = 0;\n\n            for (var i = 1 << HUF_DECBITS - l; i > 0; i--) {\n              var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n\n              if (pl.len || pl.p) {\n                throw 'Invalid table entry';\n              }\n\n              pl.len = l;\n              pl.lit = im;\n              plOffset++;\n            }\n          }\n        }\n\n        return true;\n      }\n\n      var getCharReturn = {\n        c: 0,\n        lc: 0\n      };\n\n      function getChar(c, lc, uInt8Array, inOffset) {\n        c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n        lc += 8;\n        getCharReturn.c = c;\n        getCharReturn.lc = lc;\n      }\n\n      var getCodeReturn = {\n        c: 0,\n        lc: 0\n      };\n\n      function getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n        if (po == rlc) {\n          if (lc < 8) {\n            getChar(c, lc, uInt8Array, inOffset);\n            c = getCharReturn.c;\n            lc = getCharReturn.lc;\n          }\n\n          lc -= 8;\n          var cs = c >> lc;\n          var cs = new Uint8Array([cs])[0];\n\n          if (outBufferOffset.value + cs > outBufferEndOffset) {\n            return false;\n          }\n\n          var s = outBuffer[outBufferOffset.value - 1];\n\n          while (cs-- > 0) {\n            outBuffer[outBufferOffset.value++] = s;\n          }\n        } else if (outBufferOffset.value < outBufferEndOffset) {\n          outBuffer[outBufferOffset.value++] = po;\n        } else {\n          return false;\n        }\n\n        getCodeReturn.c = c;\n        getCodeReturn.lc = lc;\n      }\n\n      function UInt16(value) {\n        return value & 0xffff;\n      }\n\n      function Int16(value) {\n        var ref = UInt16(value);\n        return ref > 0x7fff ? ref - 0x10000 : ref;\n      }\n\n      var wdec14Return = {\n        a: 0,\n        b: 0\n      };\n\n      function wdec14(l, h) {\n        var ls = Int16(l);\n        var hs = Int16(h);\n        var hi = hs;\n        var ai = ls + (hi & 1) + (hi >> 1);\n        var as = ai;\n        var bs = ai - hi;\n        wdec14Return.a = as;\n        wdec14Return.b = bs;\n      }\n\n      function wdec16(l, h) {\n        var m = UInt16(l);\n        var d = UInt16(h);\n        var bb = m - (d >> 1) & MOD_MASK;\n        var aa = d + bb - A_OFFSET & MOD_MASK;\n        wdec14Return.a = aa;\n        wdec14Return.b = bb;\n      }\n\n      function wav2Decode(buffer, j, nx, ox, ny, oy, mx) {\n        var w14 = mx < 1 << 14;\n        var n = nx > ny ? ny : nx;\n        var p = 1;\n        var p2;\n\n        while (p <= n) {\n          p <<= 1;\n        }\n\n        p >>= 1;\n        p2 = p;\n        p >>= 1;\n\n        while (p >= 1) {\n          var py = 0;\n          var ey = py + oy * (ny - p2);\n          var oy1 = oy * p;\n          var oy2 = oy * p2;\n          var ox1 = ox * p;\n          var ox2 = ox * p2;\n          var i00, i01, i10, i11;\n\n          for (; py <= ey; py += oy2) {\n            var px = py;\n            var ex = py + ox * (nx - p2);\n\n            for (; px <= ex; px += ox2) {\n              var p01 = px + ox1;\n              var p10 = px + oy1;\n              var p11 = p10 + ox1;\n\n              if (w14) {\n                wdec14(buffer[px + j], buffer[p10 + j]);\n                i00 = wdec14Return.a;\n                i10 = wdec14Return.b;\n                wdec14(buffer[p01 + j], buffer[p11 + j]);\n                i01 = wdec14Return.a;\n                i11 = wdec14Return.b;\n                wdec14(i00, i01);\n                buffer[px + j] = wdec14Return.a;\n                buffer[p01 + j] = wdec14Return.b;\n                wdec14(i10, i11);\n                buffer[p10 + j] = wdec14Return.a;\n                buffer[p11 + j] = wdec14Return.b;\n              } else {\n                wdec16(buffer[px + j], buffer[p10 + j]);\n                i00 = wdec14Return.a;\n                i10 = wdec14Return.b;\n                wdec16(buffer[p01 + j], buffer[p11 + j]);\n                i01 = wdec14Return.a;\n                i11 = wdec14Return.b;\n                wdec16(i00, i01);\n                buffer[px + j] = wdec14Return.a;\n                buffer[p01 + j] = wdec14Return.b;\n                wdec16(i10, i11);\n                buffer[p10 + j] = wdec14Return.a;\n                buffer[p11 + j] = wdec14Return.b;\n              }\n            }\n\n            if (nx & p) {\n              var p10 = px + oy1;\n              if (w14) wdec14(buffer[px + j], buffer[p10 + j]);else wdec16(buffer[px + j], buffer[p10 + j]);\n              i00 = wdec14Return.a;\n              buffer[p10 + j] = wdec14Return.b;\n              buffer[px + j] = i00;\n            }\n          }\n\n          if (ny & p) {\n            var px = py;\n            var ex = py + ox * (nx - p2);\n\n            for (; px <= ex; px += ox2) {\n              var p01 = px + ox1;\n              if (w14) wdec14(buffer[px + j], buffer[p01 + j]);else wdec16(buffer[px + j], buffer[p01 + j]);\n              i00 = wdec14Return.a;\n              buffer[p01 + j] = wdec14Return.b;\n              buffer[px + j] = i00;\n            }\n          }\n\n          p2 = p;\n          p >>= 1;\n        }\n\n        return py;\n      }\n\n      function hufDecode(encodingTable, decodingTable, uInt8Array, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n        var c = 0;\n        var lc = 0;\n        var outBufferEndOffset = no;\n        var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n\n        while (inOffset.value < inOffsetEnd) {\n          getChar(c, lc, uInt8Array, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n\n          while (lc >= HUF_DECBITS) {\n            var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n            var pl = decodingTable[index];\n\n            if (pl.len) {\n              lc -= pl.len;\n              getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n              c = getCodeReturn.c;\n              lc = getCodeReturn.lc;\n            } else {\n              if (!pl.p) {\n                throw 'hufDecode issues';\n              }\n\n              var j;\n\n              for (j = 0; j < pl.lit; j++) {\n                var l = hufLength(encodingTable[pl.p[j]]);\n\n                while (lc < l && inOffset.value < inOffsetEnd) {\n                  getChar(c, lc, uInt8Array, inOffset);\n                  c = getCharReturn.c;\n                  lc = getCharReturn.lc;\n                }\n\n                if (lc >= l) {\n                  if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                    lc -= l;\n                    getCode(pl.p[j], rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                    c = getCodeReturn.c;\n                    lc = getCodeReturn.lc;\n                    break;\n                  }\n                }\n              }\n\n              if (j == pl.lit) {\n                throw 'hufDecode issues';\n              }\n            }\n          }\n        }\n\n        var i = 8 - ni & 7;\n        c >>= i;\n        lc -= i;\n\n        while (lc > 0) {\n          var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            throw 'hufDecode issues';\n          }\n        }\n\n        return true;\n      }\n\n      function hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n        var outOffset = {\n          value: 0\n        };\n        var initialInOffset = inOffset.value;\n        var im = parseUint32(inDataView, inOffset);\n        var iM = parseUint32(inDataView, inOffset);\n        inOffset.value += 4;\n        var nBits = parseUint32(inDataView, inOffset);\n        inOffset.value += 4;\n\n        if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n          throw 'Something wrong with HUF_ENCSIZE';\n        }\n\n        var freq = new Array(HUF_ENCSIZE);\n        var hdec = new Array(HUF_DECSIZE);\n        hufClearDecTable(hdec);\n        var ni = nCompressed - (inOffset.value - initialInOffset);\n        hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq);\n\n        if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n          throw 'Something wrong with hufUncompress';\n        }\n\n        hufBuildDecTable(freq, im, iM, hdec);\n        hufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n      }\n\n      function applyLut(lut, data, nData) {\n        for (var i = 0; i < nData; ++i) {\n          data[i] = lut[data[i]];\n        }\n      }\n\n      function predictor(source) {\n        for (var t = 1; t < source.length; t++) {\n          var d = source[t - 1] + source[t] - 128;\n          source[t] = d;\n        }\n      }\n\n      function interleaveScalar(source, out) {\n        var t1 = 0;\n        var t2 = Math.floor((source.length + 1) / 2);\n        var s = 0;\n        var stop = source.length - 1;\n\n        while (true) {\n          if (s > stop) break;\n          out[s++] = source[t1++];\n          if (s > stop) break;\n          out[s++] = source[t2++];\n        }\n      }\n\n      function decodeRunLength(source) {\n        var size = source.byteLength;\n        var out = new Array();\n        var p = 0;\n        var reader = new DataView(source);\n\n        while (size > 0) {\n          var l = reader.getInt8(p++);\n\n          if (l < 0) {\n            var count = -l;\n            size -= count + 1;\n\n            for (var i = 0; i < count; i++) {\n              out.push(reader.getUint8(p++));\n            }\n          } else {\n            var count = l;\n            size -= 2;\n            var value = reader.getUint8(p++);\n\n            for (var i = 0; i < count + 1; i++) {\n              out.push(value);\n            }\n          }\n        }\n\n        return out;\n      }\n\n      function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n        var dataView = new DataView(outBuffer.buffer);\n        var width = channelData[cscSet.idx[0]].width;\n        var height = channelData[cscSet.idx[0]].height;\n        var numComp = 3;\n        var numFullBlocksX = Math.floor(width / 8.0);\n        var numBlocksX = Math.ceil(width / 8.0);\n        var numBlocksY = Math.ceil(height / 8.0);\n        var leftoverX = width - (numBlocksX - 1) * 8;\n        var leftoverY = height - (numBlocksY - 1) * 8;\n        var currAcComp = {\n          value: 0\n        };\n        var currDcComp = new Array(numComp);\n        var dctData = new Array(numComp);\n        var halfZigBlock = new Array(numComp);\n        var rowBlock = new Array(numComp);\n        var rowOffsets = new Array(numComp);\n\n        for (var _comp = 0; _comp < numComp; ++_comp) {\n          rowOffsets[_comp] = rowPtrs[cscSet.idx[_comp]];\n          currDcComp[_comp] = _comp < 1 ? 0 : currDcComp[_comp - 1] + numBlocksX * numBlocksY;\n          dctData[_comp] = new Float32Array(64);\n          halfZigBlock[_comp] = new Uint16Array(64);\n          rowBlock[_comp] = new Uint16Array(numBlocksX * 64);\n        }\n\n        for (var blocky = 0; blocky < numBlocksY; ++blocky) {\n          var maxY = 8;\n          if (blocky == numBlocksY - 1) maxY = leftoverY;\n          var maxX = 8;\n\n          for (var blockx = 0; blockx < numBlocksX; ++blockx) {\n            if (blockx == numBlocksX - 1) maxX = leftoverX;\n\n            for (var _comp2 = 0; _comp2 < numComp; ++_comp2) {\n              halfZigBlock[_comp2].fill(0); // set block DC component\n\n\n              halfZigBlock[_comp2][0] = dcBuffer[currDcComp[_comp2]++]; // set block AC components\n\n              unRleAC(currAcComp, acBuffer, halfZigBlock[_comp2]); // UnZigZag block to float\n\n              unZigZag(halfZigBlock[_comp2], dctData[_comp2]); // decode float dct\n\n              dctInverse(dctData[_comp2]);\n            }\n\n            {\n              csc709Inverse(dctData);\n            }\n\n            for (var _comp3 = 0; _comp3 < numComp; ++_comp3) {\n              convertToHalf(dctData[_comp3], rowBlock[_comp3], blockx * 64);\n            }\n          } // blockx\n\n\n          var _offset = 0;\n\n          for (var _comp4 = 0; _comp4 < numComp; ++_comp4) {\n            var _type = channelData[cscSet.idx[_comp4]].type;\n\n            for (var _y = 8 * blocky; _y < 8 * blocky + maxY; ++_y) {\n              _offset = rowOffsets[_comp4][_y];\n\n              for (var _blockx = 0; _blockx < numFullBlocksX; ++_blockx) {\n                var src = _blockx * 64 + (_y & 0x7) * 8;\n                dataView.setUint16(_offset + 0 * INT16_SIZE * _type, rowBlock[_comp4][src + 0], true);\n                dataView.setUint16(_offset + 1 * INT16_SIZE * _type, rowBlock[_comp4][src + 1], true);\n                dataView.setUint16(_offset + 2 * INT16_SIZE * _type, rowBlock[_comp4][src + 2], true);\n                dataView.setUint16(_offset + 3 * INT16_SIZE * _type, rowBlock[_comp4][src + 3], true);\n                dataView.setUint16(_offset + 4 * INT16_SIZE * _type, rowBlock[_comp4][src + 4], true);\n                dataView.setUint16(_offset + 5 * INT16_SIZE * _type, rowBlock[_comp4][src + 5], true);\n                dataView.setUint16(_offset + 6 * INT16_SIZE * _type, rowBlock[_comp4][src + 6], true);\n                dataView.setUint16(_offset + 7 * INT16_SIZE * _type, rowBlock[_comp4][src + 7], true);\n                _offset += 8 * INT16_SIZE * _type;\n              }\n            } // handle partial X blocks\n\n\n            if (numFullBlocksX != numBlocksX) {\n              for (var _y2 = 8 * blocky; _y2 < 8 * blocky + maxY; ++_y2) {\n                var _offset2 = rowOffsets[_comp4][_y2] + 8 * numFullBlocksX * INT16_SIZE * _type;\n\n                var _src = numFullBlocksX * 64 + (_y2 & 0x7) * 8;\n\n                for (var _x = 0; _x < maxX; ++_x) {\n                  dataView.setUint16(_offset2 + _x * INT16_SIZE * _type, rowBlock[_comp4][_src + _x], true);\n                }\n              }\n            }\n          } // comp\n\n        } // blocky\n\n\n        var halfRow = new Uint16Array(width);\n        var dataView = new DataView(outBuffer.buffer); // convert channels back to float, if needed\n\n        for (var comp = 0; comp < numComp; ++comp) {\n          channelData[cscSet.idx[comp]].decoded = true;\n          var type = channelData[cscSet.idx[comp]].type;\n          if (channelData[comp].type != 2) continue;\n\n          for (var y = 0; y < height; ++y) {\n            var _offset3 = rowOffsets[comp][y];\n\n            for (var x = 0; x < width; ++x) {\n              halfRow[x] = dataView.getUint16(_offset3 + x * INT16_SIZE * type, true);\n            }\n\n            for (var x = 0; x < width; ++x) {\n              dataView.setFloat32(_offset3 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n            }\n          }\n        }\n      }\n\n      function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n        var acValue;\n        var dctComp = 1;\n\n        while (dctComp < 64) {\n          acValue = acBuffer[currAcComp.value];\n\n          if (acValue == 0xff00) {\n            dctComp = 64;\n          } else if (acValue >> 8 == 0xff) {\n            dctComp += acValue & 0xff;\n          } else {\n            halfZigBlock[dctComp] = acValue;\n            dctComp++;\n          }\n\n          currAcComp.value++;\n        }\n      }\n\n      function unZigZag(src, dst) {\n        dst[0] = decodeFloat16(src[0]);\n        dst[1] = decodeFloat16(src[1]);\n        dst[2] = decodeFloat16(src[5]);\n        dst[3] = decodeFloat16(src[6]);\n        dst[4] = decodeFloat16(src[14]);\n        dst[5] = decodeFloat16(src[15]);\n        dst[6] = decodeFloat16(src[27]);\n        dst[7] = decodeFloat16(src[28]);\n        dst[8] = decodeFloat16(src[2]);\n        dst[9] = decodeFloat16(src[4]);\n        dst[10] = decodeFloat16(src[7]);\n        dst[11] = decodeFloat16(src[13]);\n        dst[12] = decodeFloat16(src[16]);\n        dst[13] = decodeFloat16(src[26]);\n        dst[14] = decodeFloat16(src[29]);\n        dst[15] = decodeFloat16(src[42]);\n        dst[16] = decodeFloat16(src[3]);\n        dst[17] = decodeFloat16(src[8]);\n        dst[18] = decodeFloat16(src[12]);\n        dst[19] = decodeFloat16(src[17]);\n        dst[20] = decodeFloat16(src[25]);\n        dst[21] = decodeFloat16(src[30]);\n        dst[22] = decodeFloat16(src[41]);\n        dst[23] = decodeFloat16(src[43]);\n        dst[24] = decodeFloat16(src[9]);\n        dst[25] = decodeFloat16(src[11]);\n        dst[26] = decodeFloat16(src[18]);\n        dst[27] = decodeFloat16(src[24]);\n        dst[28] = decodeFloat16(src[31]);\n        dst[29] = decodeFloat16(src[40]);\n        dst[30] = decodeFloat16(src[44]);\n        dst[31] = decodeFloat16(src[53]);\n        dst[32] = decodeFloat16(src[10]);\n        dst[33] = decodeFloat16(src[19]);\n        dst[34] = decodeFloat16(src[23]);\n        dst[35] = decodeFloat16(src[32]);\n        dst[36] = decodeFloat16(src[39]);\n        dst[37] = decodeFloat16(src[45]);\n        dst[38] = decodeFloat16(src[52]);\n        dst[39] = decodeFloat16(src[54]);\n        dst[40] = decodeFloat16(src[20]);\n        dst[41] = decodeFloat16(src[22]);\n        dst[42] = decodeFloat16(src[33]);\n        dst[43] = decodeFloat16(src[38]);\n        dst[44] = decodeFloat16(src[46]);\n        dst[45] = decodeFloat16(src[51]);\n        dst[46] = decodeFloat16(src[55]);\n        dst[47] = decodeFloat16(src[60]);\n        dst[48] = decodeFloat16(src[21]);\n        dst[49] = decodeFloat16(src[34]);\n        dst[50] = decodeFloat16(src[37]);\n        dst[51] = decodeFloat16(src[47]);\n        dst[52] = decodeFloat16(src[50]);\n        dst[53] = decodeFloat16(src[56]);\n        dst[54] = decodeFloat16(src[59]);\n        dst[55] = decodeFloat16(src[61]);\n        dst[56] = decodeFloat16(src[35]);\n        dst[57] = decodeFloat16(src[36]);\n        dst[58] = decodeFloat16(src[48]);\n        dst[59] = decodeFloat16(src[49]);\n        dst[60] = decodeFloat16(src[57]);\n        dst[61] = decodeFloat16(src[58]);\n        dst[62] = decodeFloat16(src[62]);\n        dst[63] = decodeFloat16(src[63]);\n      }\n\n      function dctInverse(data) {\n        var a = 0.5 * Math.cos(3.14159 / 4.0);\n        var b = 0.5 * Math.cos(3.14159 / 16.0);\n        var c = 0.5 * Math.cos(3.14159 / 8.0);\n        var d = 0.5 * Math.cos(3.0 * 3.14159 / 16.0);\n        var e = 0.5 * Math.cos(5.0 * 3.14159 / 16.0);\n        var f = 0.5 * Math.cos(3.0 * 3.14159 / 8.0);\n        var g = 0.5 * Math.cos(7.0 * 3.14159 / 16.0);\n        var alpha = new Array(4);\n        var beta = new Array(4);\n        var theta = new Array(4);\n        var gamma = new Array(4);\n\n        for (var row = 0; row < 8; ++row) {\n          var rowPtr = row * 8;\n          alpha[0] = c * data[rowPtr + 2];\n          alpha[1] = f * data[rowPtr + 2];\n          alpha[2] = c * data[rowPtr + 6];\n          alpha[3] = f * data[rowPtr + 6];\n          beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n          beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n          beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n          beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n          theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n          theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n          theta[1] = alpha[0] + alpha[3];\n          theta[2] = alpha[1] - alpha[2];\n          gamma[0] = theta[0] + theta[1];\n          gamma[1] = theta[3] + theta[2];\n          gamma[2] = theta[3] - theta[2];\n          gamma[3] = theta[0] - theta[1];\n          data[rowPtr + 0] = gamma[0] + beta[0];\n          data[rowPtr + 1] = gamma[1] + beta[1];\n          data[rowPtr + 2] = gamma[2] + beta[2];\n          data[rowPtr + 3] = gamma[3] + beta[3];\n          data[rowPtr + 4] = gamma[3] - beta[3];\n          data[rowPtr + 5] = gamma[2] - beta[2];\n          data[rowPtr + 6] = gamma[1] - beta[1];\n          data[rowPtr + 7] = gamma[0] - beta[0];\n        }\n\n        for (var column = 0; column < 8; ++column) {\n          alpha[0] = c * data[16 + column];\n          alpha[1] = f * data[16 + column];\n          alpha[2] = c * data[48 + column];\n          alpha[3] = f * data[48 + column];\n          beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n          beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n          beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n          beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n          theta[0] = a * (data[column] + data[32 + column]);\n          theta[3] = a * (data[column] - data[32 + column]);\n          theta[1] = alpha[0] + alpha[3];\n          theta[2] = alpha[1] - alpha[2];\n          gamma[0] = theta[0] + theta[1];\n          gamma[1] = theta[3] + theta[2];\n          gamma[2] = theta[3] - theta[2];\n          gamma[3] = theta[0] - theta[1];\n          data[0 + column] = gamma[0] + beta[0];\n          data[8 + column] = gamma[1] + beta[1];\n          data[16 + column] = gamma[2] + beta[2];\n          data[24 + column] = gamma[3] + beta[3];\n          data[32 + column] = gamma[3] - beta[3];\n          data[40 + column] = gamma[2] - beta[2];\n          data[48 + column] = gamma[1] - beta[1];\n          data[56 + column] = gamma[0] - beta[0];\n        }\n      }\n\n      function csc709Inverse(data) {\n        for (var i = 0; i < 64; ++i) {\n          var y = data[0][i];\n          var cb = data[1][i];\n          var cr = data[2][i];\n          data[0][i] = y + 1.5747 * cr;\n          data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n          data[2][i] = y + 1.8556 * cb;\n        }\n      }\n\n      function convertToHalf(src, dst, idx) {\n        for (var i = 0; i < 64; ++i) {\n          dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));\n        }\n      }\n\n      function toLinear(float) {\n        if (float <= 1) {\n          return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n        } else {\n          return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1.0);\n        }\n      }\n\n      function uncompressRAW(info) {\n        return new DataView(info.array.buffer, info.offset.value, info.size);\n      }\n\n      function uncompressRLE(info) {\n        var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n        var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n        var tmpBuffer = new Uint8Array(rawBuffer.length);\n        predictor(rawBuffer); // revert predictor\n\n        interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n        return new DataView(tmpBuffer.buffer);\n      }\n\n      function uncompressZIP(info) {\n        var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n        var rawBuffer = unzlibSync(compressed); // eslint-disable-line no-undef\n\n        var tmpBuffer = new Uint8Array(rawBuffer.length);\n        predictor(rawBuffer); // revert predictor\n\n        interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n        return new DataView(tmpBuffer.buffer);\n      }\n\n      function uncompressPIZ(info) {\n        var inDataView = info.viewer;\n        var inOffset = {\n          value: info.offset.value\n        };\n        var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n        var bitmap = new Uint8Array(BITMAP_SIZE); // Setup channel info\n\n        var outBufferEnd = 0;\n        var pizChannelData = new Array(info.channels);\n\n        for (var i = 0; i < info.channels; i++) {\n          pizChannelData[i] = {};\n          pizChannelData[i]['start'] = outBufferEnd;\n          pizChannelData[i]['end'] = pizChannelData[i]['start'];\n          pizChannelData[i]['nx'] = info.width;\n          pizChannelData[i]['ny'] = info.lines;\n          pizChannelData[i]['size'] = info.type;\n          outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n        } // Read range compression data\n\n\n        var minNonZero = parseUint16(inDataView, inOffset);\n        var maxNonZero = parseUint16(inDataView, inOffset);\n\n        if (maxNonZero >= BITMAP_SIZE) {\n          throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE';\n        }\n\n        if (minNonZero <= maxNonZero) {\n          for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n            bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n          }\n        } // Reverse LUT\n\n\n        var lut = new Uint16Array(USHORT_RANGE);\n        var maxValue = reverseLutFromBitmap(bitmap, lut);\n        var length = parseUint32(inDataView, inOffset); // Huffman decoding\n\n        hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd); // Wavelet decoding\n\n        for (var i = 0; i < info.channels; ++i) {\n          var cd = pizChannelData[i];\n\n          for (var j = 0; j < pizChannelData[i].size; ++j) {\n            wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n          }\n        } // Expand the pixel data to their original range\n\n\n        applyLut(lut, outBuffer, outBufferEnd); // Rearrange the pixel data into the format expected by the caller.\n\n        var tmpOffset = 0;\n        var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n\n        for (var y = 0; y < info.lines; y++) {\n          for (var c = 0; c < info.channels; c++) {\n            var cd = pizChannelData[c];\n            var n = cd.nx * cd.size;\n            var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n            tmpBuffer.set(cp, tmpOffset);\n            tmpOffset += n * INT16_SIZE;\n            cd.end += n;\n          }\n        }\n\n        return new DataView(tmpBuffer.buffer);\n      }\n\n      function uncompressPXR(info) {\n        var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n        var rawBuffer = unzlibSync(compressed); // eslint-disable-line no-undef\n\n        var sz = info.lines * info.channels * info.width;\n        var tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n        var tmpBufferEnd = 0;\n        var writePtr = 0;\n        var ptr = new Array(4);\n\n        for (var y = 0; y < info.lines; y++) {\n          for (var c = 0; c < info.channels; c++) {\n            var pixel = 0;\n\n            switch (info.type) {\n              case 1:\n                ptr[0] = tmpBufferEnd;\n                ptr[1] = ptr[0] + info.width;\n                tmpBufferEnd = ptr[1] + info.width;\n\n                for (var j = 0; j < info.width; ++j) {\n                  var diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                  pixel += diff;\n                  tmpBuffer[writePtr] = pixel;\n                  writePtr++;\n                }\n\n                break;\n\n              case 2:\n                ptr[0] = tmpBufferEnd;\n                ptr[1] = ptr[0] + info.width;\n                ptr[2] = ptr[1] + info.width;\n                tmpBufferEnd = ptr[2] + info.width;\n\n                for (var _j = 0; _j < info.width; ++_j) {\n                  var _diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n\n                  pixel += _diff;\n                  tmpBuffer[writePtr] = pixel;\n                  writePtr++;\n                }\n\n                break;\n            }\n          }\n        }\n\n        return new DataView(tmpBuffer.buffer);\n      }\n\n      function uncompressDWA(info) {\n        var inDataView = info.viewer;\n        var inOffset = {\n          value: info.offset.value\n        };\n        var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE)); // Read compression header information\n\n        var dwaHeader = {\n          version: parseInt64(inDataView, inOffset),\n          unknownUncompressedSize: parseInt64(inDataView, inOffset),\n          unknownCompressedSize: parseInt64(inDataView, inOffset),\n          acCompressedSize: parseInt64(inDataView, inOffset),\n          dcCompressedSize: parseInt64(inDataView, inOffset),\n          rleCompressedSize: parseInt64(inDataView, inOffset),\n          rleUncompressedSize: parseInt64(inDataView, inOffset),\n          rleRawSize: parseInt64(inDataView, inOffset),\n          totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n          totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n          acCompression: parseInt64(inDataView, inOffset)\n        };\n\n        if (dwaHeader.version < 2) {\n          throw 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported';\n        } // Read channel ruleset information\n\n\n        var channelRules = new Array();\n        var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n\n        while (ruleSize > 0) {\n          var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n          var value = parseUint8(inDataView, inOffset);\n          var compression = value >> 2 & 3;\n          var csc = (value >> 4) - 1;\n          var index = new Int8Array([csc])[0];\n          var type = parseUint8(inDataView, inOffset);\n          channelRules.push({\n            name: name,\n            index: index,\n            type: type,\n            compression: compression\n          });\n          ruleSize -= name.length + 3;\n        } // Classify channels\n\n\n        var channels = EXRHeader.channels;\n        var channelData = new Array(info.channels);\n\n        for (var i = 0; i < info.channels; ++i) {\n          var cd = channelData[i] = {};\n          var channel = channels[i];\n          cd.name = channel.name;\n          cd.compression = UNKNOWN;\n          cd.decoded = false;\n          cd.type = channel.pixelType;\n          cd.pLinear = channel.pLinear;\n          cd.width = info.width;\n          cd.height = info.lines;\n        }\n\n        var cscSet = {\n          idx: new Array(3)\n        };\n\n        for (var offset = 0; offset < info.channels; ++offset) {\n          var cd = channelData[offset];\n\n          for (var i = 0; i < channelRules.length; ++i) {\n            var rule = channelRules[i];\n\n            if (cd.name == rule.name) {\n              cd.compression = rule.compression;\n\n              if (rule.index >= 0) {\n                cscSet.idx[rule.index] = offset;\n              }\n\n              cd.offset = offset;\n            }\n          }\n        } // Read DCT - AC component data\n\n\n        if (dwaHeader.acCompressedSize > 0) {\n          switch (dwaHeader.acCompression) {\n            case STATIC_HUFFMAN:\n              var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n              hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n              break;\n\n            case DEFLATE:\n              var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n              var data = unzlibSync(compressed); // eslint-disable-line no-undef\n\n              var acBuffer = new Uint16Array(data.buffer);\n              inOffset.value += dwaHeader.totalAcUncompressedCount;\n              break;\n          }\n        } // Read DCT - DC component data\n\n\n        if (dwaHeader.dcCompressedSize > 0) {\n          var zlibInfo = {\n            array: info.array,\n            offset: inOffset,\n            size: dwaHeader.dcCompressedSize\n          };\n          var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n          inOffset.value += dwaHeader.dcCompressedSize;\n        } // Read RLE compressed data\n\n\n        if (dwaHeader.rleRawSize > 0) {\n          var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n          var data = unzlibSync(compressed); // eslint-disable-line no-undef\n\n          var rleBuffer = decodeRunLength(data.buffer);\n          inOffset.value += dwaHeader.rleCompressedSize;\n        } // Prepare outbuffer data offset\n\n\n        var outBufferEnd = 0;\n        var rowOffsets = new Array(channelData.length);\n\n        for (var i = 0; i < rowOffsets.length; ++i) {\n          rowOffsets[i] = new Array();\n        }\n\n        for (var y = 0; y < info.lines; ++y) {\n          for (var chan = 0; chan < channelData.length; ++chan) {\n            rowOffsets[chan].push(outBufferEnd);\n            outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n          }\n        } // Lossy DCT decode RGB channels\n\n\n        lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer); // Decode other channels\n\n        for (var i = 0; i < channelData.length; ++i) {\n          var cd = channelData[i];\n          if (cd.decoded) continue;\n\n          switch (cd.compression) {\n            case RLE:\n              var row = 0;\n              var rleOffset = 0;\n\n              for (var y = 0; y < info.lines; ++y) {\n                var rowOffsetBytes = rowOffsets[i][row];\n\n                for (var x = 0; x < cd.width; ++x) {\n                  for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                    outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                  }\n\n                  rleOffset++;\n                }\n\n                row++;\n              }\n\n              break;\n\n            case LOSSY_DCT: // skip\n\n            default:\n              throw 'EXRLoader.parse: unsupported channel compression';\n          }\n        }\n\n        return new DataView(outBuffer.buffer);\n      }\n\n      function parseNullTerminatedString(buffer, offset) {\n        var uintBuffer = new Uint8Array(buffer);\n        var endOffset = 0;\n\n        while (uintBuffer[offset.value + endOffset] != 0) {\n          endOffset += 1;\n        }\n\n        var stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset));\n        offset.value = offset.value + endOffset + 1;\n        return stringValue;\n      }\n\n      function parseFixedLengthString(buffer, offset, size) {\n        var stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size));\n        offset.value = offset.value + size;\n        return stringValue;\n      }\n\n      function parseRational(dataView, offset) {\n        var x = parseInt32(dataView, offset);\n        var y = parseUint32(dataView, offset);\n        return [x, y];\n      }\n\n      function parseTimecode(dataView, offset) {\n        var x = parseUint32(dataView, offset);\n        var y = parseUint32(dataView, offset);\n        return [x, y];\n      }\n\n      function parseInt32(dataView, offset) {\n        var Int32 = dataView.getInt32(offset.value, true);\n        offset.value = offset.value + INT32_SIZE;\n        return Int32;\n      }\n\n      function parseUint32(dataView, offset) {\n        var Uint32 = dataView.getUint32(offset.value, true);\n        offset.value = offset.value + INT32_SIZE;\n        return Uint32;\n      }\n\n      function parseUint8Array(uInt8Array, offset) {\n        var Uint8 = uInt8Array[offset.value];\n        offset.value = offset.value + INT8_SIZE;\n        return Uint8;\n      }\n\n      function parseUint8(dataView, offset) {\n        var Uint8 = dataView.getUint8(offset.value);\n        offset.value = offset.value + INT8_SIZE;\n        return Uint8;\n      }\n\n      var parseInt64 = function parseInt64(dataView, offset) {\n        var int;\n\n        if ('getBigInt64' in DataView.prototype) {\n          int = Number(dataView.getBigInt64(offset.value, true));\n        } else {\n          int = dataView.getUint32(offset.value + 4, true) + Number(dataView.getUint32(offset.value, true) << 32);\n        }\n\n        offset.value += ULONG_SIZE;\n        return int;\n      };\n\n      function parseFloat32(dataView, offset) {\n        var float = dataView.getFloat32(offset.value, true);\n        offset.value += FLOAT32_SIZE;\n        return float;\n      }\n\n      function decodeFloat32(dataView, offset) {\n        return DataUtils.toHalfFloat(parseFloat32(dataView, offset));\n      } // https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n\n\n      function decodeFloat16(binary) {\n        var exponent = (binary & 0x7c00) >> 10,\n            fraction = binary & 0x03ff;\n        return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 0x1f ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 0x400) : 6.103515625e-5 * (fraction / 0x400));\n      }\n\n      function parseUint16(dataView, offset) {\n        var Uint16 = dataView.getUint16(offset.value, true);\n        offset.value += INT16_SIZE;\n        return Uint16;\n      }\n\n      function parseFloat16(buffer, offset) {\n        return decodeFloat16(parseUint16(buffer, offset));\n      }\n\n      function parseChlist(dataView, buffer, offset, size) {\n        var startOffset = offset.value;\n        var channels = [];\n\n        while (offset.value < startOffset + size - 1) {\n          var name = parseNullTerminatedString(buffer, offset);\n          var pixelType = parseInt32(dataView, offset);\n          var pLinear = parseUint8(dataView, offset);\n          offset.value += 3; // reserved, three chars\n\n          var xSampling = parseInt32(dataView, offset);\n          var ySampling = parseInt32(dataView, offset);\n          channels.push({\n            name: name,\n            pixelType: pixelType,\n            pLinear: pLinear,\n            xSampling: xSampling,\n            ySampling: ySampling\n          });\n        }\n\n        offset.value += 1;\n        return channels;\n      }\n\n      function parseChromaticities(dataView, offset) {\n        var redX = parseFloat32(dataView, offset);\n        var redY = parseFloat32(dataView, offset);\n        var greenX = parseFloat32(dataView, offset);\n        var greenY = parseFloat32(dataView, offset);\n        var blueX = parseFloat32(dataView, offset);\n        var blueY = parseFloat32(dataView, offset);\n        var whiteX = parseFloat32(dataView, offset);\n        var whiteY = parseFloat32(dataView, offset);\n        return {\n          redX: redX,\n          redY: redY,\n          greenX: greenX,\n          greenY: greenY,\n          blueX: blueX,\n          blueY: blueY,\n          whiteX: whiteX,\n          whiteY: whiteY\n        };\n      }\n\n      function parseCompression(dataView, offset) {\n        var compressionCodes = ['NO_COMPRESSION', 'RLE_COMPRESSION', 'ZIPS_COMPRESSION', 'ZIP_COMPRESSION', 'PIZ_COMPRESSION', 'PXR24_COMPRESSION', 'B44_COMPRESSION', 'B44A_COMPRESSION', 'DWAA_COMPRESSION', 'DWAB_COMPRESSION'];\n        var compression = parseUint8(dataView, offset);\n        return compressionCodes[compression];\n      }\n\n      function parseBox2i(dataView, offset) {\n        var xMin = parseUint32(dataView, offset);\n        var yMin = parseUint32(dataView, offset);\n        var xMax = parseUint32(dataView, offset);\n        var yMax = parseUint32(dataView, offset);\n        return {\n          xMin: xMin,\n          yMin: yMin,\n          xMax: xMax,\n          yMax: yMax\n        };\n      }\n\n      function parseLineOrder(dataView, offset) {\n        var lineOrders = ['INCREASING_Y'];\n        var lineOrder = parseUint8(dataView, offset);\n        return lineOrders[lineOrder];\n      }\n\n      function parseV2f(dataView, offset) {\n        var x = parseFloat32(dataView, offset);\n        var y = parseFloat32(dataView, offset);\n        return [x, y];\n      }\n\n      function parseV3f(dataView, offset) {\n        var x = parseFloat32(dataView, offset);\n        var y = parseFloat32(dataView, offset);\n        var z = parseFloat32(dataView, offset);\n        return [x, y, z];\n      }\n\n      function parseValue(dataView, buffer, offset, type, size) {\n        if (type === 'string' || type === 'stringvector' || type === 'iccProfile') {\n          return parseFixedLengthString(buffer, offset, size);\n        } else if (type === 'chlist') {\n          return parseChlist(dataView, buffer, offset, size);\n        } else if (type === 'chromaticities') {\n          return parseChromaticities(dataView, offset);\n        } else if (type === 'compression') {\n          return parseCompression(dataView, offset);\n        } else if (type === 'box2i') {\n          return parseBox2i(dataView, offset);\n        } else if (type === 'lineOrder') {\n          return parseLineOrder(dataView, offset);\n        } else if (type === 'float') {\n          return parseFloat32(dataView, offset);\n        } else if (type === 'v2f') {\n          return parseV2f(dataView, offset);\n        } else if (type === 'v3f') {\n          return parseV3f(dataView, offset);\n        } else if (type === 'int') {\n          return parseInt32(dataView, offset);\n        } else if (type === 'rational') {\n          return parseRational(dataView, offset);\n        } else if (type === 'timecode') {\n          return parseTimecode(dataView, offset);\n        } else if (type === 'preview') {\n          offset.value += size;\n          return 'skipped';\n        } else {\n          offset.value += size;\n          return undefined;\n        }\n      }\n\n      function parseHeader(dataView, buffer, offset) {\n        var EXRHeader = {};\n\n        if (dataView.getUint32(0, true) != 20000630) {\n          // magic\n          throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n        }\n\n        EXRHeader.version = dataView.getUint8(4);\n        var spec = dataView.getUint8(5); // fullMask\n\n        EXRHeader.spec = {\n          singleTile: !!(spec & 2),\n          longName: !!(spec & 4),\n          deepFormat: !!(spec & 8),\n          multiPart: !!(spec & 16)\n        }; // start of header\n\n        offset.value = 8; // start at 8 - after pre-amble\n\n        var keepReading = true;\n\n        while (keepReading) {\n          var attributeName = parseNullTerminatedString(buffer, offset);\n\n          if (attributeName == 0) {\n            keepReading = false;\n          } else {\n            var attributeType = parseNullTerminatedString(buffer, offset);\n            var attributeSize = parseUint32(dataView, offset);\n            var attributeValue = parseValue(dataView, buffer, offset, attributeType, attributeSize);\n\n            if (attributeValue === undefined) {\n              console.warn(\"EXRLoader.parse: skipped unknown header attribute type '\".concat(attributeType, \"'.\"));\n            } else {\n              EXRHeader[attributeName] = attributeValue;\n            }\n          }\n        }\n\n        if (spec != 0) {\n          console.error('EXRHeader:', EXRHeader);\n          throw 'THREE.EXRLoader: provided file is currently unsupported.';\n        }\n\n        return EXRHeader;\n      }\n\n      function setupDecoder(EXRHeader, dataView, uInt8Array, offset, outputType) {\n        var EXRDecoder = {\n          size: 0,\n          viewer: dataView,\n          array: uInt8Array,\n          offset: offset,\n          width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,\n          height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,\n          channels: EXRHeader.channels.length,\n          bytesPerLine: null,\n          lines: null,\n          inputSize: null,\n          type: EXRHeader.channels[0].pixelType,\n          uncompress: null,\n          getter: null,\n          format: null,\n          encoding: null\n        };\n\n        switch (EXRHeader.compression) {\n          case 'NO_COMPRESSION':\n            EXRDecoder.lines = 1;\n            EXRDecoder.uncompress = uncompressRAW;\n            break;\n\n          case 'RLE_COMPRESSION':\n            EXRDecoder.lines = 1;\n            EXRDecoder.uncompress = uncompressRLE;\n            break;\n\n          case 'ZIPS_COMPRESSION':\n            EXRDecoder.lines = 1;\n            EXRDecoder.uncompress = uncompressZIP;\n            break;\n\n          case 'ZIP_COMPRESSION':\n            EXRDecoder.lines = 16;\n            EXRDecoder.uncompress = uncompressZIP;\n            break;\n\n          case 'PIZ_COMPRESSION':\n            EXRDecoder.lines = 32;\n            EXRDecoder.uncompress = uncompressPIZ;\n            break;\n\n          case 'PXR24_COMPRESSION':\n            EXRDecoder.lines = 16;\n            EXRDecoder.uncompress = uncompressPXR;\n            break;\n\n          case 'DWAA_COMPRESSION':\n            EXRDecoder.lines = 32;\n            EXRDecoder.uncompress = uncompressDWA;\n            break;\n\n          case 'DWAB_COMPRESSION':\n            EXRDecoder.lines = 256;\n            EXRDecoder.uncompress = uncompressDWA;\n            break;\n\n          default:\n            throw 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported';\n        }\n\n        EXRDecoder.scanlineBlockSize = EXRDecoder.lines;\n\n        if (EXRDecoder.type == 1) {\n          // half\n          switch (outputType) {\n            case FloatType:\n              EXRDecoder.getter = parseFloat16;\n              EXRDecoder.inputSize = INT16_SIZE;\n              break;\n\n            case HalfFloatType:\n              EXRDecoder.getter = parseUint16;\n              EXRDecoder.inputSize = INT16_SIZE;\n              break;\n          }\n        } else if (EXRDecoder.type == 2) {\n          // float\n          switch (outputType) {\n            case FloatType:\n              EXRDecoder.getter = parseFloat32;\n              EXRDecoder.inputSize = FLOAT32_SIZE;\n              break;\n\n            case HalfFloatType:\n              EXRDecoder.getter = decodeFloat32;\n              EXRDecoder.inputSize = FLOAT32_SIZE;\n          }\n        } else {\n          throw 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.';\n        }\n\n        EXRDecoder.blockCount = (EXRHeader.dataWindow.yMax + 1) / EXRDecoder.scanlineBlockSize;\n\n        for (var i = 0; i < EXRDecoder.blockCount; i++) {\n          parseInt64(dataView, offset);\n        } // scanlineOffset\n        // we should be passed the scanline offset table, ready to start reading pixel data.\n        // RGB images will be converted to RGBA format, preventing software emulation in select devices.\n\n\n        EXRDecoder.outputChannels = EXRDecoder.channels == 3 ? 4 : EXRDecoder.channels;\n        var size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels;\n\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.byteArray = new Float32Array(size); // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n\n            if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(1, 0, size);\n            break;\n\n          case HalfFloatType:\n            EXRDecoder.byteArray = new Uint16Array(size);\n            if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(0x3c00, 0, size); // Uint16Array holds half float data, 0x3C00 is 1\n\n            break;\n\n          default:\n            console.error('THREE.EXRLoader: unsupported type: ', outputType);\n            break;\n        }\n\n        EXRDecoder.bytesPerLine = EXRDecoder.width * EXRDecoder.inputSize * EXRDecoder.channels;\n\n        if (EXRDecoder.outputChannels == 4) {\n          EXRDecoder.format = RGBAFormat;\n          EXRDecoder.encoding = LinearEncoding;\n        } else {\n          EXRDecoder.format = RedFormat;\n          EXRDecoder.encoding = LinearEncoding;\n        }\n\n        return EXRDecoder;\n      } // start parsing file [START]\n\n\n      var bufferDataView = new DataView(buffer);\n      var uInt8Array = new Uint8Array(buffer);\n      var offset = {\n        value: 0\n      }; // get header information and validate format.\n\n      var EXRHeader = parseHeader(bufferDataView, buffer, offset); // get input compression information and prepare decoding.\n\n      var EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n      var tmpOffset = {\n        value: 0\n      };\n      var channelOffsets = {\n        R: 0,\n        G: 1,\n        B: 2,\n        A: 3,\n        Y: 0\n      };\n\n      for (var scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++) {\n        var line = parseUint32(bufferDataView, offset); // line_no\n\n        EXRDecoder.size = parseUint32(bufferDataView, offset); // data_len\n\n        EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n        var isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n        var viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n        offset.value += EXRDecoder.size;\n\n        for (var line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n          var true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n          if (true_y >= EXRDecoder.height) break;\n\n          for (var channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n            var cOff = channelOffsets[EXRHeader.channels[channelID].name];\n\n            for (var x = 0; x < EXRDecoder.width; x++) {\n              tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n              var outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n              EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n            }\n          }\n        }\n      }\n\n      return {\n        header: EXRHeader,\n        width: EXRDecoder.width,\n        height: EXRDecoder.height,\n        data: EXRDecoder.byteArray,\n        format: EXRDecoder.format,\n        encoding: EXRDecoder.encoding,\n        type: this.type\n      };\n    }\n  }, {\n    key: \"setDataType\",\n    value: function setDataType(value) {\n      this.type = value;\n      return this;\n    }\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      function onLoadCallback(texture, texData) {\n        texture.encoding = texData.encoding;\n        texture.minFilter = LinearFilter;\n        texture.magFilter = LinearFilter;\n        texture.generateMipmaps = false;\n        texture.flipY = false;\n        if (onLoad) onLoad(texture, texData);\n      }\n\n      return _get(_getPrototypeOf(EXRLoader.prototype), \"load\", this).call(this, url, onLoadCallback, onProgress, onError);\n    }\n  }]);\n\n  return EXRLoader;\n}(DataTextureLoader);\n\nexport { EXRLoader };","map":{"version":3,"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/three-stdlib/loaders/EXRLoader.js"],"names":["DataTextureLoader","HalfFloatType","FloatType","RGBAFormat","LinearEncoding","RedFormat","LinearFilter","DataUtils","unzlibSync","EXRLoader","manager","type","buffer","USHORT_RANGE","BITMAP_SIZE","HUF_ENCBITS","HUF_DECBITS","HUF_ENCSIZE","HUF_DECSIZE","HUF_DECMASK","NBITS","A_OFFSET","MOD_MASK","SHORT_ZEROCODE_RUN","LONG_ZEROCODE_RUN","SHORTEST_LONG_RUN","ULONG_SIZE","FLOAT32_SIZE","INT32_SIZE","INT16_SIZE","INT8_SIZE","STATIC_HUFFMAN","DEFLATE","UNKNOWN","LOSSY_DCT","RLE","logBase","Math","pow","reverseLutFromBitmap","bitmap","lut","k","i","n","hufClearDecTable","hdec","len","lit","p","getBitsReturn","l","c","lc","getBits","nBits","uInt8Array","inOffset","parseUint8Array","hufTableBuffer","Array","hufCanonicalCodeTable","hcode","nc","hufUnpackEncTable","inDataView","ni","im","iM","value","zerun","hufLength","code","hufCode","hufBuildDecTable","hdecod","pl","plOffset","getCharReturn","getChar","getCodeReturn","getCode","po","rlc","outBuffer","outBufferOffset","outBufferEndOffset","cs","Uint8Array","s","UInt16","Int16","ref","wdec14Return","a","b","wdec14","h","ls","hs","hi","ai","as","bs","wdec16","m","d","bb","aa","wav2Decode","j","nx","ox","ny","oy","mx","w14","p2","py","ey","oy1","oy2","ox1","ox2","i00","i01","i10","i11","px","ex","p01","p10","p11","hufDecode","encodingTable","decodingTable","no","outOffset","inOffsetEnd","trunc","index","hufUncompress","nCompressed","nRaw","initialInOffset","parseUint32","freq","applyLut","data","nData","predictor","source","t","length","interleaveScalar","out","t1","t2","floor","stop","decodeRunLength","size","byteLength","reader","DataView","getInt8","count","push","getUint8","lossyDctDecode","cscSet","rowPtrs","channelData","acBuffer","dcBuffer","dataView","width","idx","height","numComp","numFullBlocksX","numBlocksX","ceil","numBlocksY","leftoverX","leftoverY","currAcComp","currDcComp","dctData","halfZigBlock","rowBlock","rowOffsets","comp","Float32Array","Uint16Array","blocky","maxY","maxX","blockx","fill","unRleAC","unZigZag","dctInverse","csc709Inverse","convertToHalf","offset","y","src","setUint16","x","halfRow","decoded","getUint16","setFloat32","decodeFloat16","acValue","dctComp","dst","cos","e","f","g","alpha","beta","theta","gamma","row","rowPtr","column","cb","cr","toHalfFloat","toLinear","float","sign","abs","uncompressRAW","info","array","uncompressRLE","compressed","viewer","slice","rawBuffer","tmpBuffer","uncompressZIP","uncompressPIZ","scanlineBlockSize","channels","outBufferEnd","pizChannelData","lines","minNonZero","parseUint16","maxNonZero","parseUint8","maxValue","cd","start","tmpOffset","cp","end","set","uncompressPXR","sz","Uint32Array","tmpBufferEnd","writePtr","ptr","pixel","diff","uncompressDWA","dwaHeader","version","parseInt64","unknownUncompressedSize","unknownCompressedSize","acCompressedSize","dcCompressedSize","rleCompressedSize","rleUncompressedSize","rleRawSize","totalAcUncompressedCount","totalDcUncompressedCount","acCompression","EXRHeader","compression","channelRules","ruleSize","name","parseNullTerminatedString","csc","Int8Array","channel","pixelType","pLinear","rule","zlibInfo","rleBuffer","chan","rleOffset","rowOffsetBytes","byte","uintBuffer","endOffset","stringValue","TextDecoder","decode","parseFixedLengthString","parseRational","parseInt32","parseTimecode","Int32","getInt32","Uint32","getUint32","Uint8","int","prototype","Number","getBigInt64","parseFloat32","getFloat32","decodeFloat32","binary","exponent","fraction","NaN","Infinity","Uint16","parseFloat16","parseChlist","startOffset","xSampling","ySampling","parseChromaticities","redX","redY","greenX","greenY","blueX","blueY","whiteX","whiteY","parseCompression","compressionCodes","parseBox2i","xMin","yMin","xMax","yMax","parseLineOrder","lineOrders","lineOrder","parseV2f","parseV3f","z","parseValue","undefined","parseHeader","spec","singleTile","longName","deepFormat","multiPart","keepReading","attributeName","attributeType","attributeSize","attributeValue","console","warn","error","setupDecoder","outputType","EXRDecoder","dataWindow","bytesPerLine","inputSize","uncompress","getter","format","encoding","blockCount","outputChannels","byteArray","bufferDataView","channelOffsets","R","G","B","A","Y","scanlineBlockIdx","line","isCompressed","line_y","true_y","channelID","cOff","outIndex","header","url","onLoad","onProgress","onError","onLoadCallback","texture","texData","minFilter","magFilter","generateMipmaps","flipY"],"mappings":";;;;;;AAAA,SAASA,iBAAT,EAA4BC,aAA5B,EAA2CC,SAA3C,EAAsDC,UAAtD,EAAkEC,cAAlE,EAAkFC,SAAlF,EAA6FC,YAA7F,EAA2GC,SAA3G,QAA4H,OAA5H;AACA,SAASC,UAAT,QAA2B,QAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAEMC,S;;;;;AACJ,qBAAYC,OAAZ,EAAqB;AAAA;;AAAA;;AACnB,8BAAMA,OAAN;AACA,UAAKC,IAAL,GAAYV,aAAZ;AAFmB;AAGpB;;;;WAED,eAAMW,MAAN,EAAc;AACZ,UAAMC,YAAY,GAAG,KAAK,EAA1B;AACA,UAAMC,WAAW,GAAGD,YAAY,IAAI,CAApC;AACA,UAAME,WAAW,GAAG,EAApB,CAHY,CAGY;;AAExB,UAAMC,WAAW,GAAG,EAApB,CALY,CAKY;;AAExB,UAAMC,WAAW,GAAG,CAAC,KAAKF,WAAN,IAAqB,CAAzC,CAPY,CAOgC;;AAE5C,UAAMG,WAAW,GAAG,KAAKF,WAAzB,CATY,CAS0B;;AAEtC,UAAMG,WAAW,GAAGD,WAAW,GAAG,CAAlC;AACA,UAAME,KAAK,GAAG,EAAd;AACA,UAAMC,QAAQ,GAAG,KAAKD,KAAK,GAAG,CAA9B;AACA,UAAME,QAAQ,GAAG,CAAC,KAAKF,KAAN,IAAe,CAAhC;AACA,UAAMG,kBAAkB,GAAG,EAA3B;AACA,UAAMC,iBAAiB,GAAG,EAA1B;AACA,UAAMC,iBAAiB,GAAG,IAAID,iBAAJ,GAAwBD,kBAAlD;AACA,UAAMG,UAAU,GAAG,CAAnB;AACA,UAAMC,YAAY,GAAG,CAArB;AACA,UAAMC,UAAU,GAAG,CAAnB;AACA,UAAMC,UAAU,GAAG,CAAnB;AACA,UAAMC,SAAS,GAAG,CAAlB;AACA,UAAMC,cAAc,GAAG,CAAvB;AACA,UAAMC,OAAO,GAAG,CAAhB;AACA,UAAMC,OAAO,GAAG,CAAhB;AACA,UAAMC,SAAS,GAAG,CAAlB;AACA,UAAMC,GAAG,GAAG,CAAZ;AACA,UAAMC,OAAO,GAAGC,IAAI,CAACC,GAAL,CAAS,SAAT,EAAoB,GAApB,CAAhB;;AAEA,eAASC,oBAAT,CAA8BC,MAA9B,EAAsCC,GAAtC,EAA2C;AACzC,YAAIC,CAAC,GAAG,CAAR;;AAEA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG9B,YAApB,EAAkC,EAAE8B,CAApC,EAAuC;AACrC,cAAIA,CAAC,IAAI,CAAL,IAAUH,MAAM,CAACG,CAAC,IAAI,CAAN,CAAN,GAAiB,MAAMA,CAAC,GAAG,CAAV,CAA/B,EAA6C;AAC3CF,YAAAA,GAAG,CAACC,CAAC,EAAF,CAAH,GAAWC,CAAX;AACD;AACF;;AAED,YAAIC,CAAC,GAAGF,CAAC,GAAG,CAAZ;;AAEA,eAAOA,CAAC,GAAG7B,YAAX;AAAyB4B,UAAAA,GAAG,CAACC,CAAC,EAAF,CAAH,GAAW,CAAX;AAAzB;;AAEA,eAAOE,CAAP;AACD;;AAED,eAASC,gBAAT,CAA0BC,IAA1B,EAAgC;AAC9B,aAAK,IAAIH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGzB,WAApB,EAAiCyB,CAAC,EAAlC,EAAsC;AACpCG,UAAAA,IAAI,CAACH,CAAD,CAAJ,GAAU,EAAV;AACAG,UAAAA,IAAI,CAACH,CAAD,CAAJ,CAAQI,GAAR,GAAc,CAAd;AACAD,UAAAA,IAAI,CAACH,CAAD,CAAJ,CAAQK,GAAR,GAAc,CAAd;AACAF,UAAAA,IAAI,CAACH,CAAD,CAAJ,CAAQM,CAAR,GAAY,IAAZ;AACD;AACF;;AAED,UAAMC,aAAa,GAAG;AACpBC,QAAAA,CAAC,EAAE,CADiB;AAEpBC,QAAAA,CAAC,EAAE,CAFiB;AAGpBC,QAAAA,EAAE,EAAE;AAHgB,OAAtB;;AAMA,eAASC,OAAT,CAAiBC,KAAjB,EAAwBH,CAAxB,EAA2BC,EAA3B,EAA+BG,UAA/B,EAA2CC,QAA3C,EAAqD;AACnD,eAAOJ,EAAE,GAAGE,KAAZ,EAAmB;AACjBH,UAAAA,CAAC,GAAGA,CAAC,IAAI,CAAL,GAASM,eAAe,CAACF,UAAD,EAAaC,QAAb,CAA5B;AACAJ,UAAAA,EAAE,IAAI,CAAN;AACD;;AAEDA,QAAAA,EAAE,IAAIE,KAAN;AACAL,QAAAA,aAAa,CAACC,CAAd,GAAkBC,CAAC,IAAIC,EAAL,GAAU,CAAC,KAAKE,KAAN,IAAe,CAA3C;AACAL,QAAAA,aAAa,CAACE,CAAd,GAAkBA,CAAlB;AACAF,QAAAA,aAAa,CAACG,EAAd,GAAmBA,EAAnB;AACD;;AAED,UAAMM,cAAc,GAAG,IAAIC,KAAJ,CAAU,EAAV,CAAvB;;AAEA,eAASC,qBAAT,CAA+BC,KAA/B,EAAsC;AACpC,aAAK,IAAInB,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,EAArB,EAAyB,EAAEA,CAA3B;AAA8BgB,UAAAA,cAAc,CAAChB,CAAD,CAAd,GAAoB,CAApB;AAA9B;;AAEA,aAAK,IAAIA,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG1B,WAApB,EAAiC,EAAE0B,CAAnC;AAAsCgB,UAAAA,cAAc,CAACG,KAAK,CAACnB,CAAD,CAAN,CAAd,IAA4B,CAA5B;AAAtC;;AAEA,YAAIS,CAAC,GAAG,CAAR;;AAEA,aAAK,IAAIT,CAAC,GAAG,EAAb,EAAiBA,CAAC,GAAG,CAArB,EAAwB,EAAEA,CAA1B,EAA6B;AAC3B,cAAIoB,EAAE,GAAGX,CAAC,GAAGO,cAAc,CAAChB,CAAD,CAAlB,IAAyB,CAAlC;AACAgB,UAAAA,cAAc,CAAChB,CAAD,CAAd,GAAoBS,CAApB;AACAA,UAAAA,CAAC,GAAGW,EAAJ;AACD;;AAED,aAAK,IAAIpB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG1B,WAApB,EAAiC,EAAE0B,CAAnC,EAAsC;AACpC,cAAIQ,CAAC,GAAGW,KAAK,CAACnB,CAAD,CAAb;AACA,cAAIQ,CAAC,GAAG,CAAR,EAAWW,KAAK,CAACnB,CAAD,CAAL,GAAWQ,CAAC,GAAGQ,cAAc,CAACR,CAAD,CAAd,MAAuB,CAAtC;AACZ;AACF;;AAED,eAASa,iBAAT,CAA2BR,UAA3B,EAAuCS,UAAvC,EAAmDR,QAAnD,EAA6DS,EAA7D,EAAiEC,EAAjE,EAAqEC,EAArE,EAAyEN,KAAzE,EAAgF;AAC9E,YAAIb,CAAC,GAAGQ,QAAR;AACA,YAAIL,CAAC,GAAG,CAAR;AACA,YAAIC,EAAE,GAAG,CAAT;;AAEA,eAAOc,EAAE,IAAIC,EAAb,EAAiBD,EAAE,EAAnB,EAAuB;AACrB,cAAIlB,CAAC,CAACoB,KAAF,GAAUZ,QAAQ,CAACY,KAAnB,GAA2BH,EAA/B,EAAmC,OAAO,KAAP;AACnCZ,UAAAA,OAAO,CAAC,CAAD,EAAIF,CAAJ,EAAOC,EAAP,EAAWG,UAAX,EAAuBP,CAAvB,CAAP;AACA,cAAIE,CAAC,GAAGD,aAAa,CAACC,CAAtB;AACAC,UAAAA,CAAC,GAAGF,aAAa,CAACE,CAAlB;AACAC,UAAAA,EAAE,GAAGH,aAAa,CAACG,EAAnB;AACAS,UAAAA,KAAK,CAACK,EAAD,CAAL,GAAYhB,CAAZ;;AAEA,cAAIA,CAAC,IAAI3B,iBAAT,EAA4B;AAC1B,gBAAIyB,CAAC,CAACoB,KAAF,GAAUZ,QAAQ,CAACY,KAAnB,GAA2BH,EAA/B,EAAmC;AACjC,oBAAM,wCAAN;AACD;;AAEDZ,YAAAA,OAAO,CAAC,CAAD,EAAIF,CAAJ,EAAOC,EAAP,EAAWG,UAAX,EAAuBP,CAAvB,CAAP;AACA,gBAAIqB,KAAK,GAAGpB,aAAa,CAACC,CAAd,GAAkB1B,iBAA9B;AACA2B,YAAAA,CAAC,GAAGF,aAAa,CAACE,CAAlB;AACAC,YAAAA,EAAE,GAAGH,aAAa,CAACG,EAAnB;;AAEA,gBAAIc,EAAE,GAAGG,KAAL,GAAaF,EAAE,GAAG,CAAtB,EAAyB;AACvB,oBAAM,wCAAN;AACD;;AAED,mBAAOE,KAAK,EAAZ;AAAgBR,cAAAA,KAAK,CAACK,EAAE,EAAH,CAAL,GAAc,CAAd;AAAhB;;AAEAA,YAAAA,EAAE;AACH,WAjBD,MAiBO,IAAIhB,CAAC,IAAI5B,kBAAT,EAA6B;AAClC,gBAAI+C,KAAK,GAAGnB,CAAC,GAAG5B,kBAAJ,GAAyB,CAArC;;AAEA,gBAAI4C,EAAE,GAAGG,KAAL,GAAaF,EAAE,GAAG,CAAtB,EAAyB;AACvB,oBAAM,wCAAN;AACD;;AAED,mBAAOE,KAAK,EAAZ;AAAgBR,cAAAA,KAAK,CAACK,EAAE,EAAH,CAAL,GAAc,CAAd;AAAhB;;AAEAA,YAAAA,EAAE;AACH;AACF;;AAEDN,QAAAA,qBAAqB,CAACC,KAAD,CAArB;AACD;;AAED,eAASS,SAAT,CAAmBC,IAAnB,EAAyB;AACvB,eAAOA,IAAI,GAAG,EAAd;AACD;;AAED,eAASC,OAAT,CAAiBD,IAAjB,EAAuB;AACrB,eAAOA,IAAI,IAAI,CAAf;AACD;;AAED,eAASE,gBAAT,CAA0BZ,KAA1B,EAAiCK,EAAjC,EAAqCC,EAArC,EAAyCO,MAAzC,EAAiD;AAC/C,eAAOR,EAAE,IAAIC,EAAb,EAAiBD,EAAE,EAAnB,EAAuB;AACrB,cAAIf,CAAC,GAAGqB,OAAO,CAACX,KAAK,CAACK,EAAD,CAAN,CAAf;AACA,cAAIhB,CAAC,GAAGoB,SAAS,CAACT,KAAK,CAACK,EAAD,CAAN,CAAjB;;AAEA,cAAIf,CAAC,IAAID,CAAT,EAAY;AACV,kBAAM,qBAAN;AACD;;AAED,cAAIA,CAAC,GAAGnC,WAAR,EAAqB;AACnB,gBAAI4D,EAAE,GAAGD,MAAM,CAACvB,CAAC,IAAID,CAAC,GAAGnC,WAAV,CAAf;;AAEA,gBAAI4D,EAAE,CAAC7B,GAAP,EAAY;AACV,oBAAM,qBAAN;AACD;;AAED6B,YAAAA,EAAE,CAAC5B,GAAH;;AAEA,gBAAI4B,EAAE,CAAC3B,CAAP,EAAU;AACR,kBAAIA,CAAC,GAAG2B,EAAE,CAAC3B,CAAX;AACA2B,cAAAA,EAAE,CAAC3B,CAAH,GAAO,IAAIW,KAAJ,CAAUgB,EAAE,CAAC5B,GAAb,CAAP;;AAEA,mBAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiC,EAAE,CAAC5B,GAAH,GAAS,CAA7B,EAAgC,EAAEL,CAAlC,EAAqC;AACnCiC,gBAAAA,EAAE,CAAC3B,CAAH,CAAKN,CAAL,IAAUM,CAAC,CAACN,CAAD,CAAX;AACD;AACF,aAPD,MAOO;AACLiC,cAAAA,EAAE,CAAC3B,CAAH,GAAO,IAAIW,KAAJ,CAAU,CAAV,CAAP;AACD;;AAEDgB,YAAAA,EAAE,CAAC3B,CAAH,CAAK2B,EAAE,CAAC5B,GAAH,GAAS,CAAd,IAAmBmB,EAAnB;AACD,WArBD,MAqBO,IAAIhB,CAAJ,EAAO;AACZ,gBAAI0B,QAAQ,GAAG,CAAf;;AAEA,iBAAK,IAAIlC,CAAC,GAAG,KAAK3B,WAAW,GAAGmC,CAAhC,EAAmCR,CAAC,GAAG,CAAvC,EAA0CA,CAAC,EAA3C,EAA+C;AAC7C,kBAAIiC,EAAE,GAAGD,MAAM,CAAC,CAACvB,CAAC,IAAIpC,WAAW,GAAGmC,CAApB,IAAyB0B,QAA1B,CAAf;;AAEA,kBAAID,EAAE,CAAC7B,GAAH,IAAU6B,EAAE,CAAC3B,CAAjB,EAAoB;AAClB,sBAAM,qBAAN;AACD;;AAED2B,cAAAA,EAAE,CAAC7B,GAAH,GAASI,CAAT;AACAyB,cAAAA,EAAE,CAAC5B,GAAH,GAASmB,EAAT;AACAU,cAAAA,QAAQ;AACT;AACF;AACF;;AAED,eAAO,IAAP;AACD;;AAED,UAAMC,aAAa,GAAG;AACpB1B,QAAAA,CAAC,EAAE,CADiB;AAEpBC,QAAAA,EAAE,EAAE;AAFgB,OAAtB;;AAKA,eAAS0B,OAAT,CAAiB3B,CAAjB,EAAoBC,EAApB,EAAwBG,UAAxB,EAAoCC,QAApC,EAA8C;AAC5CL,QAAAA,CAAC,GAAGA,CAAC,IAAI,CAAL,GAASM,eAAe,CAACF,UAAD,EAAaC,QAAb,CAA5B;AACAJ,QAAAA,EAAE,IAAI,CAAN;AACAyB,QAAAA,aAAa,CAAC1B,CAAd,GAAkBA,CAAlB;AACA0B,QAAAA,aAAa,CAACzB,EAAd,GAAmBA,EAAnB;AACD;;AAED,UAAM2B,aAAa,GAAG;AACpB5B,QAAAA,CAAC,EAAE,CADiB;AAEpBC,QAAAA,EAAE,EAAE;AAFgB,OAAtB;;AAKA,eAAS4B,OAAT,CAAiBC,EAAjB,EAAqBC,GAArB,EAA0B/B,CAA1B,EAA6BC,EAA7B,EAAiCG,UAAjC,EAA6CS,UAA7C,EAAyDR,QAAzD,EAAmE2B,SAAnE,EAA8EC,eAA9E,EAA+FC,kBAA/F,EAAmH;AACjH,YAAIJ,EAAE,IAAIC,GAAV,EAAe;AACb,cAAI9B,EAAE,GAAG,CAAT,EAAY;AACV0B,YAAAA,OAAO,CAAC3B,CAAD,EAAIC,EAAJ,EAAQG,UAAR,EAAoBC,QAApB,CAAP;AACAL,YAAAA,CAAC,GAAG0B,aAAa,CAAC1B,CAAlB;AACAC,YAAAA,EAAE,GAAGyB,aAAa,CAACzB,EAAnB;AACD;;AAEDA,UAAAA,EAAE,IAAI,CAAN;AACA,cAAIkC,EAAE,GAAGnC,CAAC,IAAIC,EAAd;AACA,cAAIkC,EAAE,GAAG,IAAIC,UAAJ,CAAe,CAACD,EAAD,CAAf,EAAqB,CAArB,CAAT;;AAEA,cAAIF,eAAe,CAAChB,KAAhB,GAAwBkB,EAAxB,GAA6BD,kBAAjC,EAAqD;AACnD,mBAAO,KAAP;AACD;;AAED,cAAIG,CAAC,GAAGL,SAAS,CAACC,eAAe,CAAChB,KAAhB,GAAwB,CAAzB,CAAjB;;AAEA,iBAAOkB,EAAE,KAAK,CAAd,EAAiB;AACfH,YAAAA,SAAS,CAACC,eAAe,CAAChB,KAAhB,EAAD,CAAT,GAAqCoB,CAArC;AACD;AACF,SApBD,MAoBO,IAAIJ,eAAe,CAAChB,KAAhB,GAAwBiB,kBAA5B,EAAgD;AACrDF,UAAAA,SAAS,CAACC,eAAe,CAAChB,KAAhB,EAAD,CAAT,GAAqCa,EAArC;AACD,SAFM,MAEA;AACL,iBAAO,KAAP;AACD;;AAEDF,QAAAA,aAAa,CAAC5B,CAAd,GAAkBA,CAAlB;AACA4B,QAAAA,aAAa,CAAC3B,EAAd,GAAmBA,EAAnB;AACD;;AAED,eAASqC,MAAT,CAAgBrB,KAAhB,EAAuB;AACrB,eAAOA,KAAK,GAAG,MAAf;AACD;;AAED,eAASsB,KAAT,CAAetB,KAAf,EAAsB;AACpB,YAAIuB,GAAG,GAAGF,MAAM,CAACrB,KAAD,CAAhB;AACA,eAAOuB,GAAG,GAAG,MAAN,GAAeA,GAAG,GAAG,OAArB,GAA+BA,GAAtC;AACD;;AAED,UAAMC,YAAY,GAAG;AACnBC,QAAAA,CAAC,EAAE,CADgB;AAEnBC,QAAAA,CAAC,EAAE;AAFgB,OAArB;;AAKA,eAASC,MAAT,CAAgB7C,CAAhB,EAAmB8C,CAAnB,EAAsB;AACpB,YAAIC,EAAE,GAAGP,KAAK,CAACxC,CAAD,CAAd;AACA,YAAIgD,EAAE,GAAGR,KAAK,CAACM,CAAD,CAAd;AACA,YAAIG,EAAE,GAAGD,EAAT;AACA,YAAIE,EAAE,GAAGH,EAAE,IAAIE,EAAE,GAAG,CAAT,CAAF,IAAiBA,EAAE,IAAI,CAAvB,CAAT;AACA,YAAIE,EAAE,GAAGD,EAAT;AACA,YAAIE,EAAE,GAAGF,EAAE,GAAGD,EAAd;AACAP,QAAAA,YAAY,CAACC,CAAb,GAAiBQ,EAAjB;AACAT,QAAAA,YAAY,CAACE,CAAb,GAAiBQ,EAAjB;AACD;;AAED,eAASC,MAAT,CAAgBrD,CAAhB,EAAmB8C,CAAnB,EAAsB;AACpB,YAAIQ,CAAC,GAAGf,MAAM,CAACvC,CAAD,CAAd;AACA,YAAIuD,CAAC,GAAGhB,MAAM,CAACO,CAAD,CAAd;AACA,YAAIU,EAAE,GAAGF,CAAC,IAAIC,CAAC,IAAI,CAAT,CAAD,GAAepF,QAAxB;AACA,YAAIsF,EAAE,GAAGF,CAAC,GAAGC,EAAJ,GAAStF,QAAT,GAAoBC,QAA7B;AACAuE,QAAAA,YAAY,CAACC,CAAb,GAAiBc,EAAjB;AACAf,QAAAA,YAAY,CAACE,CAAb,GAAiBY,EAAjB;AACD;;AAED,eAASE,UAAT,CAAoBjG,MAApB,EAA4BkG,CAA5B,EAA+BC,EAA/B,EAAmCC,EAAnC,EAAuCC,EAAvC,EAA2CC,EAA3C,EAA+CC,EAA/C,EAAmD;AACjD,YAAIC,GAAG,GAAGD,EAAE,GAAG,KAAK,EAApB;AACA,YAAIvE,CAAC,GAAGmE,EAAE,GAAGE,EAAL,GAAUA,EAAV,GAAeF,EAAvB;AACA,YAAI9D,CAAC,GAAG,CAAR;AACA,YAAIoE,EAAJ;;AAEA,eAAOpE,CAAC,IAAIL,CAAZ;AAAeK,UAAAA,CAAC,KAAK,CAAN;AAAf;;AAEAA,QAAAA,CAAC,KAAK,CAAN;AACAoE,QAAAA,EAAE,GAAGpE,CAAL;AACAA,QAAAA,CAAC,KAAK,CAAN;;AAEA,eAAOA,CAAC,IAAI,CAAZ,EAAe;AACb,cAAIqE,EAAE,GAAG,CAAT;AACA,cAAIC,EAAE,GAAGD,EAAE,GAAGJ,EAAE,IAAID,EAAE,GAAGI,EAAT,CAAhB;AACA,cAAIG,GAAG,GAAGN,EAAE,GAAGjE,CAAf;AACA,cAAIwE,GAAG,GAAGP,EAAE,GAAGG,EAAf;AACA,cAAIK,GAAG,GAAGV,EAAE,GAAG/D,CAAf;AACA,cAAI0E,GAAG,GAAGX,EAAE,GAAGK,EAAf;AACA,cAAIO,GAAJ,EAASC,GAAT,EAAcC,GAAd,EAAmBC,GAAnB;;AAEA,iBAAOT,EAAE,IAAIC,EAAb,EAAiBD,EAAE,IAAIG,GAAvB,EAA4B;AAC1B,gBAAIO,EAAE,GAAGV,EAAT;AACA,gBAAIW,EAAE,GAAGX,EAAE,GAAGN,EAAE,IAAID,EAAE,GAAGM,EAAT,CAAhB;;AAEA,mBAAOW,EAAE,IAAIC,EAAb,EAAiBD,EAAE,IAAIL,GAAvB,EAA4B;AAC1B,kBAAIO,GAAG,GAAGF,EAAE,GAAGN,GAAf;AACA,kBAAIS,GAAG,GAAGH,EAAE,GAAGR,GAAf;AACA,kBAAIY,GAAG,GAAGD,GAAG,GAAGT,GAAhB;;AAEA,kBAAIN,GAAJ,EAAS;AACPpB,gBAAAA,MAAM,CAACpF,MAAM,CAACoH,EAAE,GAAGlB,CAAN,CAAP,EAAiBlG,MAAM,CAACuH,GAAG,GAAGrB,CAAP,CAAvB,CAAN;AACAc,gBAAAA,GAAG,GAAG/B,YAAY,CAACC,CAAnB;AACAgC,gBAAAA,GAAG,GAAGjC,YAAY,CAACE,CAAnB;AACAC,gBAAAA,MAAM,CAACpF,MAAM,CAACsH,GAAG,GAAGpB,CAAP,CAAP,EAAkBlG,MAAM,CAACwH,GAAG,GAAGtB,CAAP,CAAxB,CAAN;AACAe,gBAAAA,GAAG,GAAGhC,YAAY,CAACC,CAAnB;AACAiC,gBAAAA,GAAG,GAAGlC,YAAY,CAACE,CAAnB;AACAC,gBAAAA,MAAM,CAAC4B,GAAD,EAAMC,GAAN,CAAN;AACAjH,gBAAAA,MAAM,CAACoH,EAAE,GAAGlB,CAAN,CAAN,GAAiBjB,YAAY,CAACC,CAA9B;AACAlF,gBAAAA,MAAM,CAACsH,GAAG,GAAGpB,CAAP,CAAN,GAAkBjB,YAAY,CAACE,CAA/B;AACAC,gBAAAA,MAAM,CAAC8B,GAAD,EAAMC,GAAN,CAAN;AACAnH,gBAAAA,MAAM,CAACuH,GAAG,GAAGrB,CAAP,CAAN,GAAkBjB,YAAY,CAACC,CAA/B;AACAlF,gBAAAA,MAAM,CAACwH,GAAG,GAAGtB,CAAP,CAAN,GAAkBjB,YAAY,CAACE,CAA/B;AACD,eAbD,MAaO;AACLS,gBAAAA,MAAM,CAAC5F,MAAM,CAACoH,EAAE,GAAGlB,CAAN,CAAP,EAAiBlG,MAAM,CAACuH,GAAG,GAAGrB,CAAP,CAAvB,CAAN;AACAc,gBAAAA,GAAG,GAAG/B,YAAY,CAACC,CAAnB;AACAgC,gBAAAA,GAAG,GAAGjC,YAAY,CAACE,CAAnB;AACAS,gBAAAA,MAAM,CAAC5F,MAAM,CAACsH,GAAG,GAAGpB,CAAP,CAAP,EAAkBlG,MAAM,CAACwH,GAAG,GAAGtB,CAAP,CAAxB,CAAN;AACAe,gBAAAA,GAAG,GAAGhC,YAAY,CAACC,CAAnB;AACAiC,gBAAAA,GAAG,GAAGlC,YAAY,CAACE,CAAnB;AACAS,gBAAAA,MAAM,CAACoB,GAAD,EAAMC,GAAN,CAAN;AACAjH,gBAAAA,MAAM,CAACoH,EAAE,GAAGlB,CAAN,CAAN,GAAiBjB,YAAY,CAACC,CAA9B;AACAlF,gBAAAA,MAAM,CAACsH,GAAG,GAAGpB,CAAP,CAAN,GAAkBjB,YAAY,CAACE,CAA/B;AACAS,gBAAAA,MAAM,CAACsB,GAAD,EAAMC,GAAN,CAAN;AACAnH,gBAAAA,MAAM,CAACuH,GAAG,GAAGrB,CAAP,CAAN,GAAkBjB,YAAY,CAACC,CAA/B;AACAlF,gBAAAA,MAAM,CAACwH,GAAG,GAAGtB,CAAP,CAAN,GAAkBjB,YAAY,CAACE,CAA/B;AACD;AACF;;AAED,gBAAIgB,EAAE,GAAG9D,CAAT,EAAY;AACV,kBAAIkF,GAAG,GAAGH,EAAE,GAAGR,GAAf;AACA,kBAAIJ,GAAJ,EAASpB,MAAM,CAACpF,MAAM,CAACoH,EAAE,GAAGlB,CAAN,CAAP,EAAiBlG,MAAM,CAACuH,GAAG,GAAGrB,CAAP,CAAvB,CAAN,CAAT,KAAsDN,MAAM,CAAC5F,MAAM,CAACoH,EAAE,GAAGlB,CAAN,CAAP,EAAiBlG,MAAM,CAACuH,GAAG,GAAGrB,CAAP,CAAvB,CAAN;AACtDc,cAAAA,GAAG,GAAG/B,YAAY,CAACC,CAAnB;AACAlF,cAAAA,MAAM,CAACuH,GAAG,GAAGrB,CAAP,CAAN,GAAkBjB,YAAY,CAACE,CAA/B;AACAnF,cAAAA,MAAM,CAACoH,EAAE,GAAGlB,CAAN,CAAN,GAAiBc,GAAjB;AACD;AACF;;AAED,cAAIX,EAAE,GAAGhE,CAAT,EAAY;AACV,gBAAI+E,EAAE,GAAGV,EAAT;AACA,gBAAIW,EAAE,GAAGX,EAAE,GAAGN,EAAE,IAAID,EAAE,GAAGM,EAAT,CAAhB;;AAEA,mBAAOW,EAAE,IAAIC,EAAb,EAAiBD,EAAE,IAAIL,GAAvB,EAA4B;AAC1B,kBAAIO,GAAG,GAAGF,EAAE,GAAGN,GAAf;AACA,kBAAIN,GAAJ,EAASpB,MAAM,CAACpF,MAAM,CAACoH,EAAE,GAAGlB,CAAN,CAAP,EAAiBlG,MAAM,CAACsH,GAAG,GAAGpB,CAAP,CAAvB,CAAN,CAAT,KAAsDN,MAAM,CAAC5F,MAAM,CAACoH,EAAE,GAAGlB,CAAN,CAAP,EAAiBlG,MAAM,CAACsH,GAAG,GAAGpB,CAAP,CAAvB,CAAN;AACtDc,cAAAA,GAAG,GAAG/B,YAAY,CAACC,CAAnB;AACAlF,cAAAA,MAAM,CAACsH,GAAG,GAAGpB,CAAP,CAAN,GAAkBjB,YAAY,CAACE,CAA/B;AACAnF,cAAAA,MAAM,CAACoH,EAAE,GAAGlB,CAAN,CAAN,GAAiBc,GAAjB;AACD;AACF;;AAEDP,UAAAA,EAAE,GAAGpE,CAAL;AACAA,UAAAA,CAAC,KAAK,CAAN;AACD;;AAED,eAAOqE,EAAP;AACD;;AAED,eAASe,SAAT,CAAmBC,aAAnB,EAAkCC,aAAlC,EAAiD/E,UAAjD,EAA6DS,UAA7D,EAAyER,QAAzE,EAAmFS,EAAnF,EAAuFiB,GAAvF,EAA4FqD,EAA5F,EAAgGpD,SAAhG,EAA2GqD,SAA3G,EAAsH;AACpH,YAAIrF,CAAC,GAAG,CAAR;AACA,YAAIC,EAAE,GAAG,CAAT;AACA,YAAIiC,kBAAkB,GAAGkD,EAAzB;AACA,YAAIE,WAAW,GAAGrG,IAAI,CAACsG,KAAL,CAAWlF,QAAQ,CAACY,KAAT,GAAiB,CAACH,EAAE,GAAG,CAAN,IAAW,CAAvC,CAAlB;;AAEA,eAAOT,QAAQ,CAACY,KAAT,GAAiBqE,WAAxB,EAAqC;AACnC3D,UAAAA,OAAO,CAAC3B,CAAD,EAAIC,EAAJ,EAAQG,UAAR,EAAoBC,QAApB,CAAP;AACAL,UAAAA,CAAC,GAAG0B,aAAa,CAAC1B,CAAlB;AACAC,UAAAA,EAAE,GAAGyB,aAAa,CAACzB,EAAnB;;AAEA,iBAAOA,EAAE,IAAIrC,WAAb,EAA0B;AACxB,gBAAI4H,KAAK,GAAGxF,CAAC,IAAIC,EAAE,GAAGrC,WAAV,GAAwBG,WAApC;AACA,gBAAIyD,EAAE,GAAG2D,aAAa,CAACK,KAAD,CAAtB;;AAEA,gBAAIhE,EAAE,CAAC7B,GAAP,EAAY;AACVM,cAAAA,EAAE,IAAIuB,EAAE,CAAC7B,GAAT;AACAkC,cAAAA,OAAO,CAACL,EAAE,CAAC5B,GAAJ,EAASmC,GAAT,EAAc/B,CAAd,EAAiBC,EAAjB,EAAqBG,UAArB,EAAiCS,UAAjC,EAA6CR,QAA7C,EAAuD2B,SAAvD,EAAkEqD,SAAlE,EAA6EnD,kBAA7E,CAAP;AACAlC,cAAAA,CAAC,GAAG4B,aAAa,CAAC5B,CAAlB;AACAC,cAAAA,EAAE,GAAG2B,aAAa,CAAC3B,EAAnB;AACD,aALD,MAKO;AACL,kBAAI,CAACuB,EAAE,CAAC3B,CAAR,EAAW;AACT,sBAAM,kBAAN;AACD;;AAED,kBAAI6D,CAAJ;;AAEA,mBAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGlC,EAAE,CAAC5B,GAAnB,EAAwB8D,CAAC,EAAzB,EAA6B;AAC3B,oBAAI3D,CAAC,GAAGoB,SAAS,CAAC+D,aAAa,CAAC1D,EAAE,CAAC3B,CAAH,CAAK6D,CAAL,CAAD,CAAd,CAAjB;;AAEA,uBAAOzD,EAAE,GAAGF,CAAL,IAAUM,QAAQ,CAACY,KAAT,GAAiBqE,WAAlC,EAA+C;AAC7C3D,kBAAAA,OAAO,CAAC3B,CAAD,EAAIC,EAAJ,EAAQG,UAAR,EAAoBC,QAApB,CAAP;AACAL,kBAAAA,CAAC,GAAG0B,aAAa,CAAC1B,CAAlB;AACAC,kBAAAA,EAAE,GAAGyB,aAAa,CAACzB,EAAnB;AACD;;AAED,oBAAIA,EAAE,IAAIF,CAAV,EAAa;AACX,sBAAIsB,OAAO,CAAC6D,aAAa,CAAC1D,EAAE,CAAC3B,CAAH,CAAK6D,CAAL,CAAD,CAAd,CAAP,KAAoC1D,CAAC,IAAIC,EAAE,GAAGF,CAAV,GAAc,CAAC,KAAKA,CAAN,IAAW,CAA7D,CAAJ,EAAqE;AACnEE,oBAAAA,EAAE,IAAIF,CAAN;AACA8B,oBAAAA,OAAO,CAACL,EAAE,CAAC3B,CAAH,CAAK6D,CAAL,CAAD,EAAU3B,GAAV,EAAe/B,CAAf,EAAkBC,EAAlB,EAAsBG,UAAtB,EAAkCS,UAAlC,EAA8CR,QAA9C,EAAwD2B,SAAxD,EAAmEqD,SAAnE,EAA8EnD,kBAA9E,CAAP;AACAlC,oBAAAA,CAAC,GAAG4B,aAAa,CAAC5B,CAAlB;AACAC,oBAAAA,EAAE,GAAG2B,aAAa,CAAC3B,EAAnB;AACA;AACD;AACF;AACF;;AAED,kBAAIyD,CAAC,IAAIlC,EAAE,CAAC5B,GAAZ,EAAiB;AACf,sBAAM,kBAAN;AACD;AACF;AACF;AACF;;AAED,YAAIL,CAAC,GAAG,IAAIuB,EAAJ,GAAS,CAAjB;AACAd,QAAAA,CAAC,KAAKT,CAAN;AACAU,QAAAA,EAAE,IAAIV,CAAN;;AAEA,eAAOU,EAAE,GAAG,CAAZ,EAAe;AACb,cAAIuB,EAAE,GAAG2D,aAAa,CAACnF,CAAC,IAAIpC,WAAW,GAAGqC,EAAnB,GAAwBlC,WAAzB,CAAtB;;AAEA,cAAIyD,EAAE,CAAC7B,GAAP,EAAY;AACVM,YAAAA,EAAE,IAAIuB,EAAE,CAAC7B,GAAT;AACAkC,YAAAA,OAAO,CAACL,EAAE,CAAC5B,GAAJ,EAASmC,GAAT,EAAc/B,CAAd,EAAiBC,EAAjB,EAAqBG,UAArB,EAAiCS,UAAjC,EAA6CR,QAA7C,EAAuD2B,SAAvD,EAAkEqD,SAAlE,EAA6EnD,kBAA7E,CAAP;AACAlC,YAAAA,CAAC,GAAG4B,aAAa,CAAC5B,CAAlB;AACAC,YAAAA,EAAE,GAAG2B,aAAa,CAAC3B,EAAnB;AACD,WALD,MAKO;AACL,kBAAM,kBAAN;AACD;AACF;;AAED,eAAO,IAAP;AACD;;AAED,eAASwF,aAAT,CAAuBrF,UAAvB,EAAmCS,UAAnC,EAA+CR,QAA/C,EAAyDqF,WAAzD,EAAsE1D,SAAtE,EAAiF2D,IAAjF,EAAuF;AACrF,YAAIN,SAAS,GAAG;AACdpE,UAAAA,KAAK,EAAE;AADO,SAAhB;AAGA,YAAI2E,eAAe,GAAGvF,QAAQ,CAACY,KAA/B;AACA,YAAIF,EAAE,GAAG8E,WAAW,CAAChF,UAAD,EAAaR,QAAb,CAApB;AACA,YAAIW,EAAE,GAAG6E,WAAW,CAAChF,UAAD,EAAaR,QAAb,CAApB;AACAA,QAAAA,QAAQ,CAACY,KAAT,IAAkB,CAAlB;AACA,YAAId,KAAK,GAAG0F,WAAW,CAAChF,UAAD,EAAaR,QAAb,CAAvB;AACAA,QAAAA,QAAQ,CAACY,KAAT,IAAkB,CAAlB;;AAEA,YAAIF,EAAE,GAAG,CAAL,IAAUA,EAAE,IAAIlD,WAAhB,IAA+BmD,EAAE,GAAG,CAApC,IAAyCA,EAAE,IAAInD,WAAnD,EAAgE;AAC9D,gBAAM,kCAAN;AACD;;AAED,YAAIiI,IAAI,GAAG,IAAItF,KAAJ,CAAU3C,WAAV,CAAX;AACA,YAAI6B,IAAI,GAAG,IAAIc,KAAJ,CAAU1C,WAAV,CAAX;AACA2B,QAAAA,gBAAgB,CAACC,IAAD,CAAhB;AACA,YAAIoB,EAAE,GAAG4E,WAAW,IAAIrF,QAAQ,CAACY,KAAT,GAAiB2E,eAArB,CAApB;AACAhF,QAAAA,iBAAiB,CAACR,UAAD,EAAaS,UAAb,EAAyBR,QAAzB,EAAmCS,EAAnC,EAAuCC,EAAvC,EAA2CC,EAA3C,EAA+C8E,IAA/C,CAAjB;;AAEA,YAAI3F,KAAK,GAAG,KAAKuF,WAAW,IAAIrF,QAAQ,CAACY,KAAT,GAAiB2E,eAArB,CAAhB,CAAZ,EAAoE;AAClE,gBAAM,oCAAN;AACD;;AAEDtE,QAAAA,gBAAgB,CAACwE,IAAD,EAAO/E,EAAP,EAAWC,EAAX,EAAetB,IAAf,CAAhB;AACAuF,QAAAA,SAAS,CAACa,IAAD,EAAOpG,IAAP,EAAaU,UAAb,EAAyBS,UAAzB,EAAqCR,QAArC,EAA+CF,KAA/C,EAAsDa,EAAtD,EAA0D2E,IAA1D,EAAgE3D,SAAhE,EAA2EqD,SAA3E,CAAT;AACD;;AAED,eAASU,QAAT,CAAkB1G,GAAlB,EAAuB2G,IAAvB,EAA6BC,KAA7B,EAAoC;AAClC,aAAK,IAAI1G,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0G,KAApB,EAA2B,EAAE1G,CAA7B,EAAgC;AAC9ByG,UAAAA,IAAI,CAACzG,CAAD,CAAJ,GAAUF,GAAG,CAAC2G,IAAI,CAACzG,CAAD,CAAL,CAAb;AACD;AACF;;AAED,eAAS2G,SAAT,CAAmBC,MAAnB,EAA2B;AACzB,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAAM,CAACE,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACtC,cAAI9C,CAAC,GAAG6C,MAAM,CAACC,CAAC,GAAG,CAAL,CAAN,GAAgBD,MAAM,CAACC,CAAD,CAAtB,GAA4B,GAApC;AACAD,UAAAA,MAAM,CAACC,CAAD,CAAN,GAAY9C,CAAZ;AACD;AACF;;AAED,eAASgD,gBAAT,CAA0BH,MAA1B,EAAkCI,GAAlC,EAAuC;AACrC,YAAIC,EAAE,GAAG,CAAT;AACA,YAAIC,EAAE,GAAGxH,IAAI,CAACyH,KAAL,CAAW,CAACP,MAAM,CAACE,MAAP,GAAgB,CAAjB,IAAsB,CAAjC,CAAT;AACA,YAAIhE,CAAC,GAAG,CAAR;AACA,YAAIsE,IAAI,GAAGR,MAAM,CAACE,MAAP,GAAgB,CAA3B;;AAEA,eAAO,IAAP,EAAa;AACX,cAAIhE,CAAC,GAAGsE,IAAR,EAAc;AACdJ,UAAAA,GAAG,CAAClE,CAAC,EAAF,CAAH,GAAW8D,MAAM,CAACK,EAAE,EAAH,CAAjB;AACA,cAAInE,CAAC,GAAGsE,IAAR,EAAc;AACdJ,UAAAA,GAAG,CAAClE,CAAC,EAAF,CAAH,GAAW8D,MAAM,CAACM,EAAE,EAAH,CAAjB;AACD;AACF;;AAED,eAASG,eAAT,CAAyBT,MAAzB,EAAiC;AAC/B,YAAIU,IAAI,GAAGV,MAAM,CAACW,UAAlB;AACA,YAAIP,GAAG,GAAG,IAAI/F,KAAJ,EAAV;AACA,YAAIX,CAAC,GAAG,CAAR;AACA,YAAIkH,MAAM,GAAG,IAAIC,QAAJ,CAAab,MAAb,CAAb;;AAEA,eAAOU,IAAI,GAAG,CAAd,EAAiB;AACf,cAAI9G,CAAC,GAAGgH,MAAM,CAACE,OAAP,CAAepH,CAAC,EAAhB,CAAR;;AAEA,cAAIE,CAAC,GAAG,CAAR,EAAW;AACT,gBAAImH,KAAK,GAAG,CAACnH,CAAb;AACA8G,YAAAA,IAAI,IAAIK,KAAK,GAAG,CAAhB;;AAEA,iBAAK,IAAI3H,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2H,KAApB,EAA2B3H,CAAC,EAA5B,EAAgC;AAC9BgH,cAAAA,GAAG,CAACY,IAAJ,CAASJ,MAAM,CAACK,QAAP,CAAgBvH,CAAC,EAAjB,CAAT;AACD;AACF,WAPD,MAOO;AACL,gBAAIqH,KAAK,GAAGnH,CAAZ;AACA8G,YAAAA,IAAI,IAAI,CAAR;AACA,gBAAI5F,KAAK,GAAG8F,MAAM,CAACK,QAAP,CAAgBvH,CAAC,EAAjB,CAAZ;;AAEA,iBAAK,IAAIN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2H,KAAK,GAAG,CAA5B,EAA+B3H,CAAC,EAAhC,EAAoC;AAClCgH,cAAAA,GAAG,CAACY,IAAJ,CAASlG,KAAT;AACD;AACF;AACF;;AAED,eAAOsF,GAAP;AACD;;AAED,eAASc,cAAT,CAAwBC,MAAxB,EAAgCC,OAAhC,EAAyCC,WAAzC,EAAsDC,QAAtD,EAAgEC,QAAhE,EAA0E1F,SAA1E,EAAqF;AACnF,YAAI2F,QAAQ,GAAG,IAAIX,QAAJ,CAAahF,SAAS,CAACxE,MAAvB,CAAf;AACA,YAAIoK,KAAK,GAAGJ,WAAW,CAACF,MAAM,CAACO,GAAP,CAAW,CAAX,CAAD,CAAX,CAA2BD,KAAvC;AACA,YAAIE,MAAM,GAAGN,WAAW,CAACF,MAAM,CAACO,GAAP,CAAW,CAAX,CAAD,CAAX,CAA2BC,MAAxC;AACA,YAAIC,OAAO,GAAG,CAAd;AACA,YAAIC,cAAc,GAAG/I,IAAI,CAACyH,KAAL,CAAWkB,KAAK,GAAG,GAAnB,CAArB;AACA,YAAIK,UAAU,GAAGhJ,IAAI,CAACiJ,IAAL,CAAUN,KAAK,GAAG,GAAlB,CAAjB;AACA,YAAIO,UAAU,GAAGlJ,IAAI,CAACiJ,IAAL,CAAUJ,MAAM,GAAG,GAAnB,CAAjB;AACA,YAAIM,SAAS,GAAGR,KAAK,GAAG,CAACK,UAAU,GAAG,CAAd,IAAmB,CAA3C;AACA,YAAII,SAAS,GAAGP,MAAM,GAAG,CAACK,UAAU,GAAG,CAAd,IAAmB,CAA5C;AACA,YAAIG,UAAU,GAAG;AACfrH,UAAAA,KAAK,EAAE;AADQ,SAAjB;AAGA,YAAIsH,UAAU,GAAG,IAAI/H,KAAJ,CAAUuH,OAAV,CAAjB;AACA,YAAIS,OAAO,GAAG,IAAIhI,KAAJ,CAAUuH,OAAV,CAAd;AACA,YAAIU,YAAY,GAAG,IAAIjI,KAAJ,CAAUuH,OAAV,CAAnB;AACA,YAAIW,QAAQ,GAAG,IAAIlI,KAAJ,CAAUuH,OAAV,CAAf;AACA,YAAIY,UAAU,GAAG,IAAInI,KAAJ,CAAUuH,OAAV,CAAjB;;AAEA,aAAK,IAAIa,KAAI,GAAG,CAAhB,EAAmBA,KAAI,GAAGb,OAA1B,EAAmC,EAAEa,KAArC,EAA2C;AACzCD,UAAAA,UAAU,CAACC,KAAD,CAAV,GAAmBrB,OAAO,CAACD,MAAM,CAACO,GAAP,CAAWe,KAAX,CAAD,CAA1B;AACAL,UAAAA,UAAU,CAACK,KAAD,CAAV,GAAmBA,KAAI,GAAG,CAAP,GAAW,CAAX,GAAeL,UAAU,CAACK,KAAI,GAAG,CAAR,CAAV,GAAuBX,UAAU,GAAGE,UAAtE;AACAK,UAAAA,OAAO,CAACI,KAAD,CAAP,GAAgB,IAAIC,YAAJ,CAAiB,EAAjB,CAAhB;AACAJ,UAAAA,YAAY,CAACG,KAAD,CAAZ,GAAqB,IAAIE,WAAJ,CAAgB,EAAhB,CAArB;AACAJ,UAAAA,QAAQ,CAACE,KAAD,CAAR,GAAiB,IAAIE,WAAJ,CAAgBb,UAAU,GAAG,EAA7B,CAAjB;AACD;;AAED,aAAK,IAAIc,MAAM,GAAG,CAAlB,EAAqBA,MAAM,GAAGZ,UAA9B,EAA0C,EAAEY,MAA5C,EAAoD;AAClD,cAAIC,IAAI,GAAG,CAAX;AACA,cAAID,MAAM,IAAIZ,UAAU,GAAG,CAA3B,EAA8Ba,IAAI,GAAGX,SAAP;AAC9B,cAAIY,IAAI,GAAG,CAAX;;AAEA,eAAK,IAAIC,MAAM,GAAG,CAAlB,EAAqBA,MAAM,GAAGjB,UAA9B,EAA0C,EAAEiB,MAA5C,EAAoD;AAClD,gBAAIA,MAAM,IAAIjB,UAAU,GAAG,CAA3B,EAA8BgB,IAAI,GAAGb,SAAP;;AAE9B,iBAAK,IAAIQ,MAAI,GAAG,CAAhB,EAAmBA,MAAI,GAAGb,OAA1B,EAAmC,EAAEa,MAArC,EAA2C;AACzCH,cAAAA,YAAY,CAACG,MAAD,CAAZ,CAAmBO,IAAnB,CAAwB,CAAxB,EADyC,CACb;;;AAE5BV,cAAAA,YAAY,CAACG,MAAD,CAAZ,CAAmB,CAAnB,IAAwBlB,QAAQ,CAACa,UAAU,CAACK,MAAD,CAAV,EAAD,CAAhC,CAHyC,CAGa;;AAEtDQ,cAAAA,OAAO,CAACd,UAAD,EAAab,QAAb,EAAuBgB,YAAY,CAACG,MAAD,CAAnC,CAAP,CALyC,CAKU;;AAEnDS,cAAAA,QAAQ,CAACZ,YAAY,CAACG,MAAD,CAAb,EAAqBJ,OAAO,CAACI,MAAD,CAA5B,CAAR,CAPyC,CAOI;;AAE7CU,cAAAA,UAAU,CAACd,OAAO,CAACI,MAAD,CAAR,CAAV;AACD;;AAED;AACEW,cAAAA,aAAa,CAACf,OAAD,CAAb;AACD;;AAED,iBAAK,IAAII,MAAI,GAAG,CAAhB,EAAmBA,MAAI,GAAGb,OAA1B,EAAmC,EAAEa,MAArC,EAA2C;AACzCY,cAAAA,aAAa,CAAChB,OAAO,CAACI,MAAD,CAAR,EAAgBF,QAAQ,CAACE,MAAD,CAAxB,EAAgCM,MAAM,GAAG,EAAzC,CAAb;AACD;AACF,WA3BiD,CA2BhD;;;AAGF,cAAIO,OAAM,GAAG,CAAb;;AAEA,eAAK,IAAIb,MAAI,GAAG,CAAhB,EAAmBA,MAAI,GAAGb,OAA1B,EAAmC,EAAEa,MAArC,EAA2C;AACzC,gBAAMrL,KAAI,GAAGiK,WAAW,CAACF,MAAM,CAACO,GAAP,CAAWe,MAAX,CAAD,CAAX,CAA8BrL,IAA3C;;AAEA,iBAAK,IAAImM,EAAC,GAAG,IAAIX,MAAjB,EAAyBW,EAAC,GAAG,IAAIX,MAAJ,GAAaC,IAA1C,EAAgD,EAAEU,EAAlD,EAAqD;AACnDD,cAAAA,OAAM,GAAGd,UAAU,CAACC,MAAD,CAAV,CAAiBc,EAAjB,CAAT;;AAEA,mBAAK,IAAIR,OAAM,GAAG,CAAlB,EAAqBA,OAAM,GAAGlB,cAA9B,EAA8C,EAAEkB,OAAhD,EAAwD;AACtD,oBAAMS,GAAG,GAAGT,OAAM,GAAG,EAAT,GAAc,CAACQ,EAAC,GAAG,GAAL,IAAY,CAAtC;AACA/B,gBAAAA,QAAQ,CAACiC,SAAT,CAAmBH,OAAM,GAAG,IAAIhL,UAAJ,GAAiBlB,KAA7C,EAAmDmL,QAAQ,CAACE,MAAD,CAAR,CAAee,GAAG,GAAG,CAArB,CAAnD,EAA4E,IAA5E;AACAhC,gBAAAA,QAAQ,CAACiC,SAAT,CAAmBH,OAAM,GAAG,IAAIhL,UAAJ,GAAiBlB,KAA7C,EAAmDmL,QAAQ,CAACE,MAAD,CAAR,CAAee,GAAG,GAAG,CAArB,CAAnD,EAA4E,IAA5E;AACAhC,gBAAAA,QAAQ,CAACiC,SAAT,CAAmBH,OAAM,GAAG,IAAIhL,UAAJ,GAAiBlB,KAA7C,EAAmDmL,QAAQ,CAACE,MAAD,CAAR,CAAee,GAAG,GAAG,CAArB,CAAnD,EAA4E,IAA5E;AACAhC,gBAAAA,QAAQ,CAACiC,SAAT,CAAmBH,OAAM,GAAG,IAAIhL,UAAJ,GAAiBlB,KAA7C,EAAmDmL,QAAQ,CAACE,MAAD,CAAR,CAAee,GAAG,GAAG,CAArB,CAAnD,EAA4E,IAA5E;AACAhC,gBAAAA,QAAQ,CAACiC,SAAT,CAAmBH,OAAM,GAAG,IAAIhL,UAAJ,GAAiBlB,KAA7C,EAAmDmL,QAAQ,CAACE,MAAD,CAAR,CAAee,GAAG,GAAG,CAArB,CAAnD,EAA4E,IAA5E;AACAhC,gBAAAA,QAAQ,CAACiC,SAAT,CAAmBH,OAAM,GAAG,IAAIhL,UAAJ,GAAiBlB,KAA7C,EAAmDmL,QAAQ,CAACE,MAAD,CAAR,CAAee,GAAG,GAAG,CAArB,CAAnD,EAA4E,IAA5E;AACAhC,gBAAAA,QAAQ,CAACiC,SAAT,CAAmBH,OAAM,GAAG,IAAIhL,UAAJ,GAAiBlB,KAA7C,EAAmDmL,QAAQ,CAACE,MAAD,CAAR,CAAee,GAAG,GAAG,CAArB,CAAnD,EAA4E,IAA5E;AACAhC,gBAAAA,QAAQ,CAACiC,SAAT,CAAmBH,OAAM,GAAG,IAAIhL,UAAJ,GAAiBlB,KAA7C,EAAmDmL,QAAQ,CAACE,MAAD,CAAR,CAAee,GAAG,GAAG,CAArB,CAAnD,EAA4E,IAA5E;AACAF,gBAAAA,OAAM,IAAI,IAAIhL,UAAJ,GAAiBlB,KAA3B;AACD;AACF,aAlBwC,CAkBvC;;;AAGF,gBAAIyK,cAAc,IAAIC,UAAtB,EAAkC;AAChC,mBAAK,IAAIyB,GAAC,GAAG,IAAIX,MAAjB,EAAyBW,GAAC,GAAG,IAAIX,MAAJ,GAAaC,IAA1C,EAAgD,EAAEU,GAAlD,EAAqD;AACnD,oBAAMD,QAAM,GAAGd,UAAU,CAACC,MAAD,CAAV,CAAiBc,GAAjB,IAAsB,IAAI1B,cAAJ,GAAqBvJ,UAArB,GAAkClB,KAAvE;;AACA,oBAAMoM,IAAG,GAAG3B,cAAc,GAAG,EAAjB,GAAsB,CAAC0B,GAAC,GAAG,GAAL,IAAY,CAA9C;;AAEA,qBAAK,IAAIG,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGZ,IAApB,EAA0B,EAAEY,EAA5B,EAA+B;AAC7BlC,kBAAAA,QAAQ,CAACiC,SAAT,CAAmBH,QAAM,GAAGI,EAAC,GAAGpL,UAAJ,GAAiBlB,KAA7C,EAAmDmL,QAAQ,CAACE,MAAD,CAAR,CAAee,IAAG,GAAGE,EAArB,CAAnD,EAA4E,IAA5E;AACD;AACF;AACF;AACF,WA/DiD,CA+DhD;;AAEH,SA5FkF,CA4FjF;;;AAGF,YAAIC,OAAO,GAAG,IAAIhB,WAAJ,CAAgBlB,KAAhB,CAAd;AACA,YAAID,QAAQ,GAAG,IAAIX,QAAJ,CAAahF,SAAS,CAACxE,MAAvB,CAAf,CAhGmF,CAgGpC;;AAE/C,aAAK,IAAIoL,IAAI,GAAG,CAAhB,EAAmBA,IAAI,GAAGb,OAA1B,EAAmC,EAAEa,IAArC,EAA2C;AACzCpB,UAAAA,WAAW,CAACF,MAAM,CAACO,GAAP,CAAWe,IAAX,CAAD,CAAX,CAA8BmB,OAA9B,GAAwC,IAAxC;AACA,cAAIxM,IAAI,GAAGiK,WAAW,CAACF,MAAM,CAACO,GAAP,CAAWe,IAAX,CAAD,CAAX,CAA8BrL,IAAzC;AACA,cAAIiK,WAAW,CAACoB,IAAD,CAAX,CAAkBrL,IAAlB,IAA0B,CAA9B,EAAiC;;AAEjC,eAAK,IAAImM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5B,MAApB,EAA4B,EAAE4B,CAA9B,EAAiC;AAC/B,gBAAMD,QAAM,GAAGd,UAAU,CAACC,IAAD,CAAV,CAAiBc,CAAjB,CAAf;;AAEA,iBAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjC,KAApB,EAA2B,EAAEiC,CAA7B,EAAgC;AAC9BC,cAAAA,OAAO,CAACD,CAAD,CAAP,GAAalC,QAAQ,CAACqC,SAAT,CAAmBP,QAAM,GAAGI,CAAC,GAAGpL,UAAJ,GAAiBlB,IAA7C,EAAmD,IAAnD,CAAb;AACD;;AAED,iBAAK,IAAIsM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjC,KAApB,EAA2B,EAAEiC,CAA7B,EAAgC;AAC9BlC,cAAAA,QAAQ,CAACsC,UAAT,CAAoBR,QAAM,GAAGI,CAAC,GAAGpL,UAAJ,GAAiBlB,IAA9C,EAAoD2M,aAAa,CAACJ,OAAO,CAACD,CAAD,CAAR,CAAjE,EAA+E,IAA/E;AACD;AACF;AACF;AACF;;AAED,eAAST,OAAT,CAAiBd,UAAjB,EAA6Bb,QAA7B,EAAuCgB,YAAvC,EAAqD;AACnD,YAAI0B,OAAJ;AACA,YAAIC,OAAO,GAAG,CAAd;;AAEA,eAAOA,OAAO,GAAG,EAAjB,EAAqB;AACnBD,UAAAA,OAAO,GAAG1C,QAAQ,CAACa,UAAU,CAACrH,KAAZ,CAAlB;;AAEA,cAAIkJ,OAAO,IAAI,MAAf,EAAuB;AACrBC,YAAAA,OAAO,GAAG,EAAV;AACD,WAFD,MAEO,IAAID,OAAO,IAAI,CAAX,IAAgB,IAApB,EAA0B;AAC/BC,YAAAA,OAAO,IAAID,OAAO,GAAG,IAArB;AACD,WAFM,MAEA;AACL1B,YAAAA,YAAY,CAAC2B,OAAD,CAAZ,GAAwBD,OAAxB;AACAC,YAAAA,OAAO;AACR;;AAED9B,UAAAA,UAAU,CAACrH,KAAX;AACD;AACF;;AAED,eAASoI,QAAT,CAAkBM,GAAlB,EAAuBU,GAAvB,EAA4B;AAC1BA,QAAAA,GAAG,CAAC,CAAD,CAAH,GAASH,aAAa,CAACP,GAAG,CAAC,CAAD,CAAJ,CAAtB;AACAU,QAAAA,GAAG,CAAC,CAAD,CAAH,GAASH,aAAa,CAACP,GAAG,CAAC,CAAD,CAAJ,CAAtB;AACAU,QAAAA,GAAG,CAAC,CAAD,CAAH,GAASH,aAAa,CAACP,GAAG,CAAC,CAAD,CAAJ,CAAtB;AACAU,QAAAA,GAAG,CAAC,CAAD,CAAH,GAASH,aAAa,CAACP,GAAG,CAAC,CAAD,CAAJ,CAAtB;AACAU,QAAAA,GAAG,CAAC,CAAD,CAAH,GAASH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAtB;AACAU,QAAAA,GAAG,CAAC,CAAD,CAAH,GAASH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAtB;AACAU,QAAAA,GAAG,CAAC,CAAD,CAAH,GAASH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAtB;AACAU,QAAAA,GAAG,CAAC,CAAD,CAAH,GAASH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAtB;AACAU,QAAAA,GAAG,CAAC,CAAD,CAAH,GAASH,aAAa,CAACP,GAAG,CAAC,CAAD,CAAJ,CAAtB;AACAU,QAAAA,GAAG,CAAC,CAAD,CAAH,GAASH,aAAa,CAACP,GAAG,CAAC,CAAD,CAAJ,CAAtB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,CAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,CAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,CAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,CAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,QAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACD;;AAED,eAASL,UAAT,CAAoBtD,IAApB,EAA0B;AACxB,YAAMtD,CAAC,GAAG,MAAMzD,IAAI,CAACqL,GAAL,CAAS,UAAU,GAAnB,CAAhB;AACA,YAAM3H,CAAC,GAAG,MAAM1D,IAAI,CAACqL,GAAL,CAAS,UAAU,IAAnB,CAAhB;AACA,YAAMtK,CAAC,GAAG,MAAMf,IAAI,CAACqL,GAAL,CAAS,UAAU,GAAnB,CAAhB;AACA,YAAMhH,CAAC,GAAG,MAAMrE,IAAI,CAACqL,GAAL,CAAS,MAAM,OAAN,GAAgB,IAAzB,CAAhB;AACA,YAAMC,CAAC,GAAG,MAAMtL,IAAI,CAACqL,GAAL,CAAS,MAAM,OAAN,GAAgB,IAAzB,CAAhB;AACA,YAAME,CAAC,GAAG,MAAMvL,IAAI,CAACqL,GAAL,CAAS,MAAM,OAAN,GAAgB,GAAzB,CAAhB;AACA,YAAMG,CAAC,GAAG,MAAMxL,IAAI,CAACqL,GAAL,CAAS,MAAM,OAAN,GAAgB,IAAzB,CAAhB;AACA,YAAII,KAAK,GAAG,IAAIlK,KAAJ,CAAU,CAAV,CAAZ;AACA,YAAImK,IAAI,GAAG,IAAInK,KAAJ,CAAU,CAAV,CAAX;AACA,YAAIoK,KAAK,GAAG,IAAIpK,KAAJ,CAAU,CAAV,CAAZ;AACA,YAAIqK,KAAK,GAAG,IAAIrK,KAAJ,CAAU,CAAV,CAAZ;;AAEA,aAAK,IAAIsK,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG,CAAxB,EAA2B,EAAEA,GAA7B,EAAkC;AAChC,cAAIC,MAAM,GAAGD,GAAG,GAAG,CAAnB;AACAJ,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAW1K,CAAC,GAAGgG,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAnB;AACAL,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWF,CAAC,GAAGxE,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAnB;AACAL,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAW1K,CAAC,GAAGgG,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAnB;AACAL,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWF,CAAC,GAAGxE,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAnB;AACAJ,UAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUhI,CAAC,GAAGqD,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAR,GAAuBzH,CAAC,GAAG0C,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAA/B,GAA8CR,CAAC,GAAGvE,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAtD,GAAqEN,CAAC,GAAGzE,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAvF;AACAJ,UAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUrH,CAAC,GAAG0C,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAR,GAAuBN,CAAC,GAAGzE,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAA/B,GAA8CpI,CAAC,GAAGqD,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAtD,GAAqER,CAAC,GAAGvE,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAvF;AACAJ,UAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUJ,CAAC,GAAGvE,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAR,GAAuBpI,CAAC,GAAGqD,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAA/B,GAA8CN,CAAC,GAAGzE,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAtD,GAAqEzH,CAAC,GAAG0C,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAvF;AACAJ,UAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUF,CAAC,GAAGzE,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAR,GAAuBR,CAAC,GAAGvE,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAA/B,GAA8CzH,CAAC,GAAG0C,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAtD,GAAqEpI,CAAC,GAAGqD,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAvF;AACAH,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWlI,CAAC,IAAIsD,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAJ,GAAmB/E,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAA3B,CAAZ;AACAH,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWlI,CAAC,IAAIsD,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAJ,GAAmB/E,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAA3B,CAAZ;AACAH,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWF,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACAE,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWF,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACAG,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWD,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACAC,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWD,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACAC,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWD,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACAC,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWD,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACA5E,UAAAA,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAJ,GAAmBF,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAlC;AACA3E,UAAAA,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAJ,GAAmBF,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAlC;AACA3E,UAAAA,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAJ,GAAmBF,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAlC;AACA3E,UAAAA,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAJ,GAAmBF,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAlC;AACA3E,UAAAA,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAJ,GAAmBF,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAlC;AACA3E,UAAAA,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAJ,GAAmBF,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAlC;AACA3E,UAAAA,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAJ,GAAmBF,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAlC;AACA3E,UAAAA,IAAI,CAAC+E,MAAM,GAAG,CAAV,CAAJ,GAAmBF,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAlC;AACD;;AAED,aAAK,IAAIK,MAAM,GAAG,CAAlB,EAAqBA,MAAM,GAAG,CAA9B,EAAiC,EAAEA,MAAnC,EAA2C;AACzCN,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAW1K,CAAC,GAAGgG,IAAI,CAAC,KAAKgF,MAAN,CAAnB;AACAN,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWF,CAAC,GAAGxE,IAAI,CAAC,KAAKgF,MAAN,CAAnB;AACAN,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAW1K,CAAC,GAAGgG,IAAI,CAAC,KAAKgF,MAAN,CAAnB;AACAN,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWF,CAAC,GAAGxE,IAAI,CAAC,KAAKgF,MAAN,CAAnB;AACAL,UAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUhI,CAAC,GAAGqD,IAAI,CAAC,IAAIgF,MAAL,CAAR,GAAuB1H,CAAC,GAAG0C,IAAI,CAAC,KAAKgF,MAAN,CAA/B,GAA+CT,CAAC,GAAGvE,IAAI,CAAC,KAAKgF,MAAN,CAAvD,GAAuEP,CAAC,GAAGzE,IAAI,CAAC,KAAKgF,MAAN,CAAzF;AACAL,UAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUrH,CAAC,GAAG0C,IAAI,CAAC,IAAIgF,MAAL,CAAR,GAAuBP,CAAC,GAAGzE,IAAI,CAAC,KAAKgF,MAAN,CAA/B,GAA+CrI,CAAC,GAAGqD,IAAI,CAAC,KAAKgF,MAAN,CAAvD,GAAuET,CAAC,GAAGvE,IAAI,CAAC,KAAKgF,MAAN,CAAzF;AACAL,UAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUJ,CAAC,GAAGvE,IAAI,CAAC,IAAIgF,MAAL,CAAR,GAAuBrI,CAAC,GAAGqD,IAAI,CAAC,KAAKgF,MAAN,CAA/B,GAA+CP,CAAC,GAAGzE,IAAI,CAAC,KAAKgF,MAAN,CAAvD,GAAuE1H,CAAC,GAAG0C,IAAI,CAAC,KAAKgF,MAAN,CAAzF;AACAL,UAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUF,CAAC,GAAGzE,IAAI,CAAC,IAAIgF,MAAL,CAAR,GAAuBT,CAAC,GAAGvE,IAAI,CAAC,KAAKgF,MAAN,CAA/B,GAA+C1H,CAAC,GAAG0C,IAAI,CAAC,KAAKgF,MAAN,CAAvD,GAAuErI,CAAC,GAAGqD,IAAI,CAAC,KAAKgF,MAAN,CAAzF;AACAJ,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWlI,CAAC,IAAIsD,IAAI,CAACgF,MAAD,CAAJ,GAAehF,IAAI,CAAC,KAAKgF,MAAN,CAAvB,CAAZ;AACAJ,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWlI,CAAC,IAAIsD,IAAI,CAACgF,MAAD,CAAJ,GAAehF,IAAI,CAAC,KAAKgF,MAAN,CAAvB,CAAZ;AACAJ,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWF,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACAE,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWF,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACAG,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWD,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACAC,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWD,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACAC,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWD,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACAC,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWD,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACA5E,UAAAA,IAAI,CAAC,IAAIgF,MAAL,CAAJ,GAAmBH,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAlC;AACA3E,UAAAA,IAAI,CAAC,IAAIgF,MAAL,CAAJ,GAAmBH,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAlC;AACA3E,UAAAA,IAAI,CAAC,KAAKgF,MAAN,CAAJ,GAAoBH,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAnC;AACA3E,UAAAA,IAAI,CAAC,KAAKgF,MAAN,CAAJ,GAAoBH,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAnC;AACA3E,UAAAA,IAAI,CAAC,KAAKgF,MAAN,CAAJ,GAAoBH,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAnC;AACA3E,UAAAA,IAAI,CAAC,KAAKgF,MAAN,CAAJ,GAAoBH,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAnC;AACA3E,UAAAA,IAAI,CAAC,KAAKgF,MAAN,CAAJ,GAAoBH,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAnC;AACA3E,UAAAA,IAAI,CAAC,KAAKgF,MAAN,CAAJ,GAAoBH,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAnC;AACD;AACF;;AAED,eAASpB,aAAT,CAAuBvD,IAAvB,EAA6B;AAC3B,aAAK,IAAIzG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,EAApB,EAAwB,EAAEA,CAA1B,EAA6B;AAC3B,cAAImK,CAAC,GAAG1D,IAAI,CAAC,CAAD,CAAJ,CAAQzG,CAAR,CAAR;AACA,cAAI0L,EAAE,GAAGjF,IAAI,CAAC,CAAD,CAAJ,CAAQzG,CAAR,CAAT;AACA,cAAI2L,EAAE,GAAGlF,IAAI,CAAC,CAAD,CAAJ,CAAQzG,CAAR,CAAT;AACAyG,UAAAA,IAAI,CAAC,CAAD,CAAJ,CAAQzG,CAAR,IAAamK,CAAC,GAAG,SAASwB,EAA1B;AACAlF,UAAAA,IAAI,CAAC,CAAD,CAAJ,CAAQzG,CAAR,IAAamK,CAAC,GAAG,SAASuB,EAAb,GAAkB,SAASC,EAAxC;AACAlF,UAAAA,IAAI,CAAC,CAAD,CAAJ,CAAQzG,CAAR,IAAamK,CAAC,GAAG,SAASuB,EAA1B;AACD;AACF;;AAED,eAASzB,aAAT,CAAuBG,GAAvB,EAA4BU,GAA5B,EAAiCxC,GAAjC,EAAsC;AACpC,aAAK,IAAItI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,EAApB,EAAwB,EAAEA,CAA1B,EAA6B;AAC3B8K,UAAAA,GAAG,CAACxC,GAAG,GAAGtI,CAAP,CAAH,GAAepC,SAAS,CAACgO,WAAV,CAAsBC,QAAQ,CAACzB,GAAG,CAACpK,CAAD,CAAJ,CAA9B,CAAf;AACD;AACF;;AAED,eAAS6L,QAAT,CAAkBC,KAAlB,EAAyB;AACvB,YAAIA,KAAK,IAAI,CAAb,EAAgB;AACd,iBAAOpM,IAAI,CAACqM,IAAL,CAAUD,KAAV,IAAmBpM,IAAI,CAACC,GAAL,CAASD,IAAI,CAACsM,GAAL,CAASF,KAAT,CAAT,EAA0B,GAA1B,CAA1B;AACD,SAFD,MAEO;AACL,iBAAOpM,IAAI,CAACqM,IAAL,CAAUD,KAAV,IAAmBpM,IAAI,CAACC,GAAL,CAASF,OAAT,EAAkBC,IAAI,CAACsM,GAAL,CAASF,KAAT,IAAkB,GAApC,CAA1B;AACD;AACF;;AAED,eAASG,aAAT,CAAuBC,IAAvB,EAA6B;AAC3B,eAAO,IAAIzE,QAAJ,CAAayE,IAAI,CAACC,KAAL,CAAWlO,MAAxB,EAAgCiO,IAAI,CAAChC,MAAL,CAAYxI,KAA5C,EAAmDwK,IAAI,CAAC5E,IAAxD,CAAP;AACD;;AAED,eAAS8E,aAAT,CAAuBF,IAAvB,EAA6B;AAC3B,YAAIG,UAAU,GAAGH,IAAI,CAACI,MAAL,CAAYrO,MAAZ,CAAmBsO,KAAnB,CAAyBL,IAAI,CAAChC,MAAL,CAAYxI,KAArC,EAA4CwK,IAAI,CAAChC,MAAL,CAAYxI,KAAZ,GAAoBwK,IAAI,CAAC5E,IAArE,CAAjB;AACA,YAAIkF,SAAS,GAAG,IAAI3J,UAAJ,CAAewE,eAAe,CAACgF,UAAD,CAA9B,CAAhB;AACA,YAAII,SAAS,GAAG,IAAI5J,UAAJ,CAAe2J,SAAS,CAAC1F,MAAzB,CAAhB;AACAH,QAAAA,SAAS,CAAC6F,SAAD,CAAT,CAJ2B,CAIL;;AAEtBzF,QAAAA,gBAAgB,CAACyF,SAAD,EAAYC,SAAZ,CAAhB,CAN2B,CAMa;;AAExC,eAAO,IAAIhF,QAAJ,CAAagF,SAAS,CAACxO,MAAvB,CAAP;AACD;;AAED,eAASyO,aAAT,CAAuBR,IAAvB,EAA6B;AAC3B,YAAIG,UAAU,GAAGH,IAAI,CAACC,KAAL,CAAWI,KAAX,CAAiBL,IAAI,CAAChC,MAAL,CAAYxI,KAA7B,EAAoCwK,IAAI,CAAChC,MAAL,CAAYxI,KAAZ,GAAoBwK,IAAI,CAAC5E,IAA7D,CAAjB;AACA,YAAIkF,SAAS,GAAG3O,UAAU,CAACwO,UAAD,CAA1B,CAF2B,CAEa;;AAExC,YAAII,SAAS,GAAG,IAAI5J,UAAJ,CAAe2J,SAAS,CAAC1F,MAAzB,CAAhB;AACAH,QAAAA,SAAS,CAAC6F,SAAD,CAAT,CAL2B,CAKL;;AAEtBzF,QAAAA,gBAAgB,CAACyF,SAAD,EAAYC,SAAZ,CAAhB,CAP2B,CAOa;;AAExC,eAAO,IAAIhF,QAAJ,CAAagF,SAAS,CAACxO,MAAvB,CAAP;AACD;;AAED,eAAS0O,aAAT,CAAuBT,IAAvB,EAA6B;AAC3B,YAAI5K,UAAU,GAAG4K,IAAI,CAACI,MAAtB;AACA,YAAIxL,QAAQ,GAAG;AACbY,UAAAA,KAAK,EAAEwK,IAAI,CAAChC,MAAL,CAAYxI;AADN,SAAf;AAGA,YAAIe,SAAS,GAAG,IAAI8G,WAAJ,CAAgB2C,IAAI,CAAC7D,KAAL,GAAa6D,IAAI,CAACU,iBAAlB,IAAuCV,IAAI,CAACW,QAAL,GAAgBX,IAAI,CAAClO,IAA5D,CAAhB,CAAhB;AACA,YAAI6B,MAAM,GAAG,IAAIgD,UAAJ,CAAe1E,WAAf,CAAb,CAN2B,CAMe;;AAE1C,YAAI2O,YAAY,GAAG,CAAnB;AACA,YAAIC,cAAc,GAAG,IAAI9L,KAAJ,CAAUiL,IAAI,CAACW,QAAf,CAArB;;AAEA,aAAK,IAAI7M,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkM,IAAI,CAACW,QAAzB,EAAmC7M,CAAC,EAApC,EAAwC;AACtC+M,UAAAA,cAAc,CAAC/M,CAAD,CAAd,GAAoB,EAApB;AACA+M,UAAAA,cAAc,CAAC/M,CAAD,CAAd,CAAkB,OAAlB,IAA6B8M,YAA7B;AACAC,UAAAA,cAAc,CAAC/M,CAAD,CAAd,CAAkB,KAAlB,IAA2B+M,cAAc,CAAC/M,CAAD,CAAd,CAAkB,OAAlB,CAA3B;AACA+M,UAAAA,cAAc,CAAC/M,CAAD,CAAd,CAAkB,IAAlB,IAA0BkM,IAAI,CAAC7D,KAA/B;AACA0E,UAAAA,cAAc,CAAC/M,CAAD,CAAd,CAAkB,IAAlB,IAA0BkM,IAAI,CAACc,KAA/B;AACAD,UAAAA,cAAc,CAAC/M,CAAD,CAAd,CAAkB,MAAlB,IAA4BkM,IAAI,CAAClO,IAAjC;AACA8O,UAAAA,YAAY,IAAIC,cAAc,CAAC/M,CAAD,CAAd,CAAkBoE,EAAlB,GAAuB2I,cAAc,CAAC/M,CAAD,CAAd,CAAkBsE,EAAzC,GAA8CyI,cAAc,CAAC/M,CAAD,CAAd,CAAkBsH,IAAhF;AACD,SAnB0B,CAmBzB;;;AAGF,YAAI2F,UAAU,GAAGC,WAAW,CAAC5L,UAAD,EAAaR,QAAb,CAA5B;AACA,YAAIqM,UAAU,GAAGD,WAAW,CAAC5L,UAAD,EAAaR,QAAb,CAA5B;;AAEA,YAAIqM,UAAU,IAAIhP,WAAlB,EAA+B;AAC7B,gBAAM,qDAAN;AACD;;AAED,YAAI8O,UAAU,IAAIE,UAAlB,EAA8B;AAC5B,eAAK,IAAInN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmN,UAAU,GAAGF,UAAb,GAA0B,CAA9C,EAAiDjN,CAAC,EAAlD,EAAsD;AACpDH,YAAAA,MAAM,CAACG,CAAC,GAAGiN,UAAL,CAAN,GAAyBG,UAAU,CAAC9L,UAAD,EAAaR,QAAb,CAAnC;AACD;AACF,SAjC0B,CAiCzB;;;AAGF,YAAIhB,GAAG,GAAG,IAAIyJ,WAAJ,CAAgBrL,YAAhB,CAAV;AACA,YAAImP,QAAQ,GAAGzN,oBAAoB,CAACC,MAAD,EAASC,GAAT,CAAnC;AACA,YAAIgH,MAAM,GAAGR,WAAW,CAAChF,UAAD,EAAaR,QAAb,CAAxB,CAtC2B,CAsCqB;;AAEhDoF,QAAAA,aAAa,CAACgG,IAAI,CAACC,KAAN,EAAa7K,UAAb,EAAyBR,QAAzB,EAAmCgG,MAAnC,EAA2CrE,SAA3C,EAAsDqK,YAAtD,CAAb,CAxC2B,CAwCuD;;AAElF,aAAK,IAAI9M,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkM,IAAI,CAACW,QAAzB,EAAmC,EAAE7M,CAArC,EAAwC;AACtC,cAAIsN,EAAE,GAAGP,cAAc,CAAC/M,CAAD,CAAvB;;AAEA,eAAK,IAAImE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4I,cAAc,CAAC/M,CAAD,CAAd,CAAkBsH,IAAtC,EAA4C,EAAEnD,CAA9C,EAAiD;AAC/CD,YAAAA,UAAU,CAACzB,SAAD,EAAY6K,EAAE,CAACC,KAAH,GAAWpJ,CAAvB,EAA0BmJ,EAAE,CAAClJ,EAA7B,EAAiCkJ,EAAE,CAAChG,IAApC,EAA0CgG,EAAE,CAAChJ,EAA7C,EAAiDgJ,EAAE,CAAClJ,EAAH,GAAQkJ,EAAE,CAAChG,IAA5D,EAAkE+F,QAAlE,CAAV;AACD;AACF,SAhD0B,CAgDzB;;;AAGF7G,QAAAA,QAAQ,CAAC1G,GAAD,EAAM2C,SAAN,EAAiBqK,YAAjB,CAAR,CAnD2B,CAmDa;;AAExC,YAAIU,SAAS,GAAG,CAAhB;AACA,YAAIf,SAAS,GAAG,IAAI5J,UAAJ,CAAeJ,SAAS,CAACxE,MAAV,CAAiBsJ,UAAhC,CAAhB;;AAEA,aAAK,IAAI4C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+B,IAAI,CAACc,KAAzB,EAAgC7C,CAAC,EAAjC,EAAqC;AACnC,eAAK,IAAI1J,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyL,IAAI,CAACW,QAAzB,EAAmCpM,CAAC,EAApC,EAAwC;AACtC,gBAAI6M,EAAE,GAAGP,cAAc,CAACtM,CAAD,CAAvB;AACA,gBAAIR,CAAC,GAAGqN,EAAE,CAAClJ,EAAH,GAAQkJ,EAAE,CAAChG,IAAnB;AACA,gBAAImG,EAAE,GAAG,IAAI5K,UAAJ,CAAeJ,SAAS,CAACxE,MAAzB,EAAiCqP,EAAE,CAACI,GAAH,GAASxO,UAA1C,EAAsDe,CAAC,GAAGf,UAA1D,CAAT;AACAuN,YAAAA,SAAS,CAACkB,GAAV,CAAcF,EAAd,EAAkBD,SAAlB;AACAA,YAAAA,SAAS,IAAIvN,CAAC,GAAGf,UAAjB;AACAoO,YAAAA,EAAE,CAACI,GAAH,IAAUzN,CAAV;AACD;AACF;;AAED,eAAO,IAAIwH,QAAJ,CAAagF,SAAS,CAACxO,MAAvB,CAAP;AACD;;AAED,eAAS2P,aAAT,CAAuB1B,IAAvB,EAA6B;AAC3B,YAAIG,UAAU,GAAGH,IAAI,CAACC,KAAL,CAAWI,KAAX,CAAiBL,IAAI,CAAChC,MAAL,CAAYxI,KAA7B,EAAoCwK,IAAI,CAAChC,MAAL,CAAYxI,KAAZ,GAAoBwK,IAAI,CAAC5E,IAA7D,CAAjB;AACA,YAAIkF,SAAS,GAAG3O,UAAU,CAACwO,UAAD,CAA1B,CAF2B,CAEa;;AAExC,YAAMwB,EAAE,GAAG3B,IAAI,CAACc,KAAL,GAAad,IAAI,CAACW,QAAlB,GAA6BX,IAAI,CAAC7D,KAA7C;AACA,YAAMoE,SAAS,GAAGP,IAAI,CAAClO,IAAL,IAAa,CAAb,GAAiB,IAAIuL,WAAJ,CAAgBsE,EAAhB,CAAjB,GAAuC,IAAIC,WAAJ,CAAgBD,EAAhB,CAAzD;AACA,YAAIE,YAAY,GAAG,CAAnB;AACA,YAAIC,QAAQ,GAAG,CAAf;AACA,YAAMC,GAAG,GAAG,IAAIhN,KAAJ,CAAU,CAAV,CAAZ;;AAEA,aAAK,IAAIkJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+B,IAAI,CAACc,KAAzB,EAAgC7C,CAAC,EAAjC,EAAqC;AACnC,eAAK,IAAI1J,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyL,IAAI,CAACW,QAAzB,EAAmCpM,CAAC,EAApC,EAAwC;AACtC,gBAAIyN,KAAK,GAAG,CAAZ;;AAEA,oBAAQhC,IAAI,CAAClO,IAAb;AACE,mBAAK,CAAL;AACEiQ,gBAAAA,GAAG,CAAC,CAAD,CAAH,GAASF,YAAT;AACAE,gBAAAA,GAAG,CAAC,CAAD,CAAH,GAASA,GAAG,CAAC,CAAD,CAAH,GAAS/B,IAAI,CAAC7D,KAAvB;AACA0F,gBAAAA,YAAY,GAAGE,GAAG,CAAC,CAAD,CAAH,GAAS/B,IAAI,CAAC7D,KAA7B;;AAEA,qBAAK,IAAIlE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+H,IAAI,CAAC7D,KAAzB,EAAgC,EAAElE,CAAlC,EAAqC;AACnC,sBAAMgK,IAAI,GAAG3B,SAAS,CAACyB,GAAG,CAAC,CAAD,CAAH,EAAD,CAAT,IAAuB,CAAvB,GAA2BzB,SAAS,CAACyB,GAAG,CAAC,CAAD,CAAH,EAAD,CAAjD;AACAC,kBAAAA,KAAK,IAAIC,IAAT;AACA1B,kBAAAA,SAAS,CAACuB,QAAD,CAAT,GAAsBE,KAAtB;AACAF,kBAAAA,QAAQ;AACT;;AAED;;AAEF,mBAAK,CAAL;AACEC,gBAAAA,GAAG,CAAC,CAAD,CAAH,GAASF,YAAT;AACAE,gBAAAA,GAAG,CAAC,CAAD,CAAH,GAASA,GAAG,CAAC,CAAD,CAAH,GAAS/B,IAAI,CAAC7D,KAAvB;AACA4F,gBAAAA,GAAG,CAAC,CAAD,CAAH,GAASA,GAAG,CAAC,CAAD,CAAH,GAAS/B,IAAI,CAAC7D,KAAvB;AACA0F,gBAAAA,YAAY,GAAGE,GAAG,CAAC,CAAD,CAAH,GAAS/B,IAAI,CAAC7D,KAA7B;;AAEA,qBAAK,IAAIlE,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAG+H,IAAI,CAAC7D,KAAzB,EAAgC,EAAElE,EAAlC,EAAqC;AACnC,sBAAMgK,KAAI,GAAG3B,SAAS,CAACyB,GAAG,CAAC,CAAD,CAAH,EAAD,CAAT,IAAuB,EAAvB,GAA4BzB,SAAS,CAACyB,GAAG,CAAC,CAAD,CAAH,EAAD,CAAT,IAAuB,EAAnD,GAAwDzB,SAAS,CAACyB,GAAG,CAAC,CAAD,CAAH,EAAD,CAAT,IAAuB,CAA5F;;AACAC,kBAAAA,KAAK,IAAIC,KAAT;AACA1B,kBAAAA,SAAS,CAACuB,QAAD,CAAT,GAAsBE,KAAtB;AACAF,kBAAAA,QAAQ;AACT;;AAED;AA5BJ;AA8BD;AACF;;AAED,eAAO,IAAIvG,QAAJ,CAAagF,SAAS,CAACxO,MAAvB,CAAP;AACD;;AAED,eAASmQ,aAAT,CAAuBlC,IAAvB,EAA6B;AAC3B,YAAI5K,UAAU,GAAG4K,IAAI,CAACI,MAAtB;AACA,YAAIxL,QAAQ,GAAG;AACbY,UAAAA,KAAK,EAAEwK,IAAI,CAAChC,MAAL,CAAYxI;AADN,SAAf;AAGA,YAAIe,SAAS,GAAG,IAAII,UAAJ,CAAeqJ,IAAI,CAAC7D,KAAL,GAAa6D,IAAI,CAACc,KAAlB,IAA2Bd,IAAI,CAACW,QAAL,GAAgBX,IAAI,CAAClO,IAArB,GAA4BkB,UAAvD,CAAf,CAAhB,CAL2B,CAKyE;;AAEpG,YAAImP,SAAS,GAAG;AACdC,UAAAA,OAAO,EAAEC,UAAU,CAACjN,UAAD,EAAaR,QAAb,CADL;AAEd0N,UAAAA,uBAAuB,EAAED,UAAU,CAACjN,UAAD,EAAaR,QAAb,CAFrB;AAGd2N,UAAAA,qBAAqB,EAAEF,UAAU,CAACjN,UAAD,EAAaR,QAAb,CAHnB;AAId4N,UAAAA,gBAAgB,EAAEH,UAAU,CAACjN,UAAD,EAAaR,QAAb,CAJd;AAKd6N,UAAAA,gBAAgB,EAAEJ,UAAU,CAACjN,UAAD,EAAaR,QAAb,CALd;AAMd8N,UAAAA,iBAAiB,EAAEL,UAAU,CAACjN,UAAD,EAAaR,QAAb,CANf;AAOd+N,UAAAA,mBAAmB,EAAEN,UAAU,CAACjN,UAAD,EAAaR,QAAb,CAPjB;AAQdgO,UAAAA,UAAU,EAAEP,UAAU,CAACjN,UAAD,EAAaR,QAAb,CARR;AASdiO,UAAAA,wBAAwB,EAAER,UAAU,CAACjN,UAAD,EAAaR,QAAb,CATtB;AAUdkO,UAAAA,wBAAwB,EAAET,UAAU,CAACjN,UAAD,EAAaR,QAAb,CAVtB;AAWdmO,UAAAA,aAAa,EAAEV,UAAU,CAACjN,UAAD,EAAaR,QAAb;AAXX,SAAhB;;AAcA,YAAIuN,SAAS,CAACC,OAAV,GAAoB,CAAxB,EAA2B;AACzB,gBAAM,sBAAsBY,SAAS,CAACC,WAAhC,GAA8C,WAA9C,GAA4Dd,SAAS,CAACC,OAAtE,GAAgF,iBAAtF;AACD,SAvB0B,CAuBzB;;;AAGF,YAAIc,YAAY,GAAG,IAAInO,KAAJ,EAAnB;AACA,YAAIoO,QAAQ,GAAGnC,WAAW,CAAC5L,UAAD,EAAaR,QAAb,CAAX,GAAoC5B,UAAnD;;AAEA,eAAOmQ,QAAQ,GAAG,CAAlB,EAAqB;AACnB,cAAIC,IAAI,GAAGC,yBAAyB,CAACjO,UAAU,CAACrD,MAAZ,EAAoB6C,QAApB,CAApC;AACA,cAAIY,KAAK,GAAG0L,UAAU,CAAC9L,UAAD,EAAaR,QAAb,CAAtB;AACA,cAAIqO,WAAW,GAAGzN,KAAK,IAAI,CAAT,GAAa,CAA/B;AACA,cAAI8N,GAAG,GAAG,CAAC9N,KAAK,IAAI,CAAV,IAAe,CAAzB;AACA,cAAIuE,KAAK,GAAG,IAAIwJ,SAAJ,CAAc,CAACD,GAAD,CAAd,EAAqB,CAArB,CAAZ;AACA,cAAIxR,IAAI,GAAGoP,UAAU,CAAC9L,UAAD,EAAaR,QAAb,CAArB;AACAsO,UAAAA,YAAY,CAACxH,IAAb,CAAkB;AAChB0H,YAAAA,IAAI,EAAEA,IADU;AAEhBrJ,YAAAA,KAAK,EAAEA,KAFS;AAGhBjI,YAAAA,IAAI,EAAEA,IAHU;AAIhBmR,YAAAA,WAAW,EAAEA;AAJG,WAAlB;AAMAE,UAAAA,QAAQ,IAAIC,IAAI,CAACxI,MAAL,GAAc,CAA1B;AACD,SA3C0B,CA2CzB;;;AAGF,YAAI+F,QAAQ,GAAGqC,SAAS,CAACrC,QAAzB;AACA,YAAI5E,WAAW,GAAG,IAAIhH,KAAJ,CAAUiL,IAAI,CAACW,QAAf,CAAlB;;AAEA,aAAK,IAAI7M,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkM,IAAI,CAACW,QAAzB,EAAmC,EAAE7M,CAArC,EAAwC;AACtC,cAAIsN,EAAE,GAAGrF,WAAW,CAACjI,CAAD,CAAX,GAAiB,EAA1B;AACA,cAAI0P,OAAO,GAAG7C,QAAQ,CAAC7M,CAAD,CAAtB;AACAsN,UAAAA,EAAE,CAACgC,IAAH,GAAUI,OAAO,CAACJ,IAAlB;AACAhC,UAAAA,EAAE,CAAC6B,WAAH,GAAiB7P,OAAjB;AACAgO,UAAAA,EAAE,CAAC9C,OAAH,GAAa,KAAb;AACA8C,UAAAA,EAAE,CAACtP,IAAH,GAAU0R,OAAO,CAACC,SAAlB;AACArC,UAAAA,EAAE,CAACsC,OAAH,GAAaF,OAAO,CAACE,OAArB;AACAtC,UAAAA,EAAE,CAACjF,KAAH,GAAW6D,IAAI,CAAC7D,KAAhB;AACAiF,UAAAA,EAAE,CAAC/E,MAAH,GAAY2D,IAAI,CAACc,KAAjB;AACD;;AAED,YAAIjF,MAAM,GAAG;AACXO,UAAAA,GAAG,EAAE,IAAIrH,KAAJ,CAAU,CAAV;AADM,SAAb;;AAIA,aAAK,IAAIiJ,MAAM,GAAG,CAAlB,EAAqBA,MAAM,GAAGgC,IAAI,CAACW,QAAnC,EAA6C,EAAE3C,MAA/C,EAAuD;AACrD,cAAIoD,EAAE,GAAGrF,WAAW,CAACiC,MAAD,CAApB;;AAEA,eAAK,IAAIlK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoP,YAAY,CAACtI,MAAjC,EAAyC,EAAE9G,CAA3C,EAA8C;AAC5C,gBAAI6P,IAAI,GAAGT,YAAY,CAACpP,CAAD,CAAvB;;AAEA,gBAAIsN,EAAE,CAACgC,IAAH,IAAWO,IAAI,CAACP,IAApB,EAA0B;AACxBhC,cAAAA,EAAE,CAAC6B,WAAH,GAAiBU,IAAI,CAACV,WAAtB;;AAEA,kBAAIU,IAAI,CAAC5J,KAAL,IAAc,CAAlB,EAAqB;AACnB8B,gBAAAA,MAAM,CAACO,GAAP,CAAWuH,IAAI,CAAC5J,KAAhB,IAAyBiE,MAAzB;AACD;;AAEDoD,cAAAA,EAAE,CAACpD,MAAH,GAAYA,MAAZ;AACD;AACF;AACF,SAjF0B,CAiFzB;;;AAGF,YAAImE,SAAS,CAACK,gBAAV,GAA6B,CAAjC,EAAoC;AAClC,kBAAQL,SAAS,CAACY,aAAlB;AACE,iBAAK7P,cAAL;AACE,kBAAI8I,QAAQ,GAAG,IAAIqB,WAAJ,CAAgB8E,SAAS,CAACU,wBAA1B,CAAf;AACA7I,cAAAA,aAAa,CAACgG,IAAI,CAACC,KAAN,EAAa7K,UAAb,EAAyBR,QAAzB,EAAmCuN,SAAS,CAACK,gBAA7C,EAA+DxG,QAA/D,EAAyEmG,SAAS,CAACU,wBAAnF,CAAb;AACA;;AAEF,iBAAK1P,OAAL;AACE,kBAAIgN,UAAU,GAAGH,IAAI,CAACC,KAAL,CAAWI,KAAX,CAAiBzL,QAAQ,CAACY,KAA1B,EAAiCZ,QAAQ,CAACY,KAAT,GAAiB2M,SAAS,CAACU,wBAA5D,CAAjB;AACA,kBAAItI,IAAI,GAAG5I,UAAU,CAACwO,UAAD,CAArB,CAFF,CAEqC;;AAEnC,kBAAInE,QAAQ,GAAG,IAAIqB,WAAJ,CAAgB9C,IAAI,CAACxI,MAArB,CAAf;AACA6C,cAAAA,QAAQ,CAACY,KAAT,IAAkB2M,SAAS,CAACU,wBAA5B;AACA;AAZJ;AAcD,SAnG0B,CAmGzB;;;AAGF,YAAIV,SAAS,CAACM,gBAAV,GAA6B,CAAjC,EAAoC;AAClC,cAAImB,QAAQ,GAAG;AACb3D,YAAAA,KAAK,EAAED,IAAI,CAACC,KADC;AAEbjC,YAAAA,MAAM,EAAEpJ,QAFK;AAGbwG,YAAAA,IAAI,EAAE+G,SAAS,CAACM;AAHH,WAAf;AAKA,cAAIxG,QAAQ,GAAG,IAAIoB,WAAJ,CAAgBmD,aAAa,CAACoD,QAAD,CAAb,CAAwB7R,MAAxC,CAAf;AACA6C,UAAAA,QAAQ,CAACY,KAAT,IAAkB2M,SAAS,CAACM,gBAA5B;AACD,SA9G0B,CA8GzB;;;AAGF,YAAIN,SAAS,CAACS,UAAV,GAAuB,CAA3B,EAA8B;AAC5B,cAAIzC,UAAU,GAAGH,IAAI,CAACC,KAAL,CAAWI,KAAX,CAAiBzL,QAAQ,CAACY,KAA1B,EAAiCZ,QAAQ,CAACY,KAAT,GAAiB2M,SAAS,CAACO,iBAA5D,CAAjB;AACA,cAAInI,IAAI,GAAG5I,UAAU,CAACwO,UAAD,CAArB,CAF4B,CAEO;;AAEnC,cAAI0D,SAAS,GAAG1I,eAAe,CAACZ,IAAI,CAACxI,MAAN,CAA/B;AACA6C,UAAAA,QAAQ,CAACY,KAAT,IAAkB2M,SAAS,CAACO,iBAA5B;AACD,SAvH0B,CAuHzB;;;AAGF,YAAI9B,YAAY,GAAG,CAAnB;AACA,YAAI1D,UAAU,GAAG,IAAInI,KAAJ,CAAUgH,WAAW,CAACnB,MAAtB,CAAjB;;AAEA,aAAK,IAAI9G,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoJ,UAAU,CAACtC,MAA/B,EAAuC,EAAE9G,CAAzC,EAA4C;AAC1CoJ,UAAAA,UAAU,CAACpJ,CAAD,CAAV,GAAgB,IAAIiB,KAAJ,EAAhB;AACD;;AAED,aAAK,IAAIkJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+B,IAAI,CAACc,KAAzB,EAAgC,EAAE7C,CAAlC,EAAqC;AACnC,eAAK,IAAI6F,IAAI,GAAG,CAAhB,EAAmBA,IAAI,GAAG/H,WAAW,CAACnB,MAAtC,EAA8C,EAAEkJ,IAAhD,EAAsD;AACpD5G,YAAAA,UAAU,CAAC4G,IAAD,CAAV,CAAiBpI,IAAjB,CAAsBkF,YAAtB;AACAA,YAAAA,YAAY,IAAI7E,WAAW,CAAC+H,IAAD,CAAX,CAAkB3H,KAAlB,GAA0B6D,IAAI,CAAClO,IAA/B,GAAsCkB,UAAtD;AACD;AACF,SAtI0B,CAsIzB;;;AAGF4I,QAAAA,cAAc,CAACC,MAAD,EAASqB,UAAT,EAAqBnB,WAArB,EAAkCC,QAAlC,EAA4CC,QAA5C,EAAsD1F,SAAtD,CAAd,CAzI2B,CAyIqD;;AAEhF,aAAK,IAAIzC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiI,WAAW,CAACnB,MAAhC,EAAwC,EAAE9G,CAA1C,EAA6C;AAC3C,cAAIsN,EAAE,GAAGrF,WAAW,CAACjI,CAAD,CAApB;AACA,cAAIsN,EAAE,CAAC9C,OAAP,EAAgB;;AAEhB,kBAAQ8C,EAAE,CAAC6B,WAAX;AACE,iBAAK3P,GAAL;AACE,kBAAI+L,GAAG,GAAG,CAAV;AACA,kBAAI0E,SAAS,GAAG,CAAhB;;AAEA,mBAAK,IAAI9F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+B,IAAI,CAACc,KAAzB,EAAgC,EAAE7C,CAAlC,EAAqC;AACnC,oBAAI+F,cAAc,GAAG9G,UAAU,CAACpJ,CAAD,CAAV,CAAcuL,GAAd,CAArB;;AAEA,qBAAK,IAAIjB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgD,EAAE,CAACjF,KAAvB,EAA8B,EAAEiC,CAAhC,EAAmC;AACjC,uBAAK,IAAI6F,IAAI,GAAG,CAAhB,EAAmBA,IAAI,GAAGjR,UAAU,GAAGoO,EAAE,CAACtP,IAA1C,EAAgD,EAAEmS,IAAlD,EAAwD;AACtD1N,oBAAAA,SAAS,CAACyN,cAAc,EAAf,CAAT,GAA8BH,SAAS,CAACE,SAAS,GAAGE,IAAI,GAAG7C,EAAE,CAACjF,KAAV,GAAkBiF,EAAE,CAAC/E,MAAlC,CAAvC;AACD;;AAED0H,kBAAAA,SAAS;AACV;;AAED1E,gBAAAA,GAAG;AACJ;;AAED;;AAEF,iBAAKhM,SAAL,CArBF,CAqBkB;;AAEhB;AACE,oBAAM,kDAAN;AAxBJ;AA0BD;;AAED,eAAO,IAAIkI,QAAJ,CAAahF,SAAS,CAACxE,MAAvB,CAAP;AACD;;AAED,eAASsR,yBAAT,CAAmCtR,MAAnC,EAA2CiM,MAA3C,EAAmD;AACjD,YAAIkG,UAAU,GAAG,IAAIvN,UAAJ,CAAe5E,MAAf,CAAjB;AACA,YAAIoS,SAAS,GAAG,CAAhB;;AAEA,eAAOD,UAAU,CAAClG,MAAM,CAACxI,KAAP,GAAe2O,SAAhB,CAAV,IAAwC,CAA/C,EAAkD;AAChDA,UAAAA,SAAS,IAAI,CAAb;AACD;;AAED,YAAIC,WAAW,GAAG,IAAIC,WAAJ,GAAkBC,MAAlB,CAAyBJ,UAAU,CAAC7D,KAAX,CAAiBrC,MAAM,CAACxI,KAAxB,EAA+BwI,MAAM,CAACxI,KAAP,GAAe2O,SAA9C,CAAzB,CAAlB;AACAnG,QAAAA,MAAM,CAACxI,KAAP,GAAewI,MAAM,CAACxI,KAAP,GAAe2O,SAAf,GAA2B,CAA1C;AACA,eAAOC,WAAP;AACD;;AAED,eAASG,sBAAT,CAAgCxS,MAAhC,EAAwCiM,MAAxC,EAAgD5C,IAAhD,EAAsD;AACpD,YAAIgJ,WAAW,GAAG,IAAIC,WAAJ,GAAkBC,MAAlB,CAAyB,IAAI3N,UAAJ,CAAe5E,MAAf,EAAuBsO,KAAvB,CAA6BrC,MAAM,CAACxI,KAApC,EAA2CwI,MAAM,CAACxI,KAAP,GAAe4F,IAA1D,CAAzB,CAAlB;AACA4C,QAAAA,MAAM,CAACxI,KAAP,GAAewI,MAAM,CAACxI,KAAP,GAAe4F,IAA9B;AACA,eAAOgJ,WAAP;AACD;;AAED,eAASI,aAAT,CAAuBtI,QAAvB,EAAiC8B,MAAjC,EAAyC;AACvC,YAAII,CAAC,GAAGqG,UAAU,CAACvI,QAAD,EAAW8B,MAAX,CAAlB;AACA,YAAIC,CAAC,GAAG7D,WAAW,CAAC8B,QAAD,EAAW8B,MAAX,CAAnB;AACA,eAAO,CAACI,CAAD,EAAIH,CAAJ,CAAP;AACD;;AAED,eAASyG,aAAT,CAAuBxI,QAAvB,EAAiC8B,MAAjC,EAAyC;AACvC,YAAII,CAAC,GAAGhE,WAAW,CAAC8B,QAAD,EAAW8B,MAAX,CAAnB;AACA,YAAIC,CAAC,GAAG7D,WAAW,CAAC8B,QAAD,EAAW8B,MAAX,CAAnB;AACA,eAAO,CAACI,CAAD,EAAIH,CAAJ,CAAP;AACD;;AAED,eAASwG,UAAT,CAAoBvI,QAApB,EAA8B8B,MAA9B,EAAsC;AACpC,YAAI2G,KAAK,GAAGzI,QAAQ,CAAC0I,QAAT,CAAkB5G,MAAM,CAACxI,KAAzB,EAAgC,IAAhC,CAAZ;AACAwI,QAAAA,MAAM,CAACxI,KAAP,GAAewI,MAAM,CAACxI,KAAP,GAAezC,UAA9B;AACA,eAAO4R,KAAP;AACD;;AAED,eAASvK,WAAT,CAAqB8B,QAArB,EAA+B8B,MAA/B,EAAuC;AACrC,YAAI6G,MAAM,GAAG3I,QAAQ,CAAC4I,SAAT,CAAmB9G,MAAM,CAACxI,KAA1B,EAAiC,IAAjC,CAAb;AACAwI,QAAAA,MAAM,CAACxI,KAAP,GAAewI,MAAM,CAACxI,KAAP,GAAezC,UAA9B;AACA,eAAO8R,MAAP;AACD;;AAED,eAAShQ,eAAT,CAAyBF,UAAzB,EAAqCqJ,MAArC,EAA6C;AAC3C,YAAI+G,KAAK,GAAGpQ,UAAU,CAACqJ,MAAM,CAACxI,KAAR,CAAtB;AACAwI,QAAAA,MAAM,CAACxI,KAAP,GAAewI,MAAM,CAACxI,KAAP,GAAevC,SAA9B;AACA,eAAO8R,KAAP;AACD;;AAED,eAAS7D,UAAT,CAAoBhF,QAApB,EAA8B8B,MAA9B,EAAsC;AACpC,YAAI+G,KAAK,GAAG7I,QAAQ,CAACP,QAAT,CAAkBqC,MAAM,CAACxI,KAAzB,CAAZ;AACAwI,QAAAA,MAAM,CAACxI,KAAP,GAAewI,MAAM,CAACxI,KAAP,GAAevC,SAA9B;AACA,eAAO8R,KAAP;AACD;;AAED,UAAM1C,UAAU,GAAG,SAAbA,UAAa,CAAUnG,QAAV,EAAoB8B,MAApB,EAA4B;AAC7C,YAAIgH,GAAJ;;AAEA,YAAI,iBAAiBzJ,QAAQ,CAAC0J,SAA9B,EAAyC;AACvCD,UAAAA,GAAG,GAAGE,MAAM,CAAChJ,QAAQ,CAACiJ,WAAT,CAAqBnH,MAAM,CAACxI,KAA5B,EAAmC,IAAnC,CAAD,CAAZ;AACD,SAFD,MAEO;AACLwP,UAAAA,GAAG,GAAG9I,QAAQ,CAAC4I,SAAT,CAAmB9G,MAAM,CAACxI,KAAP,GAAe,CAAlC,EAAqC,IAArC,IAA6C0P,MAAM,CAAChJ,QAAQ,CAAC4I,SAAT,CAAmB9G,MAAM,CAACxI,KAA1B,EAAiC,IAAjC,KAA0C,EAA3C,CAAzD;AACD;;AAEDwI,QAAAA,MAAM,CAACxI,KAAP,IAAgB3C,UAAhB;AACA,eAAOmS,GAAP;AACD,OAXD;;AAaA,eAASI,YAAT,CAAsBlJ,QAAtB,EAAgC8B,MAAhC,EAAwC;AACtC,YAAI4B,KAAK,GAAG1D,QAAQ,CAACmJ,UAAT,CAAoBrH,MAAM,CAACxI,KAA3B,EAAkC,IAAlC,CAAZ;AACAwI,QAAAA,MAAM,CAACxI,KAAP,IAAgB1C,YAAhB;AACA,eAAO8M,KAAP;AACD;;AAED,eAAS0F,aAAT,CAAuBpJ,QAAvB,EAAiC8B,MAAjC,EAAyC;AACvC,eAAOtM,SAAS,CAACgO,WAAV,CAAsB0F,YAAY,CAAClJ,QAAD,EAAW8B,MAAX,CAAlC,CAAP;AACD,OAvsCW,CAusCV;;;AAGF,eAASS,aAAT,CAAuB8G,MAAvB,EAA+B;AAC7B,YAAIC,QAAQ,GAAG,CAACD,MAAM,GAAG,MAAV,KAAqB,EAApC;AAAA,YACIE,QAAQ,GAAGF,MAAM,GAAG,MADxB;AAEA,eAAO,CAACA,MAAM,IAAI,EAAV,GAAe,CAAC,CAAhB,GAAoB,CAArB,KAA2BC,QAAQ,GAAGA,QAAQ,KAAK,IAAb,GAAoBC,QAAQ,GAAGC,GAAH,GAASC,QAArC,GAAgDnS,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY+R,QAAQ,GAAG,EAAvB,KAA8B,IAAIC,QAAQ,GAAG,KAA7C,CAAnD,GAAyG,kBAAkBA,QAAQ,GAAG,KAA7B,CAA5I,CAAP;AACD;;AAED,eAASzE,WAAT,CAAqB9E,QAArB,EAA+B8B,MAA/B,EAAuC;AACrC,YAAI4H,MAAM,GAAG1J,QAAQ,CAACqC,SAAT,CAAmBP,MAAM,CAACxI,KAA1B,EAAiC,IAAjC,CAAb;AACAwI,QAAAA,MAAM,CAACxI,KAAP,IAAgBxC,UAAhB;AACA,eAAO4S,MAAP;AACD;;AAED,eAASC,YAAT,CAAsB9T,MAAtB,EAA8BiM,MAA9B,EAAsC;AACpC,eAAOS,aAAa,CAACuC,WAAW,CAACjP,MAAD,EAASiM,MAAT,CAAZ,CAApB;AACD;;AAED,eAAS8H,WAAT,CAAqB5J,QAArB,EAA+BnK,MAA/B,EAAuCiM,MAAvC,EAA+C5C,IAA/C,EAAqD;AACnD,YAAI2K,WAAW,GAAG/H,MAAM,CAACxI,KAAzB;AACA,YAAImL,QAAQ,GAAG,EAAf;;AAEA,eAAO3C,MAAM,CAACxI,KAAP,GAAeuQ,WAAW,GAAG3K,IAAd,GAAqB,CAA3C,EAA8C;AAC5C,cAAIgI,IAAI,GAAGC,yBAAyB,CAACtR,MAAD,EAASiM,MAAT,CAApC;AACA,cAAIyF,SAAS,GAAGgB,UAAU,CAACvI,QAAD,EAAW8B,MAAX,CAA1B;AACA,cAAI0F,OAAO,GAAGxC,UAAU,CAAChF,QAAD,EAAW8B,MAAX,CAAxB;AACAA,UAAAA,MAAM,CAACxI,KAAP,IAAgB,CAAhB,CAJ4C,CAIzB;;AAEnB,cAAIwQ,SAAS,GAAGvB,UAAU,CAACvI,QAAD,EAAW8B,MAAX,CAA1B;AACA,cAAIiI,SAAS,GAAGxB,UAAU,CAACvI,QAAD,EAAW8B,MAAX,CAA1B;AACA2C,UAAAA,QAAQ,CAACjF,IAAT,CAAc;AACZ0H,YAAAA,IAAI,EAAEA,IADM;AAEZK,YAAAA,SAAS,EAAEA,SAFC;AAGZC,YAAAA,OAAO,EAAEA,OAHG;AAIZsC,YAAAA,SAAS,EAAEA,SAJC;AAKZC,YAAAA,SAAS,EAAEA;AALC,WAAd;AAOD;;AAEDjI,QAAAA,MAAM,CAACxI,KAAP,IAAgB,CAAhB;AACA,eAAOmL,QAAP;AACD;;AAED,eAASuF,mBAAT,CAA6BhK,QAA7B,EAAuC8B,MAAvC,EAA+C;AAC7C,YAAImI,IAAI,GAAGf,YAAY,CAAClJ,QAAD,EAAW8B,MAAX,CAAvB;AACA,YAAIoI,IAAI,GAAGhB,YAAY,CAAClJ,QAAD,EAAW8B,MAAX,CAAvB;AACA,YAAIqI,MAAM,GAAGjB,YAAY,CAAClJ,QAAD,EAAW8B,MAAX,CAAzB;AACA,YAAIsI,MAAM,GAAGlB,YAAY,CAAClJ,QAAD,EAAW8B,MAAX,CAAzB;AACA,YAAIuI,KAAK,GAAGnB,YAAY,CAAClJ,QAAD,EAAW8B,MAAX,CAAxB;AACA,YAAIwI,KAAK,GAAGpB,YAAY,CAAClJ,QAAD,EAAW8B,MAAX,CAAxB;AACA,YAAIyI,MAAM,GAAGrB,YAAY,CAAClJ,QAAD,EAAW8B,MAAX,CAAzB;AACA,YAAI0I,MAAM,GAAGtB,YAAY,CAAClJ,QAAD,EAAW8B,MAAX,CAAzB;AACA,eAAO;AACLmI,UAAAA,IAAI,EAAEA,IADD;AAELC,UAAAA,IAAI,EAAEA,IAFD;AAGLC,UAAAA,MAAM,EAAEA,MAHH;AAILC,UAAAA,MAAM,EAAEA,MAJH;AAKLC,UAAAA,KAAK,EAAEA,KALF;AAMLC,UAAAA,KAAK,EAAEA,KANF;AAOLC,UAAAA,MAAM,EAAEA,MAPH;AAQLC,UAAAA,MAAM,EAAEA;AARH,SAAP;AAUD;;AAED,eAASC,gBAAT,CAA0BzK,QAA1B,EAAoC8B,MAApC,EAA4C;AAC1C,YAAI4I,gBAAgB,GAAG,CAAC,gBAAD,EAAmB,iBAAnB,EAAsC,kBAAtC,EAA0D,iBAA1D,EAA6E,iBAA7E,EAAgG,mBAAhG,EAAqH,iBAArH,EAAwI,kBAAxI,EAA4J,kBAA5J,EAAgL,kBAAhL,CAAvB;AACA,YAAI3D,WAAW,GAAG/B,UAAU,CAAChF,QAAD,EAAW8B,MAAX,CAA5B;AACA,eAAO4I,gBAAgB,CAAC3D,WAAD,CAAvB;AACD;;AAED,eAAS4D,UAAT,CAAoB3K,QAApB,EAA8B8B,MAA9B,EAAsC;AACpC,YAAI8I,IAAI,GAAG1M,WAAW,CAAC8B,QAAD,EAAW8B,MAAX,CAAtB;AACA,YAAI+I,IAAI,GAAG3M,WAAW,CAAC8B,QAAD,EAAW8B,MAAX,CAAtB;AACA,YAAIgJ,IAAI,GAAG5M,WAAW,CAAC8B,QAAD,EAAW8B,MAAX,CAAtB;AACA,YAAIiJ,IAAI,GAAG7M,WAAW,CAAC8B,QAAD,EAAW8B,MAAX,CAAtB;AACA,eAAO;AACL8I,UAAAA,IAAI,EAAEA,IADD;AAELC,UAAAA,IAAI,EAAEA,IAFD;AAGLC,UAAAA,IAAI,EAAEA,IAHD;AAILC,UAAAA,IAAI,EAAEA;AAJD,SAAP;AAMD;;AAED,eAASC,cAAT,CAAwBhL,QAAxB,EAAkC8B,MAAlC,EAA0C;AACxC,YAAImJ,UAAU,GAAG,CAAC,cAAD,CAAjB;AACA,YAAIC,SAAS,GAAGlG,UAAU,CAAChF,QAAD,EAAW8B,MAAX,CAA1B;AACA,eAAOmJ,UAAU,CAACC,SAAD,CAAjB;AACD;;AAED,eAASC,QAAT,CAAkBnL,QAAlB,EAA4B8B,MAA5B,EAAoC;AAClC,YAAII,CAAC,GAAGgH,YAAY,CAAClJ,QAAD,EAAW8B,MAAX,CAApB;AACA,YAAIC,CAAC,GAAGmH,YAAY,CAAClJ,QAAD,EAAW8B,MAAX,CAApB;AACA,eAAO,CAACI,CAAD,EAAIH,CAAJ,CAAP;AACD;;AAED,eAASqJ,QAAT,CAAkBpL,QAAlB,EAA4B8B,MAA5B,EAAoC;AAClC,YAAII,CAAC,GAAGgH,YAAY,CAAClJ,QAAD,EAAW8B,MAAX,CAApB;AACA,YAAIC,CAAC,GAAGmH,YAAY,CAAClJ,QAAD,EAAW8B,MAAX,CAApB;AACA,YAAIuJ,CAAC,GAAGnC,YAAY,CAAClJ,QAAD,EAAW8B,MAAX,CAApB;AACA,eAAO,CAACI,CAAD,EAAIH,CAAJ,EAAOsJ,CAAP,CAAP;AACD;;AAED,eAASC,UAAT,CAAoBtL,QAApB,EAA8BnK,MAA9B,EAAsCiM,MAAtC,EAA8ClM,IAA9C,EAAoDsJ,IAApD,EAA0D;AACxD,YAAItJ,IAAI,KAAK,QAAT,IAAqBA,IAAI,KAAK,cAA9B,IAAgDA,IAAI,KAAK,YAA7D,EAA2E;AACzE,iBAAOyS,sBAAsB,CAACxS,MAAD,EAASiM,MAAT,EAAiB5C,IAAjB,CAA7B;AACD,SAFD,MAEO,IAAItJ,IAAI,KAAK,QAAb,EAAuB;AAC5B,iBAAOgU,WAAW,CAAC5J,QAAD,EAAWnK,MAAX,EAAmBiM,MAAnB,EAA2B5C,IAA3B,CAAlB;AACD,SAFM,MAEA,IAAItJ,IAAI,KAAK,gBAAb,EAA+B;AACpC,iBAAOoU,mBAAmB,CAAChK,QAAD,EAAW8B,MAAX,CAA1B;AACD,SAFM,MAEA,IAAIlM,IAAI,KAAK,aAAb,EAA4B;AACjC,iBAAO6U,gBAAgB,CAACzK,QAAD,EAAW8B,MAAX,CAAvB;AACD,SAFM,MAEA,IAAIlM,IAAI,KAAK,OAAb,EAAsB;AAC3B,iBAAO+U,UAAU,CAAC3K,QAAD,EAAW8B,MAAX,CAAjB;AACD,SAFM,MAEA,IAAIlM,IAAI,KAAK,WAAb,EAA0B;AAC/B,iBAAOoV,cAAc,CAAChL,QAAD,EAAW8B,MAAX,CAArB;AACD,SAFM,MAEA,IAAIlM,IAAI,KAAK,OAAb,EAAsB;AAC3B,iBAAOsT,YAAY,CAAClJ,QAAD,EAAW8B,MAAX,CAAnB;AACD,SAFM,MAEA,IAAIlM,IAAI,KAAK,KAAb,EAAoB;AACzB,iBAAOuV,QAAQ,CAACnL,QAAD,EAAW8B,MAAX,CAAf;AACD,SAFM,MAEA,IAAIlM,IAAI,KAAK,KAAb,EAAoB;AACzB,iBAAOwV,QAAQ,CAACpL,QAAD,EAAW8B,MAAX,CAAf;AACD,SAFM,MAEA,IAAIlM,IAAI,KAAK,KAAb,EAAoB;AACzB,iBAAO2S,UAAU,CAACvI,QAAD,EAAW8B,MAAX,CAAjB;AACD,SAFM,MAEA,IAAIlM,IAAI,KAAK,UAAb,EAAyB;AAC9B,iBAAO0S,aAAa,CAACtI,QAAD,EAAW8B,MAAX,CAApB;AACD,SAFM,MAEA,IAAIlM,IAAI,KAAK,UAAb,EAAyB;AAC9B,iBAAO4S,aAAa,CAACxI,QAAD,EAAW8B,MAAX,CAApB;AACD,SAFM,MAEA,IAAIlM,IAAI,KAAK,SAAb,EAAwB;AAC7BkM,UAAAA,MAAM,CAACxI,KAAP,IAAgB4F,IAAhB;AACA,iBAAO,SAAP;AACD,SAHM,MAGA;AACL4C,UAAAA,MAAM,CAACxI,KAAP,IAAgB4F,IAAhB;AACA,iBAAOqM,SAAP;AACD;AACF;;AAED,eAASC,WAAT,CAAqBxL,QAArB,EAA+BnK,MAA/B,EAAuCiM,MAAvC,EAA+C;AAC7C,YAAMgF,SAAS,GAAG,EAAlB;;AAEA,YAAI9G,QAAQ,CAAC4I,SAAT,CAAmB,CAAnB,EAAsB,IAAtB,KAA+B,QAAnC,EAA6C;AAC3C;AACA,gBAAM,wEAAN;AACD;;AAED9B,QAAAA,SAAS,CAACZ,OAAV,GAAoBlG,QAAQ,CAACP,QAAT,CAAkB,CAAlB,CAApB;AACA,YAAMgM,IAAI,GAAGzL,QAAQ,CAACP,QAAT,CAAkB,CAAlB,CAAb,CAT6C,CASV;;AAEnCqH,QAAAA,SAAS,CAAC2E,IAAV,GAAiB;AACfC,UAAAA,UAAU,EAAE,CAAC,EAAED,IAAI,GAAG,CAAT,CADE;AAEfE,UAAAA,QAAQ,EAAE,CAAC,EAAEF,IAAI,GAAG,CAAT,CAFI;AAGfG,UAAAA,UAAU,EAAE,CAAC,EAAEH,IAAI,GAAG,CAAT,CAHE;AAIfI,UAAAA,SAAS,EAAE,CAAC,EAAEJ,IAAI,GAAG,EAAT;AAJG,SAAjB,CAX6C,CAgB1C;;AAEH3J,QAAAA,MAAM,CAACxI,KAAP,GAAe,CAAf,CAlB6C,CAkB3B;;AAElB,YAAIwS,WAAW,GAAG,IAAlB;;AAEA,eAAOA,WAAP,EAAoB;AAClB,cAAIC,aAAa,GAAG5E,yBAAyB,CAACtR,MAAD,EAASiM,MAAT,CAA7C;;AAEA,cAAIiK,aAAa,IAAI,CAArB,EAAwB;AACtBD,YAAAA,WAAW,GAAG,KAAd;AACD,WAFD,MAEO;AACL,gBAAIE,aAAa,GAAG7E,yBAAyB,CAACtR,MAAD,EAASiM,MAAT,CAA7C;AACA,gBAAImK,aAAa,GAAG/N,WAAW,CAAC8B,QAAD,EAAW8B,MAAX,CAA/B;AACA,gBAAIoK,cAAc,GAAGZ,UAAU,CAACtL,QAAD,EAAWnK,MAAX,EAAmBiM,MAAnB,EAA2BkK,aAA3B,EAA0CC,aAA1C,CAA/B;;AAEA,gBAAIC,cAAc,KAAKX,SAAvB,EAAkC;AAChCY,cAAAA,OAAO,CAACC,IAAR,mEAAyEJ,aAAzE;AACD,aAFD,MAEO;AACLlF,cAAAA,SAAS,CAACiF,aAAD,CAAT,GAA2BG,cAA3B;AACD;AACF;AACF;;AAED,YAAIT,IAAI,IAAI,CAAZ,EAAe;AACbU,UAAAA,OAAO,CAACE,KAAR,CAAc,YAAd,EAA4BvF,SAA5B;AACA,gBAAM,0DAAN;AACD;;AAED,eAAOA,SAAP;AACD;;AAED,eAASwF,YAAT,CAAsBxF,SAAtB,EAAiC9G,QAAjC,EAA2CvH,UAA3C,EAAuDqJ,MAAvD,EAA+DyK,UAA/D,EAA2E;AACzE,YAAMC,UAAU,GAAG;AACjBtN,UAAAA,IAAI,EAAE,CADW;AAEjBgF,UAAAA,MAAM,EAAElE,QAFS;AAGjB+D,UAAAA,KAAK,EAAEtL,UAHU;AAIjBqJ,UAAAA,MAAM,EAAEA,MAJS;AAKjB7B,UAAAA,KAAK,EAAE6G,SAAS,CAAC2F,UAAV,CAAqB3B,IAArB,GAA4BhE,SAAS,CAAC2F,UAAV,CAAqB7B,IAAjD,GAAwD,CAL9C;AAMjBzK,UAAAA,MAAM,EAAE2G,SAAS,CAAC2F,UAAV,CAAqB1B,IAArB,GAA4BjE,SAAS,CAAC2F,UAAV,CAAqB5B,IAAjD,GAAwD,CAN/C;AAOjBpG,UAAAA,QAAQ,EAAEqC,SAAS,CAACrC,QAAV,CAAmB/F,MAPZ;AAQjBgO,UAAAA,YAAY,EAAE,IARG;AASjB9H,UAAAA,KAAK,EAAE,IATU;AAUjB+H,UAAAA,SAAS,EAAE,IAVM;AAWjB/W,UAAAA,IAAI,EAAEkR,SAAS,CAACrC,QAAV,CAAmB,CAAnB,EAAsB8C,SAXX;AAYjBqF,UAAAA,UAAU,EAAE,IAZK;AAajBC,UAAAA,MAAM,EAAE,IAbS;AAcjBC,UAAAA,MAAM,EAAE,IAdS;AAejBC,UAAAA,QAAQ,EAAE;AAfO,SAAnB;;AAkBA,gBAAQjG,SAAS,CAACC,WAAlB;AACE,eAAK,gBAAL;AACEyF,YAAAA,UAAU,CAAC5H,KAAX,GAAmB,CAAnB;AACA4H,YAAAA,UAAU,CAACI,UAAX,GAAwB/I,aAAxB;AACA;;AAEF,eAAK,iBAAL;AACE2I,YAAAA,UAAU,CAAC5H,KAAX,GAAmB,CAAnB;AACA4H,YAAAA,UAAU,CAACI,UAAX,GAAwB5I,aAAxB;AACA;;AAEF,eAAK,kBAAL;AACEwI,YAAAA,UAAU,CAAC5H,KAAX,GAAmB,CAAnB;AACA4H,YAAAA,UAAU,CAACI,UAAX,GAAwBtI,aAAxB;AACA;;AAEF,eAAK,iBAAL;AACEkI,YAAAA,UAAU,CAAC5H,KAAX,GAAmB,EAAnB;AACA4H,YAAAA,UAAU,CAACI,UAAX,GAAwBtI,aAAxB;AACA;;AAEF,eAAK,iBAAL;AACEkI,YAAAA,UAAU,CAAC5H,KAAX,GAAmB,EAAnB;AACA4H,YAAAA,UAAU,CAACI,UAAX,GAAwBrI,aAAxB;AACA;;AAEF,eAAK,mBAAL;AACEiI,YAAAA,UAAU,CAAC5H,KAAX,GAAmB,EAAnB;AACA4H,YAAAA,UAAU,CAACI,UAAX,GAAwBpH,aAAxB;AACA;;AAEF,eAAK,kBAAL;AACEgH,YAAAA,UAAU,CAAC5H,KAAX,GAAmB,EAAnB;AACA4H,YAAAA,UAAU,CAACI,UAAX,GAAwB5G,aAAxB;AACA;;AAEF,eAAK,kBAAL;AACEwG,YAAAA,UAAU,CAAC5H,KAAX,GAAmB,GAAnB;AACA4H,YAAAA,UAAU,CAACI,UAAX,GAAwB5G,aAAxB;AACA;;AAEF;AACE,kBAAM,sBAAsBc,SAAS,CAACC,WAAhC,GAA8C,iBAApD;AA1CJ;;AA6CAyF,QAAAA,UAAU,CAAChI,iBAAX,GAA+BgI,UAAU,CAAC5H,KAA1C;;AAEA,YAAI4H,UAAU,CAAC5W,IAAX,IAAmB,CAAvB,EAA0B;AACxB;AACA,kBAAQ2W,UAAR;AACE,iBAAKpX,SAAL;AACEqX,cAAAA,UAAU,CAACK,MAAX,GAAoBlD,YAApB;AACA6C,cAAAA,UAAU,CAACG,SAAX,GAAuB7V,UAAvB;AACA;;AAEF,iBAAK5B,aAAL;AACEsX,cAAAA,UAAU,CAACK,MAAX,GAAoB/H,WAApB;AACA0H,cAAAA,UAAU,CAACG,SAAX,GAAuB7V,UAAvB;AACA;AATJ;AAWD,SAbD,MAaO,IAAI0V,UAAU,CAAC5W,IAAX,IAAmB,CAAvB,EAA0B;AAC/B;AACA,kBAAQ2W,UAAR;AACE,iBAAKpX,SAAL;AACEqX,cAAAA,UAAU,CAACK,MAAX,GAAoB3D,YAApB;AACAsD,cAAAA,UAAU,CAACG,SAAX,GAAuB/V,YAAvB;AACA;;AAEF,iBAAK1B,aAAL;AACEsX,cAAAA,UAAU,CAACK,MAAX,GAAoBzD,aAApB;AACAoD,cAAAA,UAAU,CAACG,SAAX,GAAuB/V,YAAvB;AARJ;AAUD,SAZM,MAYA;AACL,gBAAM,4CAA4C4V,UAAU,CAAC5W,IAAvD,GAA8D,OAA9D,GAAwEkR,SAAS,CAACC,WAAlF,GAAgG,GAAtG;AACD;;AAEDyF,QAAAA,UAAU,CAACQ,UAAX,GAAwB,CAAClG,SAAS,CAAC2F,UAAV,CAAqB1B,IAArB,GAA4B,CAA7B,IAAkCyB,UAAU,CAAChI,iBAArE;;AAEA,aAAK,IAAI5M,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4U,UAAU,CAACQ,UAA/B,EAA2CpV,CAAC,EAA5C;AAAgDuO,UAAAA,UAAU,CAACnG,QAAD,EAAW8B,MAAX,CAAV;AAAhD,SAjGyE,CAiGK;AAC9E;AACA;;;AAGA0K,QAAAA,UAAU,CAACS,cAAX,GAA4BT,UAAU,CAAC/H,QAAX,IAAuB,CAAvB,GAA2B,CAA3B,GAA+B+H,UAAU,CAAC/H,QAAtE;AACA,YAAMvF,IAAI,GAAGsN,UAAU,CAACvM,KAAX,GAAmBuM,UAAU,CAACrM,MAA9B,GAAuCqM,UAAU,CAACS,cAA/D;;AAEA,gBAAQV,UAAR;AACE,eAAKpX,SAAL;AACEqX,YAAAA,UAAU,CAACU,SAAX,GAAuB,IAAIhM,YAAJ,CAAiBhC,IAAjB,CAAvB,CADF,CACiD;;AAE/C,gBAAIsN,UAAU,CAAC/H,QAAX,GAAsB+H,UAAU,CAACS,cAArC,EAAqDT,UAAU,CAACU,SAAX,CAAqB1L,IAArB,CAA0B,CAA1B,EAA6B,CAA7B,EAAgCtC,IAAhC;AACrD;;AAEF,eAAKhK,aAAL;AACEsX,YAAAA,UAAU,CAACU,SAAX,GAAuB,IAAI/L,WAAJ,CAAgBjC,IAAhB,CAAvB;AACA,gBAAIsN,UAAU,CAAC/H,QAAX,GAAsB+H,UAAU,CAACS,cAArC,EAAqDT,UAAU,CAACU,SAAX,CAAqB1L,IAArB,CAA0B,MAA1B,EAAkC,CAAlC,EAAqCtC,IAArC,EAFvD,CAEmG;;AAEjG;;AAEF;AACEiN,YAAAA,OAAO,CAACE,KAAR,CAAc,qCAAd,EAAqDE,UAArD;AACA;AAfJ;;AAkBAC,QAAAA,UAAU,CAACE,YAAX,GAA0BF,UAAU,CAACvM,KAAX,GAAmBuM,UAAU,CAACG,SAA9B,GAA0CH,UAAU,CAAC/H,QAA/E;;AAEA,YAAI+H,UAAU,CAACS,cAAX,IAA6B,CAAjC,EAAoC;AAClCT,UAAAA,UAAU,CAACM,MAAX,GAAoB1X,UAApB;AACAoX,UAAAA,UAAU,CAACO,QAAX,GAAsB1X,cAAtB;AACD,SAHD,MAGO;AACLmX,UAAAA,UAAU,CAACM,MAAX,GAAoBxX,SAApB;AACAkX,UAAAA,UAAU,CAACO,QAAX,GAAsB1X,cAAtB;AACD;;AAED,eAAOmX,UAAP;AACD,OAtgDW,CAsgDV;;;AAGF,UAAMW,cAAc,GAAG,IAAI9N,QAAJ,CAAaxJ,MAAb,CAAvB;AACA,UAAM4C,UAAU,GAAG,IAAIgC,UAAJ,CAAe5E,MAAf,CAAnB;AACA,UAAMiM,MAAM,GAAG;AACbxI,QAAAA,KAAK,EAAE;AADM,OAAf,CA3gDY,CA6gDT;;AAEH,UAAMwN,SAAS,GAAG0E,WAAW,CAAC2B,cAAD,EAAiBtX,MAAjB,EAAyBiM,MAAzB,CAA7B,CA/gDY,CA+gDmD;;AAE/D,UAAM0K,UAAU,GAAGF,YAAY,CAACxF,SAAD,EAAYqG,cAAZ,EAA4B1U,UAA5B,EAAwCqJ,MAAxC,EAAgD,KAAKlM,IAArD,CAA/B;AACA,UAAMwP,SAAS,GAAG;AAChB9L,QAAAA,KAAK,EAAE;AADS,OAAlB;AAGA,UAAM8T,cAAc,GAAG;AACrBC,QAAAA,CAAC,EAAE,CADkB;AAErBC,QAAAA,CAAC,EAAE,CAFkB;AAGrBC,QAAAA,CAAC,EAAE,CAHkB;AAIrBC,QAAAA,CAAC,EAAE,CAJkB;AAKrBC,QAAAA,CAAC,EAAE;AALkB,OAAvB;;AAQA,WAAK,IAAIC,gBAAgB,GAAG,CAA5B,EAA+BA,gBAAgB,GAAGlB,UAAU,CAACrM,MAAX,GAAoBqM,UAAU,CAAChI,iBAAjF,EAAoGkJ,gBAAgB,EAApH,EAAwH;AACtH,YAAMC,IAAI,GAAGzP,WAAW,CAACiP,cAAD,EAAiBrL,MAAjB,CAAxB,CADsH,CACpE;;AAElD0K,QAAAA,UAAU,CAACtN,IAAX,GAAkBhB,WAAW,CAACiP,cAAD,EAAiBrL,MAAjB,CAA7B,CAHsH,CAG/D;;AAEvD0K,QAAAA,UAAU,CAAC5H,KAAX,GAAmB+I,IAAI,GAAGnB,UAAU,CAAChI,iBAAlB,GAAsCgI,UAAU,CAACrM,MAAjD,GAA0DqM,UAAU,CAACrM,MAAX,GAAoBwN,IAA9E,GAAqFnB,UAAU,CAAChI,iBAAnH;AACA,YAAMoJ,YAAY,GAAGpB,UAAU,CAACtN,IAAX,GAAkBsN,UAAU,CAAC5H,KAAX,GAAmB4H,UAAU,CAACE,YAArE;AACA,YAAMxI,MAAM,GAAG0J,YAAY,GAAGpB,UAAU,CAACI,UAAX,CAAsBJ,UAAtB,CAAH,GAAuC3I,aAAa,CAAC2I,UAAD,CAA/E;AACA1K,QAAAA,MAAM,CAACxI,KAAP,IAAgBkT,UAAU,CAACtN,IAA3B;;AAEA,aAAK,IAAI2O,MAAM,GAAG,CAAlB,EAAqBA,MAAM,GAAGrB,UAAU,CAAChI,iBAAzC,EAA4DqJ,MAAM,EAAlE,EAAsE;AACpE,cAAMC,MAAM,GAAGD,MAAM,GAAGH,gBAAgB,GAAGlB,UAAU,CAAChI,iBAAtD;AACA,cAAIsJ,MAAM,IAAItB,UAAU,CAACrM,MAAzB,EAAiC;;AAEjC,eAAK,IAAI4N,SAAS,GAAG,CAArB,EAAwBA,SAAS,GAAGvB,UAAU,CAAC/H,QAA/C,EAAyDsJ,SAAS,EAAlE,EAAsE;AACpE,gBAAMC,IAAI,GAAGZ,cAAc,CAACtG,SAAS,CAACrC,QAAV,CAAmBsJ,SAAnB,EAA8B7G,IAA/B,CAA3B;;AAEA,iBAAK,IAAIhF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsK,UAAU,CAACvM,KAA/B,EAAsCiC,CAAC,EAAvC,EAA2C;AACzCkD,cAAAA,SAAS,CAAC9L,KAAV,GAAkB,CAACuU,MAAM,IAAIrB,UAAU,CAAC/H,QAAX,GAAsB+H,UAAU,CAACvM,KAArC,CAAN,GAAoD8N,SAAS,GAAGvB,UAAU,CAACvM,KAA3E,GAAmFiC,CAApF,IAAyFsK,UAAU,CAACG,SAAtH;AACA,kBAAMsB,QAAQ,GAAG,CAACzB,UAAU,CAACrM,MAAX,GAAoB,CAApB,GAAwB2N,MAAzB,KAAoCtB,UAAU,CAACvM,KAAX,GAAmBuM,UAAU,CAACS,cAAlE,IAAoF/K,CAAC,GAAGsK,UAAU,CAACS,cAAnG,GAAoHe,IAArI;AACAxB,cAAAA,UAAU,CAACU,SAAX,CAAqBe,QAArB,IAAiCzB,UAAU,CAACK,MAAX,CAAkB3I,MAAlB,EAA0BkB,SAA1B,CAAjC;AACD;AACF;AACF;AACF;;AAED,aAAO;AACL8I,QAAAA,MAAM,EAAEpH,SADH;AAEL7G,QAAAA,KAAK,EAAEuM,UAAU,CAACvM,KAFb;AAGLE,QAAAA,MAAM,EAAEqM,UAAU,CAACrM,MAHd;AAIL9B,QAAAA,IAAI,EAAEmO,UAAU,CAACU,SAJZ;AAKLJ,QAAAA,MAAM,EAAEN,UAAU,CAACM,MALd;AAMLC,QAAAA,QAAQ,EAAEP,UAAU,CAACO,QANhB;AAOLnX,QAAAA,IAAI,EAAE,KAAKA;AAPN,OAAP;AASD;;;WAED,qBAAY0D,KAAZ,EAAmB;AACjB,WAAK1D,IAAL,GAAY0D,KAAZ;AACA,aAAO,IAAP;AACD;;;WAED,cAAK6U,GAAL,EAAUC,MAAV,EAAkBC,UAAlB,EAA8BC,OAA9B,EAAuC;AACrC,eAASC,cAAT,CAAwBC,OAAxB,EAAiCC,OAAjC,EAA0C;AACxCD,QAAAA,OAAO,CAACzB,QAAR,GAAmB0B,OAAO,CAAC1B,QAA3B;AACAyB,QAAAA,OAAO,CAACE,SAAR,GAAoBnZ,YAApB;AACAiZ,QAAAA,OAAO,CAACG,SAAR,GAAoBpZ,YAApB;AACAiZ,QAAAA,OAAO,CAACI,eAAR,GAA0B,KAA1B;AACAJ,QAAAA,OAAO,CAACK,KAAR,GAAgB,KAAhB;AACA,YAAIT,MAAJ,EAAYA,MAAM,CAACI,OAAD,EAAUC,OAAV,CAAN;AACb;;AAED,iFAAkBN,GAAlB,EAAuBI,cAAvB,EAAuCF,UAAvC,EAAmDC,OAAnD;AACD;;;;EAxlDqBrZ,iB;;AA4lDxB,SAASS,SAAT","sourcesContent":["import { DataTextureLoader, HalfFloatType, FloatType, RGBAFormat, LinearEncoding, RedFormat, LinearFilter, DataUtils } from 'three';\nimport { unzlibSync } from 'fflate';\n\n/**\n * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n// // End of OpenEXR license -------------------------------------------------\n\nclass EXRLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = HalfFloatType;\n  }\n\n  parse(buffer) {\n    const USHORT_RANGE = 1 << 16;\n    const BITMAP_SIZE = USHORT_RANGE >> 3;\n    const HUF_ENCBITS = 16; // literal (value) bit length\n\n    const HUF_DECBITS = 14; // decoding bit size (>= 8)\n\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1; // encoding table size\n\n    const HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size\n\n    const HUF_DECMASK = HUF_DECSIZE - 1;\n    const NBITS = 16;\n    const A_OFFSET = 1 << NBITS - 1;\n    const MOD_MASK = (1 << NBITS) - 1;\n    const SHORT_ZEROCODE_RUN = 59;\n    const LONG_ZEROCODE_RUN = 63;\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n    const ULONG_SIZE = 8;\n    const FLOAT32_SIZE = 4;\n    const INT32_SIZE = 4;\n    const INT16_SIZE = 2;\n    const INT8_SIZE = 1;\n    const STATIC_HUFFMAN = 0;\n    const DEFLATE = 1;\n    const UNKNOWN = 0;\n    const LOSSY_DCT = 1;\n    const RLE = 2;\n    const logBase = Math.pow(2.7182818, 2.2);\n\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0;\n\n      for (var i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n          lut[k++] = i;\n        }\n      }\n\n      var n = k - 1;\n\n      while (k < USHORT_RANGE) lut[k++] = 0;\n\n      return n;\n    }\n\n    function hufClearDecTable(hdec) {\n      for (var i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {};\n        hdec[i].len = 0;\n        hdec[i].lit = 0;\n        hdec[i].p = null;\n      }\n    }\n\n    const getBitsReturn = {\n      l: 0,\n      c: 0,\n      lc: 0\n    };\n\n    function getBits(nBits, c, lc, uInt8Array, inOffset) {\n      while (lc < nBits) {\n        c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n        lc += 8;\n      }\n\n      lc -= nBits;\n      getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n      getBitsReturn.c = c;\n      getBitsReturn.lc = lc;\n    }\n\n    const hufTableBuffer = new Array(59);\n\n    function hufCanonicalCodeTable(hcode) {\n      for (var i = 0; i <= 58; ++i) hufTableBuffer[i] = 0;\n\n      for (var i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1;\n\n      var c = 0;\n\n      for (var i = 58; i > 0; --i) {\n        var nc = c + hufTableBuffer[i] >> 1;\n        hufTableBuffer[i] = c;\n        c = nc;\n      }\n\n      for (var i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i];\n        if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n      }\n    }\n\n    function hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset;\n      var c = 0;\n      var lc = 0;\n\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni) return false;\n        getBits(6, c, lc, uInt8Array, p);\n        var l = getBitsReturn.l;\n        c = getBitsReturn.c;\n        lc = getBitsReturn.lc;\n        hcode[im] = l;\n\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw 'Something wrong with hufUnpackEncTable';\n          }\n\n          getBits(8, c, lc, uInt8Array, p);\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable';\n          }\n\n          while (zerun--) hcode[im++] = 0;\n\n          im--;\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable';\n          }\n\n          while (zerun--) hcode[im++] = 0;\n\n          im--;\n        }\n      }\n\n      hufCanonicalCodeTable(hcode);\n    }\n\n    function hufLength(code) {\n      return code & 63;\n    }\n\n    function hufCode(code) {\n      return code >> 6;\n    }\n\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im]);\n        var l = hufLength(hcode[im]);\n\n        if (c >> l) {\n          throw 'Invalid table entry';\n        }\n\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> l - HUF_DECBITS];\n\n          if (pl.len) {\n            throw 'Invalid table entry';\n          }\n\n          pl.lit++;\n\n          if (pl.p) {\n            var p = pl.p;\n            pl.p = new Array(pl.lit);\n\n            for (var i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i];\n            }\n          } else {\n            pl.p = new Array(1);\n          }\n\n          pl.p[pl.lit - 1] = im;\n        } else if (l) {\n          var plOffset = 0;\n\n          for (var i = 1 << HUF_DECBITS - l; i > 0; i--) {\n            var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n\n            if (pl.len || pl.p) {\n              throw 'Invalid table entry';\n            }\n\n            pl.len = l;\n            pl.lit = im;\n            plOffset++;\n          }\n        }\n      }\n\n      return true;\n    }\n\n    const getCharReturn = {\n      c: 0,\n      lc: 0\n    };\n\n    function getChar(c, lc, uInt8Array, inOffset) {\n      c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n      lc += 8;\n      getCharReturn.c = c;\n      getCharReturn.lc = lc;\n    }\n\n    const getCodeReturn = {\n      c: 0,\n      lc: 0\n    };\n\n    function getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n        }\n\n        lc -= 8;\n        var cs = c >> lc;\n        var cs = new Uint8Array([cs])[0];\n\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false;\n        }\n\n        var s = outBuffer[outBufferOffset.value - 1];\n\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s;\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po;\n      } else {\n        return false;\n      }\n\n      getCodeReturn.c = c;\n      getCodeReturn.lc = lc;\n    }\n\n    function UInt16(value) {\n      return value & 0xffff;\n    }\n\n    function Int16(value) {\n      var ref = UInt16(value);\n      return ref > 0x7fff ? ref - 0x10000 : ref;\n    }\n\n    const wdec14Return = {\n      a: 0,\n      b: 0\n    };\n\n    function wdec14(l, h) {\n      var ls = Int16(l);\n      var hs = Int16(h);\n      var hi = hs;\n      var ai = ls + (hi & 1) + (hi >> 1);\n      var as = ai;\n      var bs = ai - hi;\n      wdec14Return.a = as;\n      wdec14Return.b = bs;\n    }\n\n    function wdec16(l, h) {\n      var m = UInt16(l);\n      var d = UInt16(h);\n      var bb = m - (d >> 1) & MOD_MASK;\n      var aa = d + bb - A_OFFSET & MOD_MASK;\n      wdec14Return.a = aa;\n      wdec14Return.b = bb;\n    }\n\n    function wav2Decode(buffer, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14;\n      var n = nx > ny ? ny : nx;\n      var p = 1;\n      var p2;\n\n      while (p <= n) p <<= 1;\n\n      p >>= 1;\n      p2 = p;\n      p >>= 1;\n\n      while (p >= 1) {\n        var py = 0;\n        var ey = py + oy * (ny - p2);\n        var oy1 = oy * p;\n        var oy2 = oy * p2;\n        var ox1 = ox * p;\n        var ox2 = ox * p2;\n        var i00, i01, i10, i11;\n\n        for (; py <= ey; py += oy2) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            var p10 = px + oy1;\n            var p11 = p10 + ox1;\n\n            if (w14) {\n              wdec14(buffer[px + j], buffer[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec14(buffer[p01 + j], buffer[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec14(i00, i01);\n              buffer[px + j] = wdec14Return.a;\n              buffer[p01 + j] = wdec14Return.b;\n              wdec14(i10, i11);\n              buffer[p10 + j] = wdec14Return.a;\n              buffer[p11 + j] = wdec14Return.b;\n            } else {\n              wdec16(buffer[px + j], buffer[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec16(buffer[p01 + j], buffer[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec16(i00, i01);\n              buffer[px + j] = wdec14Return.a;\n              buffer[p01 + j] = wdec14Return.b;\n              wdec16(i10, i11);\n              buffer[p10 + j] = wdec14Return.a;\n              buffer[p11 + j] = wdec14Return.b;\n            }\n          }\n\n          if (nx & p) {\n            var p10 = px + oy1;\n            if (w14) wdec14(buffer[px + j], buffer[p10 + j]);else wdec16(buffer[px + j], buffer[p10 + j]);\n            i00 = wdec14Return.a;\n            buffer[p10 + j] = wdec14Return.b;\n            buffer[px + j] = i00;\n          }\n        }\n\n        if (ny & p) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            if (w14) wdec14(buffer[px + j], buffer[p01 + j]);else wdec16(buffer[px + j], buffer[p01 + j]);\n            i00 = wdec14Return.a;\n            buffer[p01 + j] = wdec14Return.b;\n            buffer[px + j] = i00;\n          }\n        }\n\n        p2 = p;\n        p >>= 1;\n      }\n\n      return py;\n    }\n\n    function hufDecode(encodingTable, decodingTable, uInt8Array, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n      var c = 0;\n      var lc = 0;\n      var outBufferEndOffset = no;\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array, inOffset);\n        c = getCharReturn.c;\n        lc = getCharReturn.lc;\n\n        while (lc >= HUF_DECBITS) {\n          var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n          var pl = decodingTable[index];\n\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            if (!pl.p) {\n              throw 'hufDecode issues';\n            }\n\n            var j;\n\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]]);\n\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n              }\n\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                  lc -= l;\n                  getCode(pl.p[j], rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                  c = getCodeReturn.c;\n                  lc = getCodeReturn.lc;\n                  break;\n                }\n              }\n            }\n\n            if (j == pl.lit) {\n              throw 'hufDecode issues';\n            }\n          }\n        }\n      }\n\n      var i = 8 - ni & 7;\n      c >>= i;\n      lc -= i;\n\n      while (lc > 0) {\n        var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n\n        if (pl.len) {\n          lc -= pl.len;\n          getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n          c = getCodeReturn.c;\n          lc = getCodeReturn.lc;\n        } else {\n          throw 'hufDecode issues';\n        }\n      }\n\n      return true;\n    }\n\n    function hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = {\n        value: 0\n      };\n      var initialInOffset = inOffset.value;\n      var im = parseUint32(inDataView, inOffset);\n      var iM = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      var nBits = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw 'Something wrong with HUF_ENCSIZE';\n      }\n\n      var freq = new Array(HUF_ENCSIZE);\n      var hdec = new Array(HUF_DECSIZE);\n      hufClearDecTable(hdec);\n      var ni = nCompressed - (inOffset.value - initialInOffset);\n      hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq);\n\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw 'Something wrong with hufUncompress';\n      }\n\n      hufBuildDecTable(freq, im, iM, hdec);\n      hufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n    }\n\n    function applyLut(lut, data, nData) {\n      for (var i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]];\n      }\n    }\n\n    function predictor(source) {\n      for (var t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128;\n        source[t] = d;\n      }\n    }\n\n    function interleaveScalar(source, out) {\n      var t1 = 0;\n      var t2 = Math.floor((source.length + 1) / 2);\n      var s = 0;\n      var stop = source.length - 1;\n\n      while (true) {\n        if (s > stop) break;\n        out[s++] = source[t1++];\n        if (s > stop) break;\n        out[s++] = source[t2++];\n      }\n    }\n\n    function decodeRunLength(source) {\n      var size = source.byteLength;\n      var out = new Array();\n      var p = 0;\n      var reader = new DataView(source);\n\n      while (size > 0) {\n        var l = reader.getInt8(p++);\n\n        if (l < 0) {\n          var count = -l;\n          size -= count + 1;\n\n          for (var i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++));\n          }\n        } else {\n          var count = l;\n          size -= 2;\n          var value = reader.getUint8(p++);\n\n          for (var i = 0; i < count + 1; i++) {\n            out.push(value);\n          }\n        }\n      }\n\n      return out;\n    }\n\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer);\n      var width = channelData[cscSet.idx[0]].width;\n      var height = channelData[cscSet.idx[0]].height;\n      var numComp = 3;\n      var numFullBlocksX = Math.floor(width / 8.0);\n      var numBlocksX = Math.ceil(width / 8.0);\n      var numBlocksY = Math.ceil(height / 8.0);\n      var leftoverX = width - (numBlocksX - 1) * 8;\n      var leftoverY = height - (numBlocksY - 1) * 8;\n      var currAcComp = {\n        value: 0\n      };\n      var currDcComp = new Array(numComp);\n      var dctData = new Array(numComp);\n      var halfZigBlock = new Array(numComp);\n      var rowBlock = new Array(numComp);\n      var rowOffsets = new Array(numComp);\n\n      for (let comp = 0; comp < numComp; ++comp) {\n        rowOffsets[comp] = rowPtrs[cscSet.idx[comp]];\n        currDcComp[comp] = comp < 1 ? 0 : currDcComp[comp - 1] + numBlocksX * numBlocksY;\n        dctData[comp] = new Float32Array(64);\n        halfZigBlock[comp] = new Uint16Array(64);\n        rowBlock[comp] = new Uint16Array(numBlocksX * 64);\n      }\n\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8;\n        if (blocky == numBlocksY - 1) maxY = leftoverY;\n        var maxX = 8;\n\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1) maxX = leftoverX;\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            halfZigBlock[comp].fill(0); // set block DC component\n\n            halfZigBlock[comp][0] = dcBuffer[currDcComp[comp]++]; // set block AC components\n\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp]); // UnZigZag block to float\n\n            unZigZag(halfZigBlock[comp], dctData[comp]); // decode float dct\n\n            dctInverse(dctData[comp]);\n          }\n\n          {\n            csc709Inverse(dctData);\n          }\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            convertToHalf(dctData[comp], rowBlock[comp], blockx * 64);\n          }\n        } // blockx\n\n\n        let offset = 0;\n\n        for (let comp = 0; comp < numComp; ++comp) {\n          const type = channelData[cscSet.idx[comp]].type;\n\n          for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n            offset = rowOffsets[comp][y];\n\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y & 0x7) * 8;\n              dataView.setUint16(offset + 0 * INT16_SIZE * type, rowBlock[comp][src + 0], true);\n              dataView.setUint16(offset + 1 * INT16_SIZE * type, rowBlock[comp][src + 1], true);\n              dataView.setUint16(offset + 2 * INT16_SIZE * type, rowBlock[comp][src + 2], true);\n              dataView.setUint16(offset + 3 * INT16_SIZE * type, rowBlock[comp][src + 3], true);\n              dataView.setUint16(offset + 4 * INT16_SIZE * type, rowBlock[comp][src + 4], true);\n              dataView.setUint16(offset + 5 * INT16_SIZE * type, rowBlock[comp][src + 5], true);\n              dataView.setUint16(offset + 6 * INT16_SIZE * type, rowBlock[comp][src + 6], true);\n              dataView.setUint16(offset + 7 * INT16_SIZE * type, rowBlock[comp][src + 7], true);\n              offset += 8 * INT16_SIZE * type;\n            }\n          } // handle partial X blocks\n\n\n          if (numFullBlocksX != numBlocksX) {\n            for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n              const offset = rowOffsets[comp][y] + 8 * numFullBlocksX * INT16_SIZE * type;\n              const src = numFullBlocksX * 64 + (y & 0x7) * 8;\n\n              for (let x = 0; x < maxX; ++x) {\n                dataView.setUint16(offset + x * INT16_SIZE * type, rowBlock[comp][src + x], true);\n              }\n            }\n          }\n        } // comp\n\n      } // blocky\n\n\n      var halfRow = new Uint16Array(width);\n      var dataView = new DataView(outBuffer.buffer); // convert channels back to float, if needed\n\n      for (var comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true;\n        var type = channelData[cscSet.idx[comp]].type;\n        if (channelData[comp].type != 2) continue;\n\n        for (var y = 0; y < height; ++y) {\n          const offset = rowOffsets[comp][y];\n\n          for (var x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset + x * INT16_SIZE * type, true);\n          }\n\n          for (var x = 0; x < width; ++x) {\n            dataView.setFloat32(offset + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n          }\n        }\n      }\n    }\n\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue;\n      var dctComp = 1;\n\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value];\n\n        if (acValue == 0xff00) {\n          dctComp = 64;\n        } else if (acValue >> 8 == 0xff) {\n          dctComp += acValue & 0xff;\n        } else {\n          halfZigBlock[dctComp] = acValue;\n          dctComp++;\n        }\n\n        currAcComp.value++;\n      }\n    }\n\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0]);\n      dst[1] = decodeFloat16(src[1]);\n      dst[2] = decodeFloat16(src[5]);\n      dst[3] = decodeFloat16(src[6]);\n      dst[4] = decodeFloat16(src[14]);\n      dst[5] = decodeFloat16(src[15]);\n      dst[6] = decodeFloat16(src[27]);\n      dst[7] = decodeFloat16(src[28]);\n      dst[8] = decodeFloat16(src[2]);\n      dst[9] = decodeFloat16(src[4]);\n      dst[10] = decodeFloat16(src[7]);\n      dst[11] = decodeFloat16(src[13]);\n      dst[12] = decodeFloat16(src[16]);\n      dst[13] = decodeFloat16(src[26]);\n      dst[14] = decodeFloat16(src[29]);\n      dst[15] = decodeFloat16(src[42]);\n      dst[16] = decodeFloat16(src[3]);\n      dst[17] = decodeFloat16(src[8]);\n      dst[18] = decodeFloat16(src[12]);\n      dst[19] = decodeFloat16(src[17]);\n      dst[20] = decodeFloat16(src[25]);\n      dst[21] = decodeFloat16(src[30]);\n      dst[22] = decodeFloat16(src[41]);\n      dst[23] = decodeFloat16(src[43]);\n      dst[24] = decodeFloat16(src[9]);\n      dst[25] = decodeFloat16(src[11]);\n      dst[26] = decodeFloat16(src[18]);\n      dst[27] = decodeFloat16(src[24]);\n      dst[28] = decodeFloat16(src[31]);\n      dst[29] = decodeFloat16(src[40]);\n      dst[30] = decodeFloat16(src[44]);\n      dst[31] = decodeFloat16(src[53]);\n      dst[32] = decodeFloat16(src[10]);\n      dst[33] = decodeFloat16(src[19]);\n      dst[34] = decodeFloat16(src[23]);\n      dst[35] = decodeFloat16(src[32]);\n      dst[36] = decodeFloat16(src[39]);\n      dst[37] = decodeFloat16(src[45]);\n      dst[38] = decodeFloat16(src[52]);\n      dst[39] = decodeFloat16(src[54]);\n      dst[40] = decodeFloat16(src[20]);\n      dst[41] = decodeFloat16(src[22]);\n      dst[42] = decodeFloat16(src[33]);\n      dst[43] = decodeFloat16(src[38]);\n      dst[44] = decodeFloat16(src[46]);\n      dst[45] = decodeFloat16(src[51]);\n      dst[46] = decodeFloat16(src[55]);\n      dst[47] = decodeFloat16(src[60]);\n      dst[48] = decodeFloat16(src[21]);\n      dst[49] = decodeFloat16(src[34]);\n      dst[50] = decodeFloat16(src[37]);\n      dst[51] = decodeFloat16(src[47]);\n      dst[52] = decodeFloat16(src[50]);\n      dst[53] = decodeFloat16(src[56]);\n      dst[54] = decodeFloat16(src[59]);\n      dst[55] = decodeFloat16(src[61]);\n      dst[56] = decodeFloat16(src[35]);\n      dst[57] = decodeFloat16(src[36]);\n      dst[58] = decodeFloat16(src[48]);\n      dst[59] = decodeFloat16(src[49]);\n      dst[60] = decodeFloat16(src[57]);\n      dst[61] = decodeFloat16(src[58]);\n      dst[62] = decodeFloat16(src[62]);\n      dst[63] = decodeFloat16(src[63]);\n    }\n\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4.0);\n      const b = 0.5 * Math.cos(3.14159 / 16.0);\n      const c = 0.5 * Math.cos(3.14159 / 8.0);\n      const d = 0.5 * Math.cos(3.0 * 3.14159 / 16.0);\n      const e = 0.5 * Math.cos(5.0 * 3.14159 / 16.0);\n      const f = 0.5 * Math.cos(3.0 * 3.14159 / 8.0);\n      const g = 0.5 * Math.cos(7.0 * 3.14159 / 16.0);\n      var alpha = new Array(4);\n      var beta = new Array(4);\n      var theta = new Array(4);\n      var gamma = new Array(4);\n\n      for (var row = 0; row < 8; ++row) {\n        var rowPtr = row * 8;\n        alpha[0] = c * data[rowPtr + 2];\n        alpha[1] = f * data[rowPtr + 2];\n        alpha[2] = c * data[rowPtr + 6];\n        alpha[3] = f * data[rowPtr + 6];\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[rowPtr + 0] = gamma[0] + beta[0];\n        data[rowPtr + 1] = gamma[1] + beta[1];\n        data[rowPtr + 2] = gamma[2] + beta[2];\n        data[rowPtr + 3] = gamma[3] + beta[3];\n        data[rowPtr + 4] = gamma[3] - beta[3];\n        data[rowPtr + 5] = gamma[2] - beta[2];\n        data[rowPtr + 6] = gamma[1] - beta[1];\n        data[rowPtr + 7] = gamma[0] - beta[0];\n      }\n\n      for (var column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column];\n        alpha[1] = f * data[16 + column];\n        alpha[2] = c * data[48 + column];\n        alpha[3] = f * data[48 + column];\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n        theta[0] = a * (data[column] + data[32 + column]);\n        theta[3] = a * (data[column] - data[32 + column]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[0 + column] = gamma[0] + beta[0];\n        data[8 + column] = gamma[1] + beta[1];\n        data[16 + column] = gamma[2] + beta[2];\n        data[24 + column] = gamma[3] + beta[3];\n        data[32 + column] = gamma[3] - beta[3];\n        data[40 + column] = gamma[2] - beta[2];\n        data[48 + column] = gamma[1] - beta[1];\n        data[56 + column] = gamma[0] - beta[0];\n      }\n    }\n\n    function csc709Inverse(data) {\n      for (var i = 0; i < 64; ++i) {\n        var y = data[0][i];\n        var cb = data[1][i];\n        var cr = data[2][i];\n        data[0][i] = y + 1.5747 * cr;\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n        data[2][i] = y + 1.8556 * cb;\n      }\n    }\n\n    function convertToHalf(src, dst, idx) {\n      for (var i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));\n      }\n    }\n\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1.0);\n      }\n    }\n\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size);\n    }\n\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer); // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed); // eslint-disable-line no-undef\n\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer); // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer;\n      var inOffset = {\n        value: info.offset.value\n      };\n      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n      var bitmap = new Uint8Array(BITMAP_SIZE); // Setup channel info\n\n      var outBufferEnd = 0;\n      var pizChannelData = new Array(info.channels);\n\n      for (var i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {};\n        pizChannelData[i]['start'] = outBufferEnd;\n        pizChannelData[i]['end'] = pizChannelData[i]['start'];\n        pizChannelData[i]['nx'] = info.width;\n        pizChannelData[i]['ny'] = info.lines;\n        pizChannelData[i]['size'] = info.type;\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n      } // Read range compression data\n\n\n      var minNonZero = parseUint16(inDataView, inOffset);\n      var maxNonZero = parseUint16(inDataView, inOffset);\n\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE';\n      }\n\n      if (minNonZero <= maxNonZero) {\n        for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n        }\n      } // Reverse LUT\n\n\n      var lut = new Uint16Array(USHORT_RANGE);\n      var maxValue = reverseLutFromBitmap(bitmap, lut);\n      var length = parseUint32(inDataView, inOffset); // Huffman decoding\n\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd); // Wavelet decoding\n\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i];\n\n        for (var j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n        }\n      } // Expand the pixel data to their original range\n\n\n      applyLut(lut, outBuffer, outBufferEnd); // Rearrange the pixel data into the format expected by the caller.\n\n      var tmpOffset = 0;\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c];\n          var n = cd.nx * cd.size;\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n          tmpBuffer.set(cp, tmpOffset);\n          tmpOffset += n * INT16_SIZE;\n          cd.end += n;\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed); // eslint-disable-line no-undef\n\n      const sz = info.lines * info.channels * info.width;\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n      let tmpBufferEnd = 0;\n      let writePtr = 0;\n      const ptr = new Array(4);\n\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0;\n\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              tmpBufferEnd = ptr[1] + info.width;\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n\n              break;\n\n            case 2:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              ptr[2] = ptr[1] + info.width;\n              tmpBufferEnd = ptr[2] + info.width;\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n\n              break;\n          }\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressDWA(info) {\n      var inDataView = info.viewer;\n      var inOffset = {\n        value: info.offset.value\n      };\n      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE)); // Read compression header information\n\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset)\n      };\n\n      if (dwaHeader.version < 2) {\n        throw 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported';\n      } // Read channel ruleset information\n\n\n      var channelRules = new Array();\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n        var value = parseUint8(inDataView, inOffset);\n        var compression = value >> 2 & 3;\n        var csc = (value >> 4) - 1;\n        var index = new Int8Array([csc])[0];\n        var type = parseUint8(inDataView, inOffset);\n        channelRules.push({\n          name: name,\n          index: index,\n          type: type,\n          compression: compression\n        });\n        ruleSize -= name.length + 3;\n      } // Classify channels\n\n\n      var channels = EXRHeader.channels;\n      var channelData = new Array(info.channels);\n\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = channelData[i] = {};\n        var channel = channels[i];\n        cd.name = channel.name;\n        cd.compression = UNKNOWN;\n        cd.decoded = false;\n        cd.type = channel.pixelType;\n        cd.pLinear = channel.pLinear;\n        cd.width = info.width;\n        cd.height = info.lines;\n      }\n\n      var cscSet = {\n        idx: new Array(3)\n      };\n\n      for (var offset = 0; offset < info.channels; ++offset) {\n        var cd = channelData[offset];\n\n        for (var i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i];\n\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression;\n\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset;\n            }\n\n            cd.offset = offset;\n          }\n        }\n      } // Read DCT - AC component data\n\n\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n            hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n            break;\n\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n            var data = unzlibSync(compressed); // eslint-disable-line no-undef\n\n            var acBuffer = new Uint16Array(data.buffer);\n            inOffset.value += dwaHeader.totalAcUncompressedCount;\n            break;\n        }\n      } // Read DCT - DC component data\n\n\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize\n        };\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n        inOffset.value += dwaHeader.dcCompressedSize;\n      } // Read RLE compressed data\n\n\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n        var data = unzlibSync(compressed); // eslint-disable-line no-undef\n\n        var rleBuffer = decodeRunLength(data.buffer);\n        inOffset.value += dwaHeader.rleCompressedSize;\n      } // Prepare outbuffer data offset\n\n\n      var outBufferEnd = 0;\n      var rowOffsets = new Array(channelData.length);\n\n      for (var i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array();\n      }\n\n      for (var y = 0; y < info.lines; ++y) {\n        for (var chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd);\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n        }\n      } // Lossy DCT decode RGB channels\n\n\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer); // Decode other channels\n\n      for (var i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i];\n        if (cd.decoded) continue;\n\n        switch (cd.compression) {\n          case RLE:\n            var row = 0;\n            var rleOffset = 0;\n\n            for (var y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row];\n\n              for (var x = 0; x < cd.width; ++x) {\n                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                }\n\n                rleOffset++;\n              }\n\n              row++;\n            }\n\n            break;\n\n          case LOSSY_DCT: // skip\n\n          default:\n            throw 'EXRLoader.parse: unsupported channel compression';\n        }\n      }\n\n      return new DataView(outBuffer.buffer);\n    }\n\n    function parseNullTerminatedString(buffer, offset) {\n      var uintBuffer = new Uint8Array(buffer);\n      var endOffset = 0;\n\n      while (uintBuffer[offset.value + endOffset] != 0) {\n        endOffset += 1;\n      }\n\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset));\n      offset.value = offset.value + endOffset + 1;\n      return stringValue;\n    }\n\n    function parseFixedLengthString(buffer, offset, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size));\n      offset.value = offset.value + size;\n      return stringValue;\n    }\n\n    function parseRational(dataView, offset) {\n      var x = parseInt32(dataView, offset);\n      var y = parseUint32(dataView, offset);\n      return [x, y];\n    }\n\n    function parseTimecode(dataView, offset) {\n      var x = parseUint32(dataView, offset);\n      var y = parseUint32(dataView, offset);\n      return [x, y];\n    }\n\n    function parseInt32(dataView, offset) {\n      var Int32 = dataView.getInt32(offset.value, true);\n      offset.value = offset.value + INT32_SIZE;\n      return Int32;\n    }\n\n    function parseUint32(dataView, offset) {\n      var Uint32 = dataView.getUint32(offset.value, true);\n      offset.value = offset.value + INT32_SIZE;\n      return Uint32;\n    }\n\n    function parseUint8Array(uInt8Array, offset) {\n      var Uint8 = uInt8Array[offset.value];\n      offset.value = offset.value + INT8_SIZE;\n      return Uint8;\n    }\n\n    function parseUint8(dataView, offset) {\n      var Uint8 = dataView.getUint8(offset.value);\n      offset.value = offset.value + INT8_SIZE;\n      return Uint8;\n    }\n\n    const parseInt64 = function (dataView, offset) {\n      let int;\n\n      if ('getBigInt64' in DataView.prototype) {\n        int = Number(dataView.getBigInt64(offset.value, true));\n      } else {\n        int = dataView.getUint32(offset.value + 4, true) + Number(dataView.getUint32(offset.value, true) << 32);\n      }\n\n      offset.value += ULONG_SIZE;\n      return int;\n    };\n\n    function parseFloat32(dataView, offset) {\n      var float = dataView.getFloat32(offset.value, true);\n      offset.value += FLOAT32_SIZE;\n      return float;\n    }\n\n    function decodeFloat32(dataView, offset) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset));\n    } // https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n\n\n    function decodeFloat16(binary) {\n      var exponent = (binary & 0x7c00) >> 10,\n          fraction = binary & 0x03ff;\n      return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 0x1f ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 0x400) : 6.103515625e-5 * (fraction / 0x400));\n    }\n\n    function parseUint16(dataView, offset) {\n      var Uint16 = dataView.getUint16(offset.value, true);\n      offset.value += INT16_SIZE;\n      return Uint16;\n    }\n\n    function parseFloat16(buffer, offset) {\n      return decodeFloat16(parseUint16(buffer, offset));\n    }\n\n    function parseChlist(dataView, buffer, offset, size) {\n      var startOffset = offset.value;\n      var channels = [];\n\n      while (offset.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer, offset);\n        var pixelType = parseInt32(dataView, offset);\n        var pLinear = parseUint8(dataView, offset);\n        offset.value += 3; // reserved, three chars\n\n        var xSampling = parseInt32(dataView, offset);\n        var ySampling = parseInt32(dataView, offset);\n        channels.push({\n          name: name,\n          pixelType: pixelType,\n          pLinear: pLinear,\n          xSampling: xSampling,\n          ySampling: ySampling\n        });\n      }\n\n      offset.value += 1;\n      return channels;\n    }\n\n    function parseChromaticities(dataView, offset) {\n      var redX = parseFloat32(dataView, offset);\n      var redY = parseFloat32(dataView, offset);\n      var greenX = parseFloat32(dataView, offset);\n      var greenY = parseFloat32(dataView, offset);\n      var blueX = parseFloat32(dataView, offset);\n      var blueY = parseFloat32(dataView, offset);\n      var whiteX = parseFloat32(dataView, offset);\n      var whiteY = parseFloat32(dataView, offset);\n      return {\n        redX: redX,\n        redY: redY,\n        greenX: greenX,\n        greenY: greenY,\n        blueX: blueX,\n        blueY: blueY,\n        whiteX: whiteX,\n        whiteY: whiteY\n      };\n    }\n\n    function parseCompression(dataView, offset) {\n      var compressionCodes = ['NO_COMPRESSION', 'RLE_COMPRESSION', 'ZIPS_COMPRESSION', 'ZIP_COMPRESSION', 'PIZ_COMPRESSION', 'PXR24_COMPRESSION', 'B44_COMPRESSION', 'B44A_COMPRESSION', 'DWAA_COMPRESSION', 'DWAB_COMPRESSION'];\n      var compression = parseUint8(dataView, offset);\n      return compressionCodes[compression];\n    }\n\n    function parseBox2i(dataView, offset) {\n      var xMin = parseUint32(dataView, offset);\n      var yMin = parseUint32(dataView, offset);\n      var xMax = parseUint32(dataView, offset);\n      var yMax = parseUint32(dataView, offset);\n      return {\n        xMin: xMin,\n        yMin: yMin,\n        xMax: xMax,\n        yMax: yMax\n      };\n    }\n\n    function parseLineOrder(dataView, offset) {\n      var lineOrders = ['INCREASING_Y'];\n      var lineOrder = parseUint8(dataView, offset);\n      return lineOrders[lineOrder];\n    }\n\n    function parseV2f(dataView, offset) {\n      var x = parseFloat32(dataView, offset);\n      var y = parseFloat32(dataView, offset);\n      return [x, y];\n    }\n\n    function parseV3f(dataView, offset) {\n      var x = parseFloat32(dataView, offset);\n      var y = parseFloat32(dataView, offset);\n      var z = parseFloat32(dataView, offset);\n      return [x, y, z];\n    }\n\n    function parseValue(dataView, buffer, offset, type, size) {\n      if (type === 'string' || type === 'stringvector' || type === 'iccProfile') {\n        return parseFixedLengthString(buffer, offset, size);\n      } else if (type === 'chlist') {\n        return parseChlist(dataView, buffer, offset, size);\n      } else if (type === 'chromaticities') {\n        return parseChromaticities(dataView, offset);\n      } else if (type === 'compression') {\n        return parseCompression(dataView, offset);\n      } else if (type === 'box2i') {\n        return parseBox2i(dataView, offset);\n      } else if (type === 'lineOrder') {\n        return parseLineOrder(dataView, offset);\n      } else if (type === 'float') {\n        return parseFloat32(dataView, offset);\n      } else if (type === 'v2f') {\n        return parseV2f(dataView, offset);\n      } else if (type === 'v3f') {\n        return parseV3f(dataView, offset);\n      } else if (type === 'int') {\n        return parseInt32(dataView, offset);\n      } else if (type === 'rational') {\n        return parseRational(dataView, offset);\n      } else if (type === 'timecode') {\n        return parseTimecode(dataView, offset);\n      } else if (type === 'preview') {\n        offset.value += size;\n        return 'skipped';\n      } else {\n        offset.value += size;\n        return undefined;\n      }\n    }\n\n    function parseHeader(dataView, buffer, offset) {\n      const EXRHeader = {};\n\n      if (dataView.getUint32(0, true) != 20000630) {\n        // magic\n        throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n      }\n\n      EXRHeader.version = dataView.getUint8(4);\n      const spec = dataView.getUint8(5); // fullMask\n\n      EXRHeader.spec = {\n        singleTile: !!(spec & 2),\n        longName: !!(spec & 4),\n        deepFormat: !!(spec & 8),\n        multiPart: !!(spec & 16)\n      }; // start of header\n\n      offset.value = 8; // start at 8 - after pre-amble\n\n      var keepReading = true;\n\n      while (keepReading) {\n        var attributeName = parseNullTerminatedString(buffer, offset);\n\n        if (attributeName == 0) {\n          keepReading = false;\n        } else {\n          var attributeType = parseNullTerminatedString(buffer, offset);\n          var attributeSize = parseUint32(dataView, offset);\n          var attributeValue = parseValue(dataView, buffer, offset, attributeType, attributeSize);\n\n          if (attributeValue === undefined) {\n            console.warn(`EXRLoader.parse: skipped unknown header attribute type \\'${attributeType}\\'.`);\n          } else {\n            EXRHeader[attributeName] = attributeValue;\n          }\n        }\n      }\n\n      if (spec != 0) {\n        console.error('EXRHeader:', EXRHeader);\n        throw 'THREE.EXRLoader: provided file is currently unsupported.';\n      }\n\n      return EXRHeader;\n    }\n\n    function setupDecoder(EXRHeader, dataView, uInt8Array, offset, outputType) {\n      const EXRDecoder = {\n        size: 0,\n        viewer: dataView,\n        array: uInt8Array,\n        offset: offset,\n        width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,\n        height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,\n        channels: EXRHeader.channels.length,\n        bytesPerLine: null,\n        lines: null,\n        inputSize: null,\n        type: EXRHeader.channels[0].pixelType,\n        uncompress: null,\n        getter: null,\n        format: null,\n        encoding: null\n      };\n\n      switch (EXRHeader.compression) {\n        case 'NO_COMPRESSION':\n          EXRDecoder.lines = 1;\n          EXRDecoder.uncompress = uncompressRAW;\n          break;\n\n        case 'RLE_COMPRESSION':\n          EXRDecoder.lines = 1;\n          EXRDecoder.uncompress = uncompressRLE;\n          break;\n\n        case 'ZIPS_COMPRESSION':\n          EXRDecoder.lines = 1;\n          EXRDecoder.uncompress = uncompressZIP;\n          break;\n\n        case 'ZIP_COMPRESSION':\n          EXRDecoder.lines = 16;\n          EXRDecoder.uncompress = uncompressZIP;\n          break;\n\n        case 'PIZ_COMPRESSION':\n          EXRDecoder.lines = 32;\n          EXRDecoder.uncompress = uncompressPIZ;\n          break;\n\n        case 'PXR24_COMPRESSION':\n          EXRDecoder.lines = 16;\n          EXRDecoder.uncompress = uncompressPXR;\n          break;\n\n        case 'DWAA_COMPRESSION':\n          EXRDecoder.lines = 32;\n          EXRDecoder.uncompress = uncompressDWA;\n          break;\n\n        case 'DWAB_COMPRESSION':\n          EXRDecoder.lines = 256;\n          EXRDecoder.uncompress = uncompressDWA;\n          break;\n\n        default:\n          throw 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported';\n      }\n\n      EXRDecoder.scanlineBlockSize = EXRDecoder.lines;\n\n      if (EXRDecoder.type == 1) {\n        // half\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat16;\n            EXRDecoder.inputSize = INT16_SIZE;\n            break;\n\n          case HalfFloatType:\n            EXRDecoder.getter = parseUint16;\n            EXRDecoder.inputSize = INT16_SIZE;\n            break;\n        }\n      } else if (EXRDecoder.type == 2) {\n        // float\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat32;\n            EXRDecoder.inputSize = FLOAT32_SIZE;\n            break;\n\n          case HalfFloatType:\n            EXRDecoder.getter = decodeFloat32;\n            EXRDecoder.inputSize = FLOAT32_SIZE;\n        }\n      } else {\n        throw 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.';\n      }\n\n      EXRDecoder.blockCount = (EXRHeader.dataWindow.yMax + 1) / EXRDecoder.scanlineBlockSize;\n\n      for (var i = 0; i < EXRDecoder.blockCount; i++) parseInt64(dataView, offset); // scanlineOffset\n      // we should be passed the scanline offset table, ready to start reading pixel data.\n      // RGB images will be converted to RGBA format, preventing software emulation in select devices.\n\n\n      EXRDecoder.outputChannels = EXRDecoder.channels == 3 ? 4 : EXRDecoder.channels;\n      const size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels;\n\n      switch (outputType) {\n        case FloatType:\n          EXRDecoder.byteArray = new Float32Array(size); // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(1, 0, size);\n          break;\n\n        case HalfFloatType:\n          EXRDecoder.byteArray = new Uint16Array(size);\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(0x3c00, 0, size); // Uint16Array holds half float data, 0x3C00 is 1\n\n          break;\n\n        default:\n          console.error('THREE.EXRLoader: unsupported type: ', outputType);\n          break;\n      }\n\n      EXRDecoder.bytesPerLine = EXRDecoder.width * EXRDecoder.inputSize * EXRDecoder.channels;\n\n      if (EXRDecoder.outputChannels == 4) {\n        EXRDecoder.format = RGBAFormat;\n        EXRDecoder.encoding = LinearEncoding;\n      } else {\n        EXRDecoder.format = RedFormat;\n        EXRDecoder.encoding = LinearEncoding;\n      }\n\n      return EXRDecoder;\n    } // start parsing file [START]\n\n\n    const bufferDataView = new DataView(buffer);\n    const uInt8Array = new Uint8Array(buffer);\n    const offset = {\n      value: 0\n    }; // get header information and validate format.\n\n    const EXRHeader = parseHeader(bufferDataView, buffer, offset); // get input compression information and prepare decoding.\n\n    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n    const tmpOffset = {\n      value: 0\n    };\n    const channelOffsets = {\n      R: 0,\n      G: 1,\n      B: 2,\n      A: 3,\n      Y: 0\n    };\n\n    for (let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++) {\n      const line = parseUint32(bufferDataView, offset); // line_no\n\n      EXRDecoder.size = parseUint32(bufferDataView, offset); // data_len\n\n      EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n      offset.value += EXRDecoder.size;\n\n      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n        if (true_y >= EXRDecoder.height) break;\n\n        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n          const cOff = channelOffsets[EXRHeader.channels[channelID].name];\n\n          for (let x = 0; x < EXRDecoder.width; x++) {\n            tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n            const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n          }\n        }\n      }\n    }\n\n    return {\n      header: EXRHeader,\n      width: EXRDecoder.width,\n      height: EXRDecoder.height,\n      data: EXRDecoder.byteArray,\n      format: EXRDecoder.format,\n      encoding: EXRDecoder.encoding,\n      type: this.type\n    };\n  }\n\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      texture.encoding = texData.encoding;\n      texture.minFilter = LinearFilter;\n      texture.magFilter = LinearFilter;\n      texture.generateMipmaps = false;\n      texture.flipY = false;\n      if (onLoad) onLoad(texture, texData);\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n\n}\n\nexport { EXRLoader };\n"]},"metadata":{},"sourceType":"module"}