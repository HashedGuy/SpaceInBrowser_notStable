{"ast":null,"code":"export var shaderStructs =\n/* glsl */\n\"\\n#ifndef TRI_INTERSECT_EPSILON\\n#define TRI_INTERSECT_EPSILON 1e-5\\n#endif\\n\\n#ifndef INFINITY\\n#define INFINITY 1e20\\n#endif\\n\\nstruct BVH {\\n\\n\\tusampler2D index;\\n\\tsampler2D position;\\n\\n\\tsampler2D bvhBounds;\\n\\tusampler2D bvhContents;\\n\\n};\\n\\n// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,\\n// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically\\n// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.\\n\";\nexport var shaderIntersectFunction =\n/* glsl */\n\"\\n\\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\\n\\n\\tuint width = uint( textureSize( tex, 0 ).x );\\n\\tuvec2 uv;\\n\\tuv.x = index % width;\\n\\tuv.y = index / width;\\n\\n\\treturn texelFetch( tex, ivec2( uv ), 0 );\\n\\n}\\n\\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\\n\\n\\tuint width = uint( textureSize( tex, 0 ).x );\\n\\tuvec2 uv;\\n\\tuv.x = index % width;\\n\\tuv.y = index / width;\\n\\n\\treturn texelFetch( tex, ivec2( uv ), 0 );\\n\\n}\\n\\nvec4 texelFetch1D( sampler2D tex, uint index ) {\\n\\n\\tuint width = uint( textureSize( tex, 0 ).x );\\n\\tuvec2 uv;\\n\\tuv.x = index % width;\\n\\tuv.y = index / width;\\n\\n\\treturn texelFetch( tex, ivec2( uv ), 0 );\\n\\n}\\n\\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\\n\\n\\treturn\\n\\t\\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\\n\\t\\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\\n\\t\\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\\n\\n}\\n\\nvoid ndcToCameraRay(\\n\\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\\n\\tout vec3 rayOrigin, out vec3 rayDirection\\n) {\\n\\n\\t// get camera look direction and near plane for camera clipping\\n\\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\\n\\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\\n\\tfloat near = abs( nearVector.z / nearVector.w );\\n\\n\\t// get the camera direction and position from camera matrices\\n\\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\\n\\tdirection /= direction.w;\\n\\tdirection = cameraWorld * direction - origin;\\n\\n\\t// slide the origin along the ray until it sits at the near clip plane position\\n\\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\\n\\n\\trayOrigin = origin.xyz;\\n\\trayDirection = direction.xyz;\\n\\n}\\n\\nfloat intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax ) {\\n\\n\\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\\n\\t// https://tavianator.com/2011/ray_box.html\\n\\tvec3 invDir = 1.0 / rayDirection;\\n\\n\\t// find intersection distances for each plane\\n\\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\\n\\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\\n\\n\\t// get the min and max distances from each intersection\\n\\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\\n\\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\\n\\n\\t// get the furthest hit distance\\n\\tvec2 t = max( tMinHit.xx, tMinHit.yz );\\n\\tfloat t0 = max( t.x, t.y );\\n\\n\\t// get the minimum hit distance\\n\\tt = min( tMaxHit.xx, tMaxHit.yz );\\n\\tfloat t1 = min( t.x, t.y );\\n\\n\\t// set distance to 0.0 if the ray starts inside the box\\n\\tfloat dist = max( t0, 0.0 );\\n\\n\\treturn t1 >= dist ? dist : INFINITY;\\n\\n}\\n\\nbool intersectsTriangle(\\n\\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\\n\\tout vec3 barycoord, out vec3 norm, out float dist, out float side\\n) {\\n\\n\\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\\n\\tvec3 edge1 = b - a;\\n\\tvec3 edge2 = c - a;\\n\\tnorm = cross( edge1, edge2 );\\n\\n\\tfloat det = - dot( rayDirection, norm );\\n\\tfloat invdet = 1.0 / det;\\n\\n\\tvec3 AO = rayOrigin - a;\\n\\tvec3 DAO = cross( AO, rayDirection );\\n\\n\\tvec4 uvt;\\n\\tuvt.x = dot( edge2, DAO ) * invdet;\\n\\tuvt.y = - dot( edge1, DAO ) * invdet;\\n\\tuvt.z = dot( AO, norm ) * invdet;\\n\\tuvt.w = 1.0 - uvt.x - uvt.y;\\n\\n\\t// set the hit information\\n\\tbarycoord = uvt.wxy; // arranged in A, B, C order\\n\\tdist = uvt.z;\\n\\tside = sign( det );\\n\\tnorm = side * normalize( norm );\\n\\n\\t// add an epsilon to avoid misses between triangles\\n\\tuvt += vec4( TRI_INTERSECT_EPSILON );\\n\\n\\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\\n\\n}\\n\\nbool intersectTriangles(\\n\\tBVH bvh, vec3 rayOrigin, vec3 rayDirection, uint offset, uint count,\\n\\tinout float minDistance,\\n\\n\\t// output variables\\n\\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\\n\\tout float side, out float dist\\n) {\\n\\n\\tbool found = false;\\n\\tvec3 localBarycoord, localNormal;\\n\\tfloat localDist, localSide;\\n\\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\\n\\n\\t\\tuvec3 indices = uTexelFetch1D( bvh.index, i ).xyz;\\n\\t\\tvec3 a = texelFetch1D( bvh.position, indices.x ).rgb;\\n\\t\\tvec3 b = texelFetch1D( bvh.position, indices.y ).rgb;\\n\\t\\tvec3 c = texelFetch1D( bvh.position, indices.z ).rgb;\\n\\n\\t\\tif (\\n\\t\\t\\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\\n\\t\\t\\t&& localDist < minDistance\\n\\t\\t) {\\n\\n\\t\\t\\tfound = true;\\n\\t\\t\\tminDistance = localDist;\\n\\n\\t\\t\\tfaceIndices = uvec4( indices.xyz, i );\\n\\t\\t\\tfaceNormal = localNormal;\\n\\n\\t\\t\\tside = localSide;\\n\\t\\t\\tbarycoord = localBarycoord;\\n\\t\\t\\tdist = localDist;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\treturn found;\\n\\n}\\n\\nfloat intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, BVH bvh, uint currNodeIndex ) {\\n\\n\\tvec3 boundsMin = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 0u ).xyz;\\n\\tvec3 boundsMax = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 1u ).xyz;\\n\\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax );\\n\\n}\\n\\nbool bvhIntersectFirstHit(\\n\\tBVH bvh, vec3 rayOrigin, vec3 rayDirection,\\n\\n\\t// output variables\\n\\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\\n\\tout float side, out float dist\\n) {\\n\\n\\t// stack needs to be twice as long as the deepest tree we expect because\\n\\t// we push both the left and right child onto the stack every traversal\\n\\tint ptr = 0;\\n\\tuint stack[ 60 ];\\n\\tstack[ 0 ] = 0u;\\n\\n\\tfloat triangleDistance = 1e20;\\n\\tbool found = false;\\n\\twhile ( ptr > - 1 && ptr < 60 ) {\\n\\n\\t\\tuint currNodeIndex = stack[ ptr ];\\n\\t\\tptr --;\\n\\n\\t\\t// check if we intersect the current bounds\\n\\t\\tfloat boundsHitDistance = intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh, currNodeIndex );\\n\\t\\tif ( boundsHitDistance == INFINITY || boundsHitDistance > triangleDistance ) {\\n\\n\\t\\t\\tcontinue;\\n\\n\\t\\t}\\n\\n\\t\\tuvec2 boundsInfo = uTexelFetch1D( bvh.bvhContents, currNodeIndex ).xy;\\n\\t\\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\\n\\n\\t\\tif ( isLeaf ) {\\n\\n\\t\\t\\tuint count = boundsInfo.x & 0x0000ffffu;\\n\\t\\t\\tuint offset = boundsInfo.y;\\n\\n\\t\\t\\tfound = intersectTriangles(\\n\\t\\t\\t\\tbvh, rayOrigin, rayDirection, offset, count, triangleDistance,\\n\\t\\t\\t\\tfaceIndices, faceNormal, barycoord, side, dist\\n\\t\\t\\t) || found;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tuint leftIndex = currNodeIndex + 1u;\\n\\t\\t\\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\\n\\t\\t\\tuint rightIndex = boundsInfo.y;\\n\\n\\t\\t\\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\\n\\t\\t\\tuint c1 = leftToRight ? leftIndex : rightIndex;\\n\\t\\t\\tuint c2 = leftToRight ? rightIndex : leftIndex;\\n\\n\\t\\t\\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\\n\\t\\t\\t// the stack while we traverse. The second pointer added is the one that will be\\n\\t\\t\\t// traversed first\\n\\t\\t\\tptr ++;\\n\\t\\t\\tstack[ ptr ] = c2;\\n\\n\\t\\t\\tptr ++;\\n\\t\\t\\tstack[ ptr ] = c1;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\treturn found;\\n\\n}\\n\\n\";","map":{"version":3,"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/three-mesh-bvh/src/gpu/shaderFunctions.js"],"names":["shaderStructs","shaderIntersectFunction"],"mappings":"AAAA,OAAO,IAAMA,aAAa;AAAG;AAAH,2jBAAnB;AAwBP,OAAO,IAAMC,uBAAuB;AAAG;AAAH,86NAA7B","sourcesContent":["export const shaderStructs = /* glsl */`\r\n#ifndef TRI_INTERSECT_EPSILON\r\n#define TRI_INTERSECT_EPSILON 1e-5\r\n#endif\r\n\r\n#ifndef INFINITY\r\n#define INFINITY 1e20\r\n#endif\r\n\r\nstruct BVH {\r\n\r\n\tusampler2D index;\r\n\tsampler2D position;\r\n\r\n\tsampler2D bvhBounds;\r\n\tusampler2D bvhContents;\r\n\r\n};\r\n\r\n// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,\r\n// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically\r\n// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.\r\n`;\r\n\r\nexport const shaderIntersectFunction = /* glsl */`\r\n\r\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\r\n\r\n\tuint width = uint( textureSize( tex, 0 ).x );\r\n\tuvec2 uv;\r\n\tuv.x = index % width;\r\n\tuv.y = index / width;\r\n\r\n\treturn texelFetch( tex, ivec2( uv ), 0 );\r\n\r\n}\r\n\r\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\r\n\r\n\tuint width = uint( textureSize( tex, 0 ).x );\r\n\tuvec2 uv;\r\n\tuv.x = index % width;\r\n\tuv.y = index / width;\r\n\r\n\treturn texelFetch( tex, ivec2( uv ), 0 );\r\n\r\n}\r\n\r\nvec4 texelFetch1D( sampler2D tex, uint index ) {\r\n\r\n\tuint width = uint( textureSize( tex, 0 ).x );\r\n\tuvec2 uv;\r\n\tuv.x = index % width;\r\n\tuv.y = index / width;\r\n\r\n\treturn texelFetch( tex, ivec2( uv ), 0 );\r\n\r\n}\r\n\r\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\r\n\r\n\treturn\r\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\r\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\r\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\r\n\r\n}\r\n\r\nvoid ndcToCameraRay(\r\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\r\n\tout vec3 rayOrigin, out vec3 rayDirection\r\n) {\r\n\r\n\t// get camera look direction and near plane for camera clipping\r\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\r\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\r\n\tfloat near = abs( nearVector.z / nearVector.w );\r\n\r\n\t// get the camera direction and position from camera matrices\r\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\r\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\r\n\tdirection /= direction.w;\r\n\tdirection = cameraWorld * direction - origin;\r\n\r\n\t// slide the origin along the ray until it sits at the near clip plane position\r\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\r\n\r\n\trayOrigin = origin.xyz;\r\n\trayDirection = direction.xyz;\r\n\r\n}\r\n\r\nfloat intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax ) {\r\n\r\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\r\n\t// https://tavianator.com/2011/ray_box.html\r\n\tvec3 invDir = 1.0 / rayDirection;\r\n\r\n\t// find intersection distances for each plane\r\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\r\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\r\n\r\n\t// get the min and max distances from each intersection\r\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\r\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\r\n\r\n\t// get the furthest hit distance\r\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\r\n\tfloat t0 = max( t.x, t.y );\r\n\r\n\t// get the minimum hit distance\r\n\tt = min( tMaxHit.xx, tMaxHit.yz );\r\n\tfloat t1 = min( t.x, t.y );\r\n\r\n\t// set distance to 0.0 if the ray starts inside the box\r\n\tfloat dist = max( t0, 0.0 );\r\n\r\n\treturn t1 >= dist ? dist : INFINITY;\r\n\r\n}\r\n\r\nbool intersectsTriangle(\r\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\r\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\r\n) {\r\n\r\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\r\n\tvec3 edge1 = b - a;\r\n\tvec3 edge2 = c - a;\r\n\tnorm = cross( edge1, edge2 );\r\n\r\n\tfloat det = - dot( rayDirection, norm );\r\n\tfloat invdet = 1.0 / det;\r\n\r\n\tvec3 AO = rayOrigin - a;\r\n\tvec3 DAO = cross( AO, rayDirection );\r\n\r\n\tvec4 uvt;\r\n\tuvt.x = dot( edge2, DAO ) * invdet;\r\n\tuvt.y = - dot( edge1, DAO ) * invdet;\r\n\tuvt.z = dot( AO, norm ) * invdet;\r\n\tuvt.w = 1.0 - uvt.x - uvt.y;\r\n\r\n\t// set the hit information\r\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\r\n\tdist = uvt.z;\r\n\tside = sign( det );\r\n\tnorm = side * normalize( norm );\r\n\r\n\t// add an epsilon to avoid misses between triangles\r\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\r\n\r\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\r\n\r\n}\r\n\r\nbool intersectTriangles(\r\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection, uint offset, uint count,\r\n\tinout float minDistance,\r\n\r\n\t// output variables\r\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\r\n\tout float side, out float dist\r\n) {\r\n\r\n\tbool found = false;\r\n\tvec3 localBarycoord, localNormal;\r\n\tfloat localDist, localSide;\r\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\r\n\r\n\t\tuvec3 indices = uTexelFetch1D( bvh.index, i ).xyz;\r\n\t\tvec3 a = texelFetch1D( bvh.position, indices.x ).rgb;\r\n\t\tvec3 b = texelFetch1D( bvh.position, indices.y ).rgb;\r\n\t\tvec3 c = texelFetch1D( bvh.position, indices.z ).rgb;\r\n\r\n\t\tif (\r\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\r\n\t\t\t&& localDist < minDistance\r\n\t\t) {\r\n\r\n\t\t\tfound = true;\r\n\t\t\tminDistance = localDist;\r\n\r\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\r\n\t\t\tfaceNormal = localNormal;\r\n\r\n\t\t\tside = localSide;\r\n\t\t\tbarycoord = localBarycoord;\r\n\t\t\tdist = localDist;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn found;\r\n\r\n}\r\n\r\nfloat intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, BVH bvh, uint currNodeIndex ) {\r\n\r\n\tvec3 boundsMin = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 0u ).xyz;\r\n\tvec3 boundsMax = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 1u ).xyz;\r\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax );\r\n\r\n}\r\n\r\nbool bvhIntersectFirstHit(\r\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection,\r\n\r\n\t// output variables\r\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\r\n\tout float side, out float dist\r\n) {\r\n\r\n\t// stack needs to be twice as long as the deepest tree we expect because\r\n\t// we push both the left and right child onto the stack every traversal\r\n\tint ptr = 0;\r\n\tuint stack[ 60 ];\r\n\tstack[ 0 ] = 0u;\r\n\r\n\tfloat triangleDistance = 1e20;\r\n\tbool found = false;\r\n\twhile ( ptr > - 1 && ptr < 60 ) {\r\n\r\n\t\tuint currNodeIndex = stack[ ptr ];\r\n\t\tptr --;\r\n\r\n\t\t// check if we intersect the current bounds\r\n\t\tfloat boundsHitDistance = intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh, currNodeIndex );\r\n\t\tif ( boundsHitDistance == INFINITY || boundsHitDistance > triangleDistance ) {\r\n\r\n\t\t\tcontinue;\r\n\r\n\t\t}\r\n\r\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh.bvhContents, currNodeIndex ).xy;\r\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\r\n\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\r\n\t\t\tuint offset = boundsInfo.y;\r\n\r\n\t\t\tfound = intersectTriangles(\r\n\t\t\t\tbvh, rayOrigin, rayDirection, offset, count, triangleDistance,\r\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\r\n\t\t\t) || found;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tuint leftIndex = currNodeIndex + 1u;\r\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\r\n\t\t\tuint rightIndex = boundsInfo.y;\r\n\r\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\r\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\r\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\r\n\r\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\r\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\r\n\t\t\t// traversed first\r\n\t\t\tptr ++;\r\n\t\t\tstack[ ptr ] = c2;\r\n\r\n\t\t\tptr ++;\r\n\t\t\tstack[ ptr ] = c1;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn found;\r\n\r\n}\r\n\r\n`;\r\n"]},"metadata":{},"sourceType":"module"}