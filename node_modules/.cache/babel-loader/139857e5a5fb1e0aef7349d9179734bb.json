{"ast":null,"code":"import _toConsumableArray from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { BufferAttribute } from 'three';\nimport { MeshBVHNode } from './MeshBVHNode.js';\nimport { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST, BYTES_PER_NODE, FLOAT32_EPSILON, IS_LEAFNODE_FLAG } from './Constants.js';\n\nfunction ensureIndex(geo, options) {\n  if (!geo.index) {\n    var vertexCount = geo.attributes.position.count;\n    var BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n    var index;\n\n    if (vertexCount > 65535) {\n      index = new Uint32Array(new BufferConstructor(4 * vertexCount));\n    } else {\n      index = new Uint16Array(new BufferConstructor(2 * vertexCount));\n    }\n\n    geo.setIndex(new BufferAttribute(index, 1));\n\n    for (var i = 0; i < vertexCount; i++) {\n      index[i] = i;\n    }\n  }\n} // Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\n\n\nfunction getRootIndexRanges(geo) {\n  if (!geo.groups || !geo.groups.length) {\n    return [{\n      offset: 0,\n      count: geo.index.count / 3\n    }];\n  }\n\n  var ranges = [];\n  var rangeBoundaries = new Set();\n\n  var _iterator = _createForOfIteratorHelper(geo.groups),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var group = _step.value;\n      rangeBoundaries.add(group.start);\n      rangeBoundaries.add(group.start + group.count);\n    } // note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var sortedBoundaries = Array.from(rangeBoundaries.values()).sort(function (a, b) {\n    return a - b;\n  });\n\n  for (var i = 0; i < sortedBoundaries.length - 1; i++) {\n    var start = sortedBoundaries[i],\n        end = sortedBoundaries[i + 1];\n    ranges.push({\n      offset: start / 3,\n      count: (end - start) / 3\n    });\n  }\n\n  return ranges;\n} // computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n// These are computed together to avoid redundant accesses to bounds array.\n\n\nfunction getBounds(triangleBounds, offset, count, target) {\n  var centroidTarget = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var minx = Infinity;\n  var miny = Infinity;\n  var minz = Infinity;\n  var maxx = -Infinity;\n  var maxy = -Infinity;\n  var maxz = -Infinity;\n  var cminx = Infinity;\n  var cminy = Infinity;\n  var cminz = Infinity;\n  var cmaxx = -Infinity;\n  var cmaxy = -Infinity;\n  var cmaxz = -Infinity;\n  var includeCentroid = centroidTarget !== null;\n\n  for (var i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {\n    var cx = triangleBounds[i + 0];\n    var hx = triangleBounds[i + 1];\n    var lx = cx - hx;\n    var rx = cx + hx;\n    if (lx < minx) minx = lx;\n    if (rx > maxx) maxx = rx;\n    if (includeCentroid && cx < cminx) cminx = cx;\n    if (includeCentroid && cx > cmaxx) cmaxx = cx;\n    var cy = triangleBounds[i + 2];\n    var hy = triangleBounds[i + 3];\n    var ly = cy - hy;\n    var ry = cy + hy;\n    if (ly < miny) miny = ly;\n    if (ry > maxy) maxy = ry;\n    if (includeCentroid && cy < cminy) cminy = cy;\n    if (includeCentroid && cy > cmaxy) cmaxy = cy;\n    var cz = triangleBounds[i + 4];\n    var hz = triangleBounds[i + 5];\n    var lz = cz - hz;\n    var rz = cz + hz;\n    if (lz < minz) minz = lz;\n    if (rz > maxz) maxz = rz;\n    if (includeCentroid && cz < cminz) cminz = cz;\n    if (includeCentroid && cz > cmaxz) cmaxz = cz;\n  }\n\n  target[0] = minx;\n  target[1] = miny;\n  target[2] = minz;\n  target[3] = maxx;\n  target[4] = maxy;\n  target[5] = maxz;\n\n  if (includeCentroid) {\n    centroidTarget[0] = cminx;\n    centroidTarget[1] = cminy;\n    centroidTarget[2] = cminz;\n    centroidTarget[3] = cmaxx;\n    centroidTarget[4] = cmaxy;\n    centroidTarget[5] = cmaxz;\n  }\n} // A stand alone function for retrieving the centroid bounds.\n\n\nfunction getCentroidBounds(triangleBounds, offset, count, centroidTarget) {\n  var cminx = Infinity;\n  var cminy = Infinity;\n  var cminz = Infinity;\n  var cmaxx = -Infinity;\n  var cmaxy = -Infinity;\n  var cmaxz = -Infinity;\n\n  for (var i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {\n    var cx = triangleBounds[i + 0];\n    if (cx < cminx) cminx = cx;\n    if (cx > cmaxx) cmaxx = cx;\n    var cy = triangleBounds[i + 2];\n    if (cy < cminy) cminy = cy;\n    if (cy > cmaxy) cmaxy = cy;\n    var cz = triangleBounds[i + 4];\n    if (cz < cminz) cminz = cz;\n    if (cz > cmaxz) cmaxz = cz;\n  }\n\n  centroidTarget[0] = cminx;\n  centroidTarget[1] = cminy;\n  centroidTarget[2] = cminz;\n  centroidTarget[3] = cmaxx;\n  centroidTarget[4] = cmaxy;\n  centroidTarget[5] = cmaxz;\n} // reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\n\n\nfunction partition(index, triangleBounds, offset, count, split) {\n  var left = offset;\n  var right = offset + count - 1;\n  var pos = split.pos;\n  var axisOffset = split.axis * 2; // hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\n  while (true) {\n    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {\n      left++;\n    } // if a triangle center lies on the partition plane it is considered to be on the right side\n\n\n    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {\n      right--;\n    }\n\n    if (left < right) {\n      // we need to swap all of the information associated with the triangles at index\n      // left and right; that's the verts in the geometry index, the bounds,\n      // and perhaps the SAH planes\n      for (var i = 0; i < 3; i++) {\n        var t0 = index[left * 3 + i];\n        index[left * 3 + i] = index[right * 3 + i];\n        index[right * 3 + i] = t0;\n        var t1 = triangleBounds[left * 6 + i * 2 + 0];\n        triangleBounds[left * 6 + i * 2 + 0] = triangleBounds[right * 6 + i * 2 + 0];\n        triangleBounds[right * 6 + i * 2 + 0] = t1;\n        var t2 = triangleBounds[left * 6 + i * 2 + 1];\n        triangleBounds[left * 6 + i * 2 + 1] = triangleBounds[right * 6 + i * 2 + 1];\n        triangleBounds[right * 6 + i * 2 + 1] = t2;\n      }\n\n      left++;\n      right--;\n    } else {\n      return left;\n    }\n  }\n}\n\nvar BIN_COUNT = 32;\n\nvar binsSort = function binsSort(a, b) {\n  return a.candidate - b.candidate;\n};\n\nvar sahBins = new Array(BIN_COUNT).fill().map(function () {\n  return {\n    count: 0,\n    bounds: new Float32Array(6),\n    rightCacheBounds: new Float32Array(6),\n    leftCacheBounds: new Float32Array(6),\n    candidate: 0\n  };\n});\nvar leftBounds = new Float32Array(6);\n\nfunction getOptimalSplit(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {\n  var axis = -1;\n  var pos = 0; // Center\n\n  if (strategy === CENTER) {\n    axis = getLongestEdgeIndex(centroidBoundingData);\n\n    if (axis !== -1) {\n      pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;\n    }\n  } else if (strategy === AVERAGE) {\n    axis = getLongestEdgeIndex(nodeBoundingData);\n\n    if (axis !== -1) {\n      pos = getAverage(triangleBounds, offset, count, axis);\n    }\n  } else if (strategy === SAH) {\n    var rootSurfaceArea = computeSurfaceArea(nodeBoundingData);\n    var bestCost = TRIANGLE_INTERSECT_COST * count; // iterate over all axes\n\n    var cStart = offset * 6;\n    var cEnd = (offset + count) * 6;\n\n    for (var a = 0; a < 3; a++) {\n      var axisLeft = centroidBoundingData[a];\n      var axisRight = centroidBoundingData[a + 3];\n      var axisLength = axisRight - axisLeft;\n      var binWidth = axisLength / BIN_COUNT; // If we have fewer triangles than we're planning to split then just check all\n      // the triangle positions because it will be faster.\n\n      if (count < BIN_COUNT / 4) {\n        // initialize the bin candidates\n        var truncatedBins = _toConsumableArray(sahBins);\n\n        truncatedBins.length = count; // set the candidates\n\n        var b = 0;\n\n        for (var c = cStart; c < cEnd; c += 6, b++) {\n          var bin = truncatedBins[b];\n          bin.candidate = triangleBounds[c + 2 * a];\n          bin.count = 0;\n          var bounds = bin.bounds,\n              leftCacheBounds = bin.leftCacheBounds,\n              rightCacheBounds = bin.rightCacheBounds;\n\n          for (var d = 0; d < 3; d++) {\n            rightCacheBounds[d] = Infinity;\n            rightCacheBounds[d + 3] = -Infinity;\n            leftCacheBounds[d] = Infinity;\n            leftCacheBounds[d + 3] = -Infinity;\n            bounds[d] = Infinity;\n            bounds[d + 3] = -Infinity;\n          }\n\n          expandByTriangleBounds(c, triangleBounds, bounds);\n        }\n\n        truncatedBins.sort(binsSort); // remove redundant splits\n\n        var splitCount = count;\n\n        for (var bi = 0; bi < splitCount; bi++) {\n          var _bin = truncatedBins[bi];\n\n          while (bi + 1 < splitCount && truncatedBins[bi + 1].candidate === _bin.candidate) {\n            truncatedBins.splice(bi + 1, 1);\n            splitCount--;\n          }\n        } // find the appropriate bin for each triangle and expand the bounds.\n\n\n        for (var _c = cStart; _c < cEnd; _c += 6) {\n          var center = triangleBounds[_c + 2 * a];\n\n          for (var _bi = 0; _bi < splitCount; _bi++) {\n            var _bin2 = truncatedBins[_bi];\n\n            if (center >= _bin2.candidate) {\n              expandByTriangleBounds(_c, triangleBounds, _bin2.rightCacheBounds);\n            } else {\n              expandByTriangleBounds(_c, triangleBounds, _bin2.leftCacheBounds);\n              _bin2.count++;\n            }\n          }\n        } // expand all the bounds\n\n\n        for (var _bi2 = 0; _bi2 < splitCount; _bi2++) {\n          var _bin3 = truncatedBins[_bi2];\n          var leftCount = _bin3.count;\n          var rightCount = count - _bin3.count; // check the cost of this split\n\n          var _leftBounds = _bin3.leftCacheBounds;\n          var rightBounds = _bin3.rightCacheBounds;\n          var leftProb = 0;\n\n          if (leftCount !== 0) {\n            leftProb = computeSurfaceArea(_leftBounds) / rootSurfaceArea;\n          }\n\n          var rightProb = 0;\n\n          if (rightCount !== 0) {\n            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;\n          }\n\n          var cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);\n\n          if (cost < bestCost) {\n            axis = a;\n            bestCost = cost;\n            pos = _bin3.candidate;\n          }\n        }\n      } else {\n        // reset the bins\n        for (var i = 0; i < BIN_COUNT; i++) {\n          var _bin4 = sahBins[i];\n          _bin4.count = 0;\n          _bin4.candidate = axisLeft + binWidth + i * binWidth;\n          var _bounds = _bin4.bounds;\n\n          for (var _d = 0; _d < 3; _d++) {\n            _bounds[_d] = Infinity;\n            _bounds[_d + 3] = -Infinity;\n          }\n        } // iterate over all center positions\n\n\n        for (var _c2 = cStart; _c2 < cEnd; _c2 += 6) {\n          var triCenter = triangleBounds[_c2 + 2 * a];\n          var relativeCenter = triCenter - axisLeft; // in the partition function if the centroid lies on the split plane then it is\n          // considered to be on the right side of the split\n\n          var binIndex = ~~(relativeCenter / binWidth);\n          if (binIndex >= BIN_COUNT) binIndex = BIN_COUNT - 1;\n          var _bin5 = sahBins[binIndex];\n          _bin5.count++;\n          expandByTriangleBounds(_c2, triangleBounds, _bin5.bounds);\n        } // cache the unioned bounds from right to left so we don't have to regenerate them each time\n\n\n        var lastBin = sahBins[BIN_COUNT - 1];\n        copyBounds(lastBin.bounds, lastBin.rightCacheBounds);\n\n        for (var _i = BIN_COUNT - 2; _i >= 0; _i--) {\n          var _bin6 = sahBins[_i];\n          var nextBin = sahBins[_i + 1];\n          unionBounds(_bin6.bounds, nextBin.rightCacheBounds, _bin6.rightCacheBounds);\n        }\n\n        var _leftCount = 0;\n\n        for (var _i2 = 0; _i2 < BIN_COUNT - 1; _i2++) {\n          var _bin7 = sahBins[_i2];\n          var binCount = _bin7.count;\n          var _bounds2 = _bin7.bounds;\n          var _nextBin = sahBins[_i2 + 1];\n          var _rightBounds = _nextBin.rightCacheBounds; // dont do anything with the bounds if the new bounds have no triangles\n\n          if (binCount !== 0) {\n            if (_leftCount === 0) {\n              copyBounds(_bounds2, leftBounds);\n            } else {\n              unionBounds(_bounds2, leftBounds, leftBounds);\n            }\n          }\n\n          _leftCount += binCount; // check the cost of this split\n\n          var _leftProb = 0;\n          var _rightProb = 0;\n\n          if (_leftCount !== 0) {\n            _leftProb = computeSurfaceArea(leftBounds) / rootSurfaceArea;\n          }\n\n          var _rightCount = count - _leftCount;\n\n          if (_rightCount !== 0) {\n            _rightProb = computeSurfaceArea(_rightBounds) / rootSurfaceArea;\n          }\n\n          var _cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (_leftProb * _leftCount + _rightProb * _rightCount);\n\n          if (_cost < bestCost) {\n            axis = a;\n            bestCost = _cost;\n            pos = _bin7.candidate;\n          }\n        }\n      }\n    }\n  } else {\n    console.warn(\"MeshBVH: Invalid build strategy value \".concat(strategy, \" used.\"));\n  }\n\n  return {\n    axis: axis,\n    pos: pos\n  };\n} // returns the average coordinate on the specified axis of the all the provided triangles\n\n\nfunction getAverage(triangleBounds, offset, count, axis) {\n  var avg = 0;\n\n  for (var i = offset, end = offset + count; i < end; i++) {\n    avg += triangleBounds[i * 6 + axis * 2];\n  }\n\n  return avg / count;\n} // precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\n\n\nfunction computeTriangleBounds(geo, fullBounds) {\n  var posAttr = geo.attributes.position;\n  var posArr = posAttr.array;\n  var index = geo.index.array;\n  var triCount = index.length / 3;\n  var triangleBounds = new Float32Array(triCount * 6); // support for an interleaved position buffer\n\n  var bufferOffset = posAttr.offset || 0;\n  var stride = 3;\n\n  if (posAttr.isInterleavedBufferAttribute) {\n    stride = posAttr.data.stride;\n  }\n\n  for (var tri = 0; tri < triCount; tri++) {\n    var tri3 = tri * 3;\n    var tri6 = tri * 6;\n    var ai = index[tri3 + 0] * stride + bufferOffset;\n    var bi = index[tri3 + 1] * stride + bufferOffset;\n    var ci = index[tri3 + 2] * stride + bufferOffset;\n\n    for (var el = 0; el < 3; el++) {\n      var a = posArr[ai + el];\n      var b = posArr[bi + el];\n      var c = posArr[ci + el];\n      var min = a;\n      if (b < min) min = b;\n      if (c < min) min = c;\n      var max = a;\n      if (b > max) max = b;\n      if (c > max) max = c; // Increase the bounds size by float32 epsilon to avoid precision errors when\n      // converting to 32 bit float. Scale the epsilon by the size of the numbers being\n      // worked with.\n\n      var halfExtents = (max - min) / 2;\n      var el2 = el * 2;\n      triangleBounds[tri6 + el2 + 0] = min + halfExtents;\n      triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * FLOAT32_EPSILON;\n      if (min < fullBounds[el]) fullBounds[el] = min;\n      if (max > fullBounds[el + 3]) fullBounds[el + 3] = max;\n    }\n  }\n\n  return triangleBounds;\n}\n\nexport function buildTree(geo, options) {\n  function triggerProgress(trianglesProcessed) {\n    if (onProgress) {\n      onProgress(trianglesProcessed / totalTriangles);\n    }\n  } // either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n  // recording the offset and count of its triangles and writing them into the reordered geometry index.\n\n\n  function splitNode(node, offset, count) {\n    var centroidBoundingData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var depth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n    if (!reachedMaxDepth && depth >= maxDepth) {\n      reachedMaxDepth = true;\n\n      if (verbose) {\n        console.warn(\"MeshBVH: Max depth of \".concat(maxDepth, \" reached when generating BVH. Consider increasing maxDepth.\"));\n        console.warn(geo);\n      }\n    } // early out if we've met our capacity\n\n\n    if (count <= maxLeafTris || depth >= maxDepth) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n      return node;\n    } // Find where to split the volume\n\n\n    var split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);\n\n    if (split.axis === -1) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n      return node;\n    }\n\n    var splitOffset = partition(indexArray, triangleBounds, offset, count, split); // create the two new child nodes\n\n    if (splitOffset === offset || splitOffset === offset + count) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n    } else {\n      node.splitAxis = split.axis; // create the left child and compute its bounding box\n\n      var left = new MeshBVHNode();\n      var lstart = offset;\n      var lcount = splitOffset - offset;\n      node.left = left;\n      left.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);\n      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1); // repeat for right\n\n      var right = new MeshBVHNode();\n      var rstart = splitOffset;\n      var rcount = count - lcount;\n      node.right = right;\n      right.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);\n      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);\n    }\n\n    return node;\n  }\n\n  ensureIndex(geo, options); // Compute the full bounds of the geometry at the same time as triangle bounds because\n  // we'll need it for the root bounds in the case with no groups and it should be fast here.\n  // We can't use the geometrying bounding box if it's available because it may be out of date.\n\n  var fullBounds = new Float32Array(6);\n  var cacheCentroidBoundingData = new Float32Array(6);\n  var triangleBounds = computeTriangleBounds(geo, fullBounds);\n  var indexArray = geo.index.array;\n  var maxDepth = options.maxDepth;\n  var verbose = options.verbose;\n  var maxLeafTris = options.maxLeafTris;\n  var strategy = options.strategy;\n  var onProgress = options.onProgress;\n  var totalTriangles = geo.index.count / 3;\n  var reachedMaxDepth = false;\n  var roots = [];\n  var ranges = getRootIndexRanges(geo);\n\n  if (ranges.length === 1) {\n    var range = ranges[0];\n    var root = new MeshBVHNode();\n    root.boundingData = fullBounds;\n    getCentroidBounds(triangleBounds, range.offset, range.count, cacheCentroidBoundingData);\n    splitNode(root, range.offset, range.count, cacheCentroidBoundingData);\n    roots.push(root);\n  } else {\n    var _iterator2 = _createForOfIteratorHelper(ranges),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _range = _step2.value;\n\n        var _root = new MeshBVHNode();\n\n        _root.boundingData = new Float32Array(6);\n        getBounds(triangleBounds, _range.offset, _range.count, _root.boundingData, cacheCentroidBoundingData);\n        splitNode(_root, _range.offset, _range.count, cacheCentroidBoundingData);\n        roots.push(_root);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  return roots;\n}\nexport function buildPackedTree(geo, options) {\n  // boundingData  \t\t\t\t: 6 float32\n  // right / offset \t\t\t\t: 1 uint32\n  // splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n  var roots = buildTree(geo, options);\n  var float32Array;\n  var uint32Array;\n  var uint16Array;\n  var packedRoots = [];\n  var BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\n  for (var i = 0; i < roots.length; i++) {\n    var root = roots[i];\n    var nodeCount = countNodes(root);\n    var buffer = new BufferConstructor(BYTES_PER_NODE * nodeCount);\n    float32Array = new Float32Array(buffer);\n    uint32Array = new Uint32Array(buffer);\n    uint16Array = new Uint16Array(buffer);\n    populateBuffer(0, root);\n    packedRoots.push(buffer);\n  }\n\n  return packedRoots;\n\n  function countNodes(node) {\n    if (node.count) {\n      return 1;\n    } else {\n      return 1 + countNodes(node.left) + countNodes(node.right);\n    }\n  }\n\n  function populateBuffer(byteOffset, node) {\n    var stride4Offset = byteOffset / 4;\n    var stride2Offset = byteOffset / 2;\n    var isLeaf = !!node.count;\n    var boundingData = node.boundingData;\n\n    for (var _i3 = 0; _i3 < 6; _i3++) {\n      float32Array[stride4Offset + _i3] = boundingData[_i3];\n    }\n\n    if (isLeaf) {\n      var offset = node.offset;\n      var count = node.count;\n      uint32Array[stride4Offset + 6] = offset;\n      uint16Array[stride2Offset + 14] = count;\n      uint16Array[stride2Offset + 15] = IS_LEAFNODE_FLAG;\n      return byteOffset + BYTES_PER_NODE;\n    } else {\n      var left = node.left;\n      var right = node.right;\n      var splitAxis = node.splitAxis;\n      var nextUnusedPointer;\n      nextUnusedPointer = populateBuffer(byteOffset + BYTES_PER_NODE, left);\n\n      if (nextUnusedPointer / 4 > Math.pow(2, 32)) {\n        throw new Error('MeshBVH: Cannot store child pointer greater than 32 bits.');\n      }\n\n      uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;\n      nextUnusedPointer = populateBuffer(nextUnusedPointer, right);\n      uint32Array[stride4Offset + 7] = splitAxis;\n      return nextUnusedPointer;\n    }\n  }\n}","map":{"version":3,"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/three-mesh-bvh/src/core/buildFunctions.js"],"names":["BufferAttribute","MeshBVHNode","getLongestEdgeIndex","computeSurfaceArea","copyBounds","unionBounds","expandByTriangleBounds","CENTER","AVERAGE","SAH","TRIANGLE_INTERSECT_COST","TRAVERSAL_COST","BYTES_PER_NODE","FLOAT32_EPSILON","IS_LEAFNODE_FLAG","ensureIndex","geo","options","index","vertexCount","attributes","position","count","BufferConstructor","useSharedArrayBuffer","SharedArrayBuffer","ArrayBuffer","Uint32Array","Uint16Array","setIndex","i","getRootIndexRanges","groups","length","offset","ranges","rangeBoundaries","Set","group","add","start","sortedBoundaries","Array","from","values","sort","a","b","end","push","getBounds","triangleBounds","target","centroidTarget","minx","Infinity","miny","minz","maxx","maxy","maxz","cminx","cminy","cminz","cmaxx","cmaxy","cmaxz","includeCentroid","cx","hx","lx","rx","cy","hy","ly","ry","cz","hz","lz","rz","getCentroidBounds","partition","split","left","right","pos","axisOffset","axis","t0","t1","t2","BIN_COUNT","binsSort","candidate","sahBins","fill","map","bounds","Float32Array","rightCacheBounds","leftCacheBounds","leftBounds","getOptimalSplit","nodeBoundingData","centroidBoundingData","strategy","getAverage","rootSurfaceArea","bestCost","cStart","cEnd","axisLeft","axisRight","axisLength","binWidth","truncatedBins","c","bin","d","splitCount","bi","splice","center","leftCount","rightCount","rightBounds","leftProb","rightProb","cost","triCenter","relativeCenter","binIndex","lastBin","nextBin","binCount","console","warn","avg","computeTriangleBounds","fullBounds","posAttr","posArr","array","triCount","bufferOffset","stride","isInterleavedBufferAttribute","data","tri","tri3","tri6","ai","ci","el","min","max","halfExtents","el2","Math","abs","buildTree","triggerProgress","trianglesProcessed","onProgress","totalTriangles","splitNode","node","depth","reachedMaxDepth","maxDepth","verbose","maxLeafTris","boundingData","splitOffset","indexArray","splitAxis","lstart","lcount","cacheCentroidBoundingData","rstart","rcount","roots","range","root","buildPackedTree","float32Array","uint32Array","uint16Array","packedRoots","nodeCount","countNodes","buffer","populateBuffer","byteOffset","stride4Offset","stride2Offset","isLeaf","nextUnusedPointer","pow","Error"],"mappings":"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","sourcesContent":["import { BufferAttribute } from 'three';\r\nimport { MeshBVHNode } from './MeshBVHNode.js';\r\nimport { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../utils/ArrayBoxUtilities.js';\r\nimport {\r\n\tCENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST,\r\n\tBYTES_PER_NODE, FLOAT32_EPSILON, IS_LEAFNODE_FLAG,\r\n} from './Constants.js';\r\n\r\nfunction ensureIndex( geo, options ) {\r\n\r\n\tif ( ! geo.index ) {\r\n\r\n\t\tconst vertexCount = geo.attributes.position.count;\r\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\r\n\t\tlet index;\r\n\t\tif ( vertexCount > 65535 ) {\r\n\r\n\t\t\tindex = new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tindex = new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\r\n\r\n\t\t}\r\n\r\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\r\n\r\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\r\n\r\n\t\t\tindex[ i ] = i;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\r\n// region in the geometry index that belongs to a different set of material groups requires\r\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\r\n// with triangle indices belongs to another group. For example, if the groups were like this:\r\n//\r\n// [-------------------------------------------------------------]\r\n// |__________________|\r\n//   g0 = [0, 20]  |______________________||_____________________|\r\n//                      g1 = [16, 40]           g2 = [41, 60]\r\n//\r\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\r\nfunction getRootIndexRanges( geo ) {\r\n\r\n\tif ( ! geo.groups || ! geo.groups.length ) {\r\n\r\n\t\treturn [ { offset: 0, count: geo.index.count / 3 } ];\r\n\r\n\t}\r\n\r\n\tconst ranges = [];\r\n\tconst rangeBoundaries = new Set();\r\n\tfor ( const group of geo.groups ) {\r\n\r\n\t\trangeBoundaries.add( group.start );\r\n\t\trangeBoundaries.add( group.start + group.count );\r\n\r\n\t}\r\n\r\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\r\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\r\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\r\n\r\n\t\tconst start = sortedBoundaries[ i ], end = sortedBoundaries[ i + 1 ];\r\n\t\tranges.push( { offset: ( start / 3 ), count: ( end - start ) / 3 } );\r\n\r\n\t}\r\n\r\n\treturn ranges;\r\n\r\n}\r\n\r\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\r\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\r\n// These are computed together to avoid redundant accesses to bounds array.\r\nfunction getBounds( triangleBounds, offset, count, target, centroidTarget = null ) {\r\n\r\n\tlet minx = Infinity;\r\n\tlet miny = Infinity;\r\n\tlet minz = Infinity;\r\n\tlet maxx = - Infinity;\r\n\tlet maxy = - Infinity;\r\n\tlet maxz = - Infinity;\r\n\r\n\tlet cminx = Infinity;\r\n\tlet cminy = Infinity;\r\n\tlet cminz = Infinity;\r\n\tlet cmaxx = - Infinity;\r\n\tlet cmaxy = - Infinity;\r\n\tlet cmaxz = - Infinity;\r\n\r\n\tconst includeCentroid = centroidTarget !== null;\r\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\r\n\r\n\t\tconst cx = triangleBounds[ i + 0 ];\r\n\t\tconst hx = triangleBounds[ i + 1 ];\r\n\t\tconst lx = cx - hx;\r\n\t\tconst rx = cx + hx;\r\n\t\tif ( lx < minx ) minx = lx;\r\n\t\tif ( rx > maxx ) maxx = rx;\r\n\t\tif ( includeCentroid && cx < cminx ) cminx = cx;\r\n\t\tif ( includeCentroid && cx > cmaxx ) cmaxx = cx;\r\n\r\n\t\tconst cy = triangleBounds[ i + 2 ];\r\n\t\tconst hy = triangleBounds[ i + 3 ];\r\n\t\tconst ly = cy - hy;\r\n\t\tconst ry = cy + hy;\r\n\t\tif ( ly < miny ) miny = ly;\r\n\t\tif ( ry > maxy ) maxy = ry;\r\n\t\tif ( includeCentroid && cy < cminy ) cminy = cy;\r\n\t\tif ( includeCentroid && cy > cmaxy ) cmaxy = cy;\r\n\r\n\t\tconst cz = triangleBounds[ i + 4 ];\r\n\t\tconst hz = triangleBounds[ i + 5 ];\r\n\t\tconst lz = cz - hz;\r\n\t\tconst rz = cz + hz;\r\n\t\tif ( lz < minz ) minz = lz;\r\n\t\tif ( rz > maxz ) maxz = rz;\r\n\t\tif ( includeCentroid && cz < cminz ) cminz = cz;\r\n\t\tif ( includeCentroid && cz > cmaxz ) cmaxz = cz;\r\n\r\n\t}\r\n\r\n\ttarget[ 0 ] = minx;\r\n\ttarget[ 1 ] = miny;\r\n\ttarget[ 2 ] = minz;\r\n\r\n\ttarget[ 3 ] = maxx;\r\n\ttarget[ 4 ] = maxy;\r\n\ttarget[ 5 ] = maxz;\r\n\r\n\tif ( includeCentroid ) {\r\n\r\n\t\tcentroidTarget[ 0 ] = cminx;\r\n\t\tcentroidTarget[ 1 ] = cminy;\r\n\t\tcentroidTarget[ 2 ] = cminz;\r\n\r\n\t\tcentroidTarget[ 3 ] = cmaxx;\r\n\t\tcentroidTarget[ 4 ] = cmaxy;\r\n\t\tcentroidTarget[ 5 ] = cmaxz;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// A stand alone function for retrieving the centroid bounds.\r\nfunction getCentroidBounds( triangleBounds, offset, count, centroidTarget ) {\r\n\r\n\tlet cminx = Infinity;\r\n\tlet cminy = Infinity;\r\n\tlet cminz = Infinity;\r\n\tlet cmaxx = - Infinity;\r\n\tlet cmaxy = - Infinity;\r\n\tlet cmaxz = - Infinity;\r\n\r\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\r\n\r\n\t\tconst cx = triangleBounds[ i + 0 ];\r\n\t\tif ( cx < cminx ) cminx = cx;\r\n\t\tif ( cx > cmaxx ) cmaxx = cx;\r\n\r\n\t\tconst cy = triangleBounds[ i + 2 ];\r\n\t\tif ( cy < cminy ) cminy = cy;\r\n\t\tif ( cy > cmaxy ) cmaxy = cy;\r\n\r\n\t\tconst cz = triangleBounds[ i + 4 ];\r\n\t\tif ( cz < cminz ) cminz = cz;\r\n\t\tif ( cz > cmaxz ) cmaxz = cz;\r\n\r\n\t}\r\n\r\n\tcentroidTarget[ 0 ] = cminx;\r\n\tcentroidTarget[ 1 ] = cminy;\r\n\tcentroidTarget[ 2 ] = cminz;\r\n\r\n\tcentroidTarget[ 3 ] = cmaxx;\r\n\tcentroidTarget[ 4 ] = cmaxy;\r\n\tcentroidTarget[ 5 ] = cmaxz;\r\n\r\n}\r\n\r\n\r\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\r\n// will be on the left and elements on the right side of the split will be on the right. returns the index\r\n// of the first element on the right side, or offset + count if there are no elements on the right side.\r\nfunction partition( index, triangleBounds, offset, count, split ) {\r\n\r\n\tlet left = offset;\r\n\tlet right = offset + count - 1;\r\n\tconst pos = split.pos;\r\n\tconst axisOffset = split.axis * 2;\r\n\r\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\r\n\twhile ( true ) {\r\n\r\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\r\n\r\n\t\t\tleft ++;\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\r\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\r\n\r\n\t\t\tright --;\r\n\r\n\t\t}\r\n\r\n\t\tif ( left < right ) {\r\n\r\n\t\t\t// we need to swap all of the information associated with the triangles at index\r\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\r\n\t\t\t// and perhaps the SAH planes\r\n\r\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\tlet t0 = index[ left * 3 + i ];\r\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\r\n\t\t\t\tindex[ right * 3 + i ] = t0;\r\n\r\n\t\t\t\tlet t1 = triangleBounds[ left * 6 + i * 2 + 0 ];\r\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 0 ] = triangleBounds[ right * 6 + i * 2 + 0 ];\r\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 0 ] = t1;\r\n\r\n\t\t\t\tlet t2 = triangleBounds[ left * 6 + i * 2 + 1 ];\r\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 1 ] = triangleBounds[ right * 6 + i * 2 + 1 ];\r\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 1 ] = t2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tleft ++;\r\n\t\t\tright --;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn left;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nconst BIN_COUNT = 32;\r\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\r\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\r\n\r\n\treturn {\r\n\r\n\t\tcount: 0,\r\n\t\tbounds: new Float32Array( 6 ),\r\n\t\trightCacheBounds: new Float32Array( 6 ),\r\n\t\tleftCacheBounds: new Float32Array( 6 ),\r\n\t\tcandidate: 0,\r\n\r\n\t};\r\n\r\n} );\r\nconst leftBounds = new Float32Array( 6 );\r\n\r\nfunction getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\r\n\r\n\tlet axis = - 1;\r\n\tlet pos = 0;\r\n\r\n\t// Center\r\n\tif ( strategy === CENTER ) {\r\n\r\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\r\n\t\tif ( axis !== - 1 ) {\r\n\r\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\r\n\r\n\t\t}\r\n\r\n\t} else if ( strategy === AVERAGE ) {\r\n\r\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\r\n\t\tif ( axis !== - 1 ) {\r\n\r\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\r\n\r\n\t\t}\r\n\r\n\t} else if ( strategy === SAH ) {\r\n\r\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\r\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\r\n\r\n\t\t// iterate over all axes\r\n\t\tconst cStart = offset * 6;\r\n\t\tconst cEnd = ( offset + count ) * 6;\r\n\t\tfor ( let a = 0; a < 3; a ++ ) {\r\n\r\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\r\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\r\n\t\t\tconst axisLength = axisRight - axisLeft;\r\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\r\n\r\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\r\n\t\t\t// the triangle positions because it will be faster.\r\n\t\t\tif ( count < BIN_COUNT / 4 ) {\r\n\r\n\t\t\t\t// initialize the bin candidates\r\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\r\n\t\t\t\ttruncatedBins.length = count;\r\n\r\n\t\t\t\t// set the candidates\r\n\t\t\t\tlet b = 0;\r\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\r\n\r\n\t\t\t\t\tconst bin = truncatedBins[ b ];\r\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\r\n\t\t\t\t\tbin.count = 0;\r\n\r\n\t\t\t\t\tconst {\r\n\t\t\t\t\t\tbounds,\r\n\t\t\t\t\t\tleftCacheBounds,\r\n\t\t\t\t\t\trightCacheBounds,\r\n\t\t\t\t\t} = bin;\r\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\r\n\r\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\r\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\r\n\r\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\r\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\r\n\r\n\t\t\t\t\t\tbounds[ d ] = Infinity;\r\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttruncatedBins.sort( binsSort );\r\n\r\n\t\t\t\t// remove redundant splits\r\n\t\t\t\tlet splitCount = count;\r\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\r\n\r\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\r\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\r\n\r\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\r\n\t\t\t\t\t\tsplitCount --;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\r\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\r\n\r\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\r\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\r\n\r\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\r\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\r\n\r\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\r\n\t\t\t\t\t\t\tbin.count ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// expand all the bounds\r\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\r\n\r\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\r\n\t\t\t\t\tconst leftCount = bin.count;\r\n\t\t\t\t\tconst rightCount = count - bin.count;\r\n\r\n\t\t\t\t\t// check the cost of this split\r\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\r\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\r\n\r\n\t\t\t\t\tlet leftProb = 0;\r\n\t\t\t\t\tif ( leftCount !== 0 ) {\r\n\r\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet rightProb = 0;\r\n\t\t\t\t\tif ( rightCount !== 0 ) {\r\n\r\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\r\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tif ( cost < bestCost ) {\r\n\r\n\t\t\t\t\t\taxis = a;\r\n\t\t\t\t\t\tbestCost = cost;\r\n\t\t\t\t\t\tpos = bin.candidate;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// reset the bins\r\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\r\n\r\n\t\t\t\t\tconst bin = sahBins[ i ];\r\n\t\t\t\t\tbin.count = 0;\r\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\r\n\r\n\t\t\t\t\tconst bounds = bin.bounds;\r\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\r\n\r\n\t\t\t\t\t\tbounds[ d ] = Infinity;\r\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// iterate over all center positions\r\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\r\n\r\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\r\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\r\n\r\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\r\n\t\t\t\t\t// considered to be on the right side of the split\r\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\r\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\r\n\r\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\r\n\t\t\t\t\tbin.count ++;\r\n\r\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\r\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\r\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\r\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\r\n\r\n\t\t\t\t\tconst bin = sahBins[ i ];\r\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\r\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet leftCount = 0;\r\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\r\n\r\n\t\t\t\t\tconst bin = sahBins[ i ];\r\n\t\t\t\t\tconst binCount = bin.count;\r\n\t\t\t\t\tconst bounds = bin.bounds;\r\n\r\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\r\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\r\n\r\n\t\t\t\t\t// dont do anything with the bounds if the new bounds have no triangles\r\n\t\t\t\t\tif ( binCount !== 0 ) {\r\n\r\n\t\t\t\t\t\tif ( leftCount === 0 ) {\r\n\r\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tleftCount += binCount;\r\n\r\n\t\t\t\t\t// check the cost of this split\r\n\t\t\t\t\tlet leftProb = 0;\r\n\t\t\t\t\tlet rightProb = 0;\r\n\r\n\t\t\t\t\tif ( leftCount !== 0 ) {\r\n\r\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst rightCount = count - leftCount;\r\n\t\t\t\t\tif ( rightCount !== 0 ) {\r\n\r\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\r\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tif ( cost < bestCost ) {\r\n\r\n\t\t\t\t\t\taxis = a;\r\n\t\t\t\t\t\tbestCost = cost;\r\n\t\t\t\t\t\tpos = bin.candidate;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\r\n\r\n\t}\r\n\r\n\treturn { axis, pos };\r\n\r\n}\r\n\r\n// returns the average coordinate on the specified axis of the all the provided triangles\r\nfunction getAverage( triangleBounds, offset, count, axis ) {\r\n\r\n\tlet avg = 0;\r\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\r\n\r\n\t}\r\n\r\n\treturn avg / count;\r\n\r\n}\r\n\r\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\r\n// result is an array of size tris.length * 6 where triangle i maps to a\r\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\r\n// representing the center and half-extent in each dimension of triangle i\r\nfunction computeTriangleBounds( geo, fullBounds ) {\r\n\r\n\tconst posAttr = geo.attributes.position;\r\n\tconst posArr = posAttr.array;\r\n\tconst index = geo.index.array;\r\n\tconst triCount = index.length / 3;\r\n\tconst triangleBounds = new Float32Array( triCount * 6 );\r\n\r\n\t// support for an interleaved position buffer\r\n\tconst bufferOffset = posAttr.offset || 0;\r\n\tlet stride = 3;\r\n\tif ( posAttr.isInterleavedBufferAttribute ) {\r\n\r\n\t\tstride = posAttr.data.stride;\r\n\r\n\t}\r\n\r\n\tfor ( let tri = 0; tri < triCount; tri ++ ) {\r\n\r\n\t\tconst tri3 = tri * 3;\r\n\t\tconst tri6 = tri * 6;\r\n\t\tconst ai = index[ tri3 + 0 ] * stride + bufferOffset;\r\n\t\tconst bi = index[ tri3 + 1 ] * stride + bufferOffset;\r\n\t\tconst ci = index[ tri3 + 2 ] * stride + bufferOffset;\r\n\r\n\t\tfor ( let el = 0; el < 3; el ++ ) {\r\n\r\n\t\t\tconst a = posArr[ ai + el ];\r\n\t\t\tconst b = posArr[ bi + el ];\r\n\t\t\tconst c = posArr[ ci + el ];\r\n\r\n\t\t\tlet min = a;\r\n\t\t\tif ( b < min ) min = b;\r\n\t\t\tif ( c < min ) min = c;\r\n\r\n\t\t\tlet max = a;\r\n\t\t\tif ( b > max ) max = b;\r\n\t\t\tif ( c > max ) max = c;\r\n\r\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\r\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\r\n\t\t\t// worked with.\r\n\t\t\tconst halfExtents = ( max - min ) / 2;\r\n\t\t\tconst el2 = el * 2;\r\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\r\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\r\n\r\n\t\t\tif ( min < fullBounds[ el ] ) fullBounds[ el ] = min;\r\n\t\t\tif ( max > fullBounds[ el + 3 ] ) fullBounds[ el + 3 ] = max;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn triangleBounds;\r\n\r\n}\r\n\r\nexport function buildTree( geo, options ) {\r\n\r\n\tfunction triggerProgress( trianglesProcessed ) {\r\n\r\n\t\tif ( onProgress ) {\r\n\r\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\r\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\r\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\r\n\r\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\r\n\r\n\t\t\treachedMaxDepth = true;\r\n\t\t\tif ( verbose ) {\r\n\r\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\r\n\t\t\t\tconsole.warn( geo );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// early out if we've met our capacity\r\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\r\n\r\n\t\t\ttriggerProgress( offset + count );\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\t\t\treturn node;\r\n\r\n\t\t}\r\n\r\n\t\t// Find where to split the volume\r\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\r\n\t\tif ( split.axis === - 1 ) {\r\n\r\n\t\t\ttriggerProgress( offset + count );\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\t\t\treturn node;\r\n\r\n\t\t}\r\n\r\n\t\tconst splitOffset = partition( indexArray, triangleBounds, offset, count, split );\r\n\r\n\t\t// create the two new child nodes\r\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\r\n\r\n\t\t\ttriggerProgress( offset + count );\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tnode.splitAxis = split.axis;\r\n\r\n\t\t\t// create the left child and compute its bounding box\r\n\t\t\tconst left = new MeshBVHNode();\r\n\t\t\tconst lstart = offset;\r\n\t\t\tconst lcount = splitOffset - offset;\r\n\t\t\tnode.left = left;\r\n\t\t\tleft.boundingData = new Float32Array( 6 );\r\n\r\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\r\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\r\n\r\n\t\t\t// repeat for right\r\n\t\t\tconst right = new MeshBVHNode();\r\n\t\t\tconst rstart = splitOffset;\r\n\t\t\tconst rcount = count - lcount;\r\n\t\t\tnode.right = right;\r\n\t\t\tright.boundingData = new Float32Array( 6 );\r\n\r\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\r\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\r\n\r\n\t\t}\r\n\r\n\t\treturn node;\r\n\r\n\t}\r\n\r\n\tensureIndex( geo, options );\r\n\r\n\t// Compute the full bounds of the geometry at the same time as triangle bounds because\r\n\t// we'll need it for the root bounds in the case with no groups and it should be fast here.\r\n\t// We can't use the geometrying bounding box if it's available because it may be out of date.\r\n\tconst fullBounds = new Float32Array( 6 );\r\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\r\n\tconst triangleBounds = computeTriangleBounds( geo, fullBounds );\r\n\tconst indexArray = geo.index.array;\r\n\tconst maxDepth = options.maxDepth;\r\n\tconst verbose = options.verbose;\r\n\tconst maxLeafTris = options.maxLeafTris;\r\n\tconst strategy = options.strategy;\r\n\tconst onProgress = options.onProgress;\r\n\tconst totalTriangles = geo.index.count / 3;\r\n\tlet reachedMaxDepth = false;\r\n\r\n\tconst roots = [];\r\n\tconst ranges = getRootIndexRanges( geo );\r\n\r\n\tif ( ranges.length === 1 ) {\r\n\r\n\t\tconst range = ranges[ 0 ];\r\n\t\tconst root = new MeshBVHNode();\r\n\t\troot.boundingData = fullBounds;\r\n\t\tgetCentroidBounds( triangleBounds, range.offset, range.count, cacheCentroidBoundingData );\r\n\r\n\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\r\n\t\troots.push( root );\r\n\r\n\t} else {\r\n\r\n\t\tfor ( let range of ranges ) {\r\n\r\n\t\t\tconst root = new MeshBVHNode();\r\n\t\t\troot.boundingData = new Float32Array( 6 );\r\n\t\t\tgetBounds( triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData );\r\n\r\n\t\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\r\n\t\t\troots.push( root );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn roots;\r\n\r\n}\r\n\r\nexport function buildPackedTree( geo, options ) {\r\n\r\n\t// boundingData  \t\t\t\t: 6 float32\r\n\t// right / offset \t\t\t\t: 1 uint32\r\n\t// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\r\n\tconst roots = buildTree( geo, options );\r\n\r\n\tlet float32Array;\r\n\tlet uint32Array;\r\n\tlet uint16Array;\r\n\tconst packedRoots = [];\r\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\r\n\tfor ( let i = 0; i < roots.length; i ++ ) {\r\n\r\n\t\tconst root = roots[ i ];\r\n\t\tlet nodeCount = countNodes( root );\r\n\r\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\r\n\t\tfloat32Array = new Float32Array( buffer );\r\n\t\tuint32Array = new Uint32Array( buffer );\r\n\t\tuint16Array = new Uint16Array( buffer );\r\n\t\tpopulateBuffer( 0, root );\r\n\t\tpackedRoots.push( buffer );\r\n\r\n\t}\r\n\r\n\treturn packedRoots;\r\n\r\n\tfunction countNodes( node ) {\r\n\r\n\t\tif ( node.count ) {\r\n\r\n\t\t\treturn 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction populateBuffer( byteOffset, node ) {\r\n\r\n\t\tconst stride4Offset = byteOffset / 4;\r\n\t\tconst stride2Offset = byteOffset / 2;\r\n\t\tconst isLeaf = ! ! node.count;\r\n\t\tconst boundingData = node.boundingData;\r\n\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tconst offset = node.offset;\r\n\t\t\tconst count = node.count;\r\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\r\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\r\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\r\n\t\t\treturn byteOffset + BYTES_PER_NODE;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst left = node.left;\r\n\t\t\tconst right = node.right;\r\n\t\t\tconst splitAxis = node.splitAxis;\r\n\r\n\t\t\tlet nextUnusedPointer;\r\n\t\t\tnextUnusedPointer = populateBuffer( byteOffset + BYTES_PER_NODE, left );\r\n\r\n\t\t\tif ( ( nextUnusedPointer / 4 ) > Math.pow( 2, 32 ) ) {\r\n\r\n\t\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\r\n\t\t\tnextUnusedPointer = populateBuffer( nextUnusedPointer, right );\r\n\r\n\t\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\r\n\t\t\treturn nextUnusedPointer;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}