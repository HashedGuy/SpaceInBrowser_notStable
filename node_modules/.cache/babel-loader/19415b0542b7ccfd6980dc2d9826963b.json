{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.firstForTerminal = exports.firstForBranching = exports.firstForSequence = exports.first = void 0;\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar gast_public_1 = require(\"./gast/gast_public\");\n\nvar gast_1 = require(\"./gast/gast\");\n\nfunction first(prod) {\n  /* istanbul ignore else */\n  if (prod instanceof gast_public_1.NonTerminal) {\n    // this could in theory cause infinite loops if\n    // (1) prod A refs prod B.\n    // (2) prod B refs prod A\n    // (3) AB can match the empty set\n    // in other words a cycle where everything is optional so the first will keep\n    // looking ahead for the next optional part and will never exit\n    // currently there is no safeguard for this unique edge case because\n    // (1) not sure a grammar in which this can happen is useful for anything (productive)\n    return first(prod.referencedRule);\n  } else if (prod instanceof gast_public_1.Terminal) {\n    return firstForTerminal(prod);\n  } else if ((0, gast_1.isSequenceProd)(prod)) {\n    return firstForSequence(prod);\n  } else if ((0, gast_1.isBranchingProd)(prod)) {\n    return firstForBranching(prod);\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nexports.first = first;\n\nfunction firstForSequence(prod) {\n  var firstSet = [];\n  var seq = prod.definition;\n  var nextSubProdIdx = 0;\n  var hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  var currSubProd; // so we enter the loop at least once (if the definition is not empty\n\n  var isLastInnerProdOptional = true; // scan a sequence until it's end or until we have found a NONE optional production in it\n\n  while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n    currSubProd = seq[nextSubProdIdx];\n    isLastInnerProdOptional = (0, gast_1.isOptionalProd)(currSubProd);\n    firstSet = firstSet.concat(first(currSubProd));\n    nextSubProdIdx = nextSubProdIdx + 1;\n    hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  }\n\n  return (0, utils_1.uniq)(firstSet);\n}\n\nexports.firstForSequence = firstForSequence;\n\nfunction firstForBranching(prod) {\n  var allAlternativesFirsts = (0, utils_1.map)(prod.definition, function (innerProd) {\n    return first(innerProd);\n  });\n  return (0, utils_1.uniq)((0, utils_1.flatten)(allAlternativesFirsts));\n}\n\nexports.firstForBranching = firstForBranching;\n\nfunction firstForTerminal(terminal) {\n  return [terminal.terminalType];\n}\n\nexports.firstForTerminal = firstForTerminal;","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;;AACA;;AAGA,SAAgBA,KAAhB,CAAsBC,IAAtB,EAAuC;AACrC;AACA,MAAIA,IAAI,YAAYC,yBAApB,EAAiC;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAOF,KAAK,CAAeC,IAAK,CAACE,cAArB,CAAZ;AACD,GAVD,MAUO,IAAIF,IAAI,YAAYC,sBAApB,EAA8B;AACnC,WAAOE,gBAAgB,CAAWH,IAAX,CAAvB;AACD,GAFM,MAEA,IAAI,2BAAeA,IAAf,CAAJ,EAA0B;AAC/B,WAAOI,gBAAgB,CAAqBJ,IAArB,CAAvB;AACD,GAFM,MAEA,IAAI,4BAAgBA,IAAhB,CAAJ,EAA2B;AAChC,WAAOK,iBAAiB,CAAqBL,IAArB,CAAxB;AACD,GAFM,MAEA;AACL,UAAMM,KAAK,CAAC,sBAAD,CAAX;AACD;AACF;;AArBDC;;AAuBA,SAAgBH,gBAAhB,CAAiCJ,IAAjC,EAAyD;AACvD,MAAIQ,QAAQ,GAAgB,EAA5B;AACA,MAAMC,GAAG,GAAGT,IAAI,CAACU,UAAjB;AACA,MAAIC,cAAc,GAAG,CAArB;AACA,MAAIC,sBAAsB,GAAGH,GAAG,CAACI,MAAJ,GAAaF,cAA1C;AACA,MAAIG,WAAJ,CALuD,CAMvD;;AACA,MAAIC,uBAAuB,GAAG,IAA9B,CAPuD,CAQvD;;AACA,SAAOH,sBAAsB,IAAIG,uBAAjC,EAA0D;AACxDD,eAAW,GAAGL,GAAG,CAACE,cAAD,CAAjB;AACAI,2BAAuB,GAAG,2BAAeD,WAAf,CAA1B;AACAN,YAAQ,GAAGA,QAAQ,CAACQ,MAAT,CAAgBjB,KAAK,CAACe,WAAD,CAArB,CAAX;AACAH,kBAAc,GAAGA,cAAc,GAAG,CAAlC;AACAC,0BAAsB,GAAGH,GAAG,CAACI,MAAJ,GAAaF,cAAtC;AACD;;AAED,SAAO,kBAAKH,QAAL,CAAP;AACD;;AAlBDD;;AAoBA,SAAgBF,iBAAhB,CAAkCL,IAAlC,EAA0D;AACxD,MAAMiB,qBAAqB,GAAkB,iBAC3CjB,IAAI,CAACU,UADsC,EAE3C,UAACQ,SAAD,EAAU;AACR,WAAOnB,KAAK,CAACmB,SAAD,CAAZ;AACD,GAJ0C,CAA7C;AAMA,SAAO,kBAAK,qBAAmBD,qBAAnB,CAAL,CAAP;AACD;;AARDV;;AAUA,SAAgBJ,gBAAhB,CAAiCgB,QAAjC,EAAmD;AACjD,SAAO,CAACA,QAAQ,CAACC,YAAV,CAAP;AACD;;AAFDb","names":["first","prod","gast_public_1","referencedRule","firstForTerminal","firstForSequence","firstForBranching","Error","exports","firstSet","seq","definition","nextSubProdIdx","hasInnerProdsRemaining","length","currSubProd","isLastInnerProdOptional","concat","allAlternativesFirsts","innerProd","terminal","terminalType"],"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/chevrotain/src/parse/grammar/first.ts"],"sourcesContent":["import { uniq, map, flatten } from \"@chevrotain/utils\"\nimport { AbstractProduction, NonTerminal, Terminal } from \"./gast/gast_public\"\nimport { isBranchingProd, isOptionalProd, isSequenceProd } from \"./gast/gast\"\nimport { IProduction, TokenType } from \"@chevrotain/types\"\n\nexport function first(prod: IProduction): TokenType[] {\n  /* istanbul ignore else */\n  if (prod instanceof NonTerminal) {\n    // this could in theory cause infinite loops if\n    // (1) prod A refs prod B.\n    // (2) prod B refs prod A\n    // (3) AB can match the empty set\n    // in other words a cycle where everything is optional so the first will keep\n    // looking ahead for the next optional part and will never exit\n    // currently there is no safeguard for this unique edge case because\n    // (1) not sure a grammar in which this can happen is useful for anything (productive)\n    return first((<NonTerminal>prod).referencedRule)\n  } else if (prod instanceof Terminal) {\n    return firstForTerminal(<Terminal>prod)\n  } else if (isSequenceProd(prod)) {\n    return firstForSequence(<AbstractProduction>prod)\n  } else if (isBranchingProd(prod)) {\n    return firstForBranching(<AbstractProduction>prod)\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nexport function firstForSequence(prod: AbstractProduction): TokenType[] {\n  let firstSet: TokenType[] = []\n  const seq = prod.definition\n  let nextSubProdIdx = 0\n  let hasInnerProdsRemaining = seq.length > nextSubProdIdx\n  let currSubProd\n  // so we enter the loop at least once (if the definition is not empty\n  let isLastInnerProdOptional = true\n  // scan a sequence until it's end or until we have found a NONE optional production in it\n  while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n    currSubProd = seq[nextSubProdIdx]\n    isLastInnerProdOptional = isOptionalProd(currSubProd)\n    firstSet = firstSet.concat(first(currSubProd))\n    nextSubProdIdx = nextSubProdIdx + 1\n    hasInnerProdsRemaining = seq.length > nextSubProdIdx\n  }\n\n  return uniq(firstSet)\n}\n\nexport function firstForBranching(prod: AbstractProduction): TokenType[] {\n  const allAlternativesFirsts: TokenType[][] = map(\n    prod.definition,\n    (innerProd) => {\n      return first(innerProd)\n    }\n  )\n  return uniq(flatten<TokenType>(allAlternativesFirsts))\n}\n\nexport function firstForTerminal(terminal: Terminal): TokenType[] {\n  return [terminal.terminalType]\n}\n"]},"metadata":{},"sourceType":"script"}