{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LooksAhead = void 0;\n\nvar lookahead_1 = require(\"../../grammar/lookahead\");\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar parser_1 = require(\"../parser\");\n\nvar keys_1 = require(\"../../grammar/keys\");\n\nvar gast_1 = require(\"../../grammar/gast/gast\");\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\n\n\nvar LooksAhead =\n/** @class */\nfunction () {\n  function LooksAhead() {}\n\n  LooksAhead.prototype.initLooksAhead = function (config) {\n    this.dynamicTokensEnabled = (0, utils_1.has)(config, \"dynamicTokensEnabled\") ? config.dynamicTokensEnabled : parser_1.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\n    this.maxLookahead = (0, utils_1.has)(config, \"maxLookahead\") ? config.maxLookahead : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;\n    /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n\n    this.lookAheadFuncsCache = (0, utils_1.isES2015MapSupported)() ? new Map() : []; // Performance optimization on newer engines that support ES6 Map\n    // For larger Maps this is slightly faster than using a plain object (array in our case).\n\n    /* istanbul ignore else - The else branch will be tested on older node.js versions and IE11 */\n\n    if ((0, utils_1.isES2015MapSupported)()) {\n      this.getLaFuncFromCache = this.getLaFuncFromMap;\n      this.setLaFuncCache = this.setLaFuncCacheUsingMap;\n    } else {\n      this.getLaFuncFromCache = this.getLaFuncFromObj;\n      this.setLaFuncCache = this.setLaFuncUsingObj;\n    }\n  };\n\n  LooksAhead.prototype.preComputeLookaheadFunctions = function (rules) {\n    var _this = this;\n\n    (0, utils_1.forEach)(rules, function (currRule) {\n      _this.TRACE_INIT(currRule.name + \" Rule Lookahead\", function () {\n        var _a = (0, gast_1.collectMethods)(currRule),\n            alternation = _a.alternation,\n            repetition = _a.repetition,\n            option = _a.option,\n            repetitionMandatory = _a.repetitionMandatory,\n            repetitionMandatoryWithSeparator = _a.repetitionMandatoryWithSeparator,\n            repetitionWithSeparator = _a.repetitionWithSeparator;\n\n        (0, utils_1.forEach)(alternation, function (currProd) {\n          var prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\n\n          _this.TRACE_INIT(\"\" + (0, gast_1.getProductionDslName)(currProd) + prodIdx, function () {\n            var laFunc = (0, lookahead_1.buildLookaheadFuncForOr)(currProd.idx, currRule, currProd.maxLookahead || _this.maxLookahead, currProd.hasPredicates, _this.dynamicTokensEnabled, _this.lookAheadBuilderForAlternatives);\n            var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[currRule.name], keys_1.OR_IDX, currProd.idx);\n\n            _this.setLaFuncCache(key, laFunc);\n          });\n        });\n        (0, utils_1.forEach)(repetition, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_IDX, lookahead_1.PROD_TYPE.REPETITION, currProd.maxLookahead, (0, gast_1.getProductionDslName)(currProd));\n        });\n        (0, utils_1.forEach)(option, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.OPTION_IDX, lookahead_1.PROD_TYPE.OPTION, currProd.maxLookahead, (0, gast_1.getProductionDslName)(currProd));\n        });\n        (0, utils_1.forEach)(repetitionMandatory, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_IDX, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, currProd.maxLookahead, (0, gast_1.getProductionDslName)(currProd));\n        });\n        (0, utils_1.forEach)(repetitionMandatoryWithSeparator, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_SEP_IDX, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currProd.maxLookahead, (0, gast_1.getProductionDslName)(currProd));\n        });\n        (0, utils_1.forEach)(repetitionWithSeparator, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_SEP_IDX, lookahead_1.PROD_TYPE.REPETITION_WITH_SEPARATOR, currProd.maxLookahead, (0, gast_1.getProductionDslName)(currProd));\n        });\n      });\n    });\n  };\n\n  LooksAhead.prototype.computeLookaheadFunc = function (rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n    var _this = this;\n\n    this.TRACE_INIT(\"\" + dslMethodName + (prodOccurrence === 0 ? \"\" : prodOccurrence), function () {\n      var laFunc = (0, lookahead_1.buildLookaheadFuncForOptionalProd)(prodOccurrence, rule, prodMaxLookahead || _this.maxLookahead, _this.dynamicTokensEnabled, prodType, _this.lookAheadBuilderForOptional);\n      var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);\n\n      _this.setLaFuncCache(key, laFunc);\n    });\n  };\n\n  LooksAhead.prototype.lookAheadBuilderForOptional = function (alt, tokenMatcher, dynamicTokensEnabled) {\n    return (0, lookahead_1.buildSingleAlternativeLookaheadFunction)(alt, tokenMatcher, dynamicTokensEnabled);\n  };\n\n  LooksAhead.prototype.lookAheadBuilderForAlternatives = function (alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n    return (0, lookahead_1.buildAlternativesLookAheadFunc)(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n  }; // this actually returns a number, but it is always used as a string (object prop key)\n\n\n  LooksAhead.prototype.getKeyForAutomaticLookahead = function (dslMethodIdx, occurrence) {\n    var currRuleShortName = this.getLastExplicitRuleShortName();\n    return (0, keys_1.getKeyForAutomaticLookahead)(currRuleShortName, dslMethodIdx, occurrence);\n  };\n  /* istanbul ignore next */\n\n\n  LooksAhead.prototype.getLaFuncFromCache = function (key) {\n    return undefined;\n  };\n\n  LooksAhead.prototype.getLaFuncFromMap = function (key) {\n    return this.lookAheadFuncsCache.get(key);\n  };\n  /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n\n\n  LooksAhead.prototype.getLaFuncFromObj = function (key) {\n    return this.lookAheadFuncsCache[key];\n  };\n  /* istanbul ignore next */\n\n\n  LooksAhead.prototype.setLaFuncCache = function (key, value) {};\n\n  LooksAhead.prototype.setLaFuncCacheUsingMap = function (key, value) {\n    this.lookAheadFuncsCache.set(key, value);\n  };\n  /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n\n\n  LooksAhead.prototype.setLaFuncUsingObj = function (key, value) {\n    this.lookAheadFuncsCache[key] = value;\n  };\n\n  return LooksAhead;\n}();\n\nexports.LooksAhead = LooksAhead;","map":{"version":3,"mappings":"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","names":["LooksAhead","config","dynamicTokensEnabled","parser_1","maxLookahead","lookAheadFuncsCache","Map","getLaFuncFromCache","getLaFuncFromMap","setLaFuncCache","setLaFuncCacheUsingMap","getLaFuncFromObj","setLaFuncUsingObj","rules","currRule","_this","TRACE_INIT","name","alternation","repetition","option","repetitionMandatory","repetitionMandatoryWithSeparator","repetitionWithSeparator","currProd","prodIdx","idx","laFunc","hasPredicates","lookAheadBuilderForAlternatives","key","fullRuleNameToShort","keys_1","computeLookaheadFunc","lookahead_1","REPETITION","OPTION","REPETITION_MANDATORY","REPETITION_MANDATORY_WITH_SEPARATOR","REPETITION_WITH_SEPARATOR","rule","prodOccurrence","prodKey","prodType","prodMaxLookahead","dslMethodName","lookAheadBuilderForOptional","alt","tokenMatcher","alts","dslMethodIdx","occurrence","currRuleShortName","getLastExplicitRuleShortName","undefined","get","value","set","exports"],"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/chevrotain/src/parse/parser/traits/looksahead.ts"],"sourcesContent":["import {\n  buildAlternativesLookAheadFunc,\n  buildLookaheadFuncForOptionalProd,\n  buildLookaheadFuncForOr,\n  buildSingleAlternativeLookaheadFunction,\n  PROD_TYPE\n} from \"../../grammar/lookahead\"\nimport { forEach, has, isES2015MapSupported } from \"@chevrotain/utils\"\nimport {\n  DEFAULT_PARSER_CONFIG,\n  lookAheadSequence,\n  TokenMatcher\n} from \"../parser\"\nimport { IOrAlt, IParserConfig } from \"@chevrotain/types\"\nimport {\n  AT_LEAST_ONE_IDX,\n  AT_LEAST_ONE_SEP_IDX,\n  getKeyForAutomaticLookahead,\n  MANY_IDX,\n  MANY_SEP_IDX,\n  OPTION_IDX,\n  OR_IDX\n} from \"../../grammar/keys\"\nimport { MixedInParser } from \"./parser_traits\"\nimport { Rule } from \"../../grammar/gast/gast_public\"\nimport { collectMethods, getProductionDslName } from \"../../grammar/gast/gast\"\n\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\nexport class LooksAhead {\n  maxLookahead: number\n  lookAheadFuncsCache: any\n  dynamicTokensEnabled: boolean\n\n  initLooksAhead(config: IParserConfig) {\n    this.dynamicTokensEnabled = has(config, \"dynamicTokensEnabled\")\n      ? config.dynamicTokensEnabled\n      : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled\n\n    this.maxLookahead = has(config, \"maxLookahead\")\n      ? config.maxLookahead\n      : DEFAULT_PARSER_CONFIG.maxLookahead\n\n    /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n    this.lookAheadFuncsCache = isES2015MapSupported() ? new Map() : []\n\n    // Performance optimization on newer engines that support ES6 Map\n    // For larger Maps this is slightly faster than using a plain object (array in our case).\n    /* istanbul ignore else - The else branch will be tested on older node.js versions and IE11 */\n    if (isES2015MapSupported()) {\n      this.getLaFuncFromCache = this.getLaFuncFromMap\n      this.setLaFuncCache = this.setLaFuncCacheUsingMap\n    } else {\n      this.getLaFuncFromCache = this.getLaFuncFromObj\n      this.setLaFuncCache = this.setLaFuncUsingObj\n    }\n  }\n\n  preComputeLookaheadFunctions(this: MixedInParser, rules: Rule[]): void {\n    forEach(rules, (currRule) => {\n      this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\n        const {\n          alternation,\n          repetition,\n          option,\n          repetitionMandatory,\n          repetitionMandatoryWithSeparator,\n          repetitionWithSeparator\n        } = collectMethods(currRule)\n\n        forEach(alternation, (currProd) => {\n          const prodIdx = currProd.idx === 0 ? \"\" : currProd.idx\n          this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () => {\n            const laFunc = buildLookaheadFuncForOr(\n              currProd.idx,\n              currRule,\n              currProd.maxLookahead || this.maxLookahead,\n              currProd.hasPredicates,\n              this.dynamicTokensEnabled,\n              this.lookAheadBuilderForAlternatives\n            )\n\n            const key = getKeyForAutomaticLookahead(\n              this.fullRuleNameToShort[currRule.name],\n              OR_IDX,\n              currProd.idx\n            )\n            this.setLaFuncCache(key, laFunc)\n          })\n        })\n\n        forEach(repetition, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            MANY_IDX,\n            PROD_TYPE.REPETITION,\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(option, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            OPTION_IDX,\n            PROD_TYPE.OPTION,\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionMandatory, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            AT_LEAST_ONE_IDX,\n            PROD_TYPE.REPETITION_MANDATORY,\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionMandatoryWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            AT_LEAST_ONE_SEP_IDX,\n            PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            MANY_SEP_IDX,\n            PROD_TYPE.REPETITION_WITH_SEPARATOR,\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n      })\n    })\n  }\n\n  computeLookaheadFunc(\n    this: MixedInParser,\n    rule: Rule,\n    prodOccurrence: number,\n    prodKey: number,\n    prodType: PROD_TYPE,\n    prodMaxLookahead: number,\n    dslMethodName: string\n  ): void {\n    this.TRACE_INIT(\n      `${dslMethodName}${prodOccurrence === 0 ? \"\" : prodOccurrence}`,\n      () => {\n        const laFunc = buildLookaheadFuncForOptionalProd(\n          prodOccurrence,\n          rule,\n          prodMaxLookahead || this.maxLookahead,\n          this.dynamicTokensEnabled,\n          prodType,\n          this.lookAheadBuilderForOptional\n        )\n        const key = getKeyForAutomaticLookahead(\n          this.fullRuleNameToShort[rule.name],\n          prodKey,\n          prodOccurrence\n        )\n        this.setLaFuncCache(key, laFunc)\n      }\n    )\n  }\n\n  lookAheadBuilderForOptional(\n    this: MixedInParser,\n    alt: lookAheadSequence,\n    tokenMatcher: TokenMatcher,\n    dynamicTokensEnabled: boolean\n  ): () => boolean {\n    return buildSingleAlternativeLookaheadFunction(\n      alt,\n      tokenMatcher,\n      dynamicTokensEnabled\n    )\n  }\n\n  lookAheadBuilderForAlternatives(\n    this: MixedInParser,\n    alts: lookAheadSequence[],\n    hasPredicates: boolean,\n    tokenMatcher: TokenMatcher,\n    dynamicTokensEnabled: boolean\n  ): (orAlts?: IOrAlt<any>[]) => number | undefined {\n    return buildAlternativesLookAheadFunc(\n      alts,\n      hasPredicates,\n      tokenMatcher,\n      dynamicTokensEnabled\n    )\n  }\n\n  // this actually returns a number, but it is always used as a string (object prop key)\n  getKeyForAutomaticLookahead(\n    this: MixedInParser,\n    dslMethodIdx: number,\n    occurrence: number\n  ): number {\n    const currRuleShortName: any = this.getLastExplicitRuleShortName()\n    return getKeyForAutomaticLookahead(\n      currRuleShortName,\n      dslMethodIdx,\n      occurrence\n    )\n  }\n\n  /* istanbul ignore next */\n  getLaFuncFromCache(this: MixedInParser, key: number): Function {\n    return undefined\n  }\n\n  getLaFuncFromMap(this: MixedInParser, key: number): Function {\n    return this.lookAheadFuncsCache.get(key)\n  }\n\n  /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n  getLaFuncFromObj(this: MixedInParser, key: number): Function {\n    return this.lookAheadFuncsCache[key]\n  }\n\n  /* istanbul ignore next */\n  setLaFuncCache(this: MixedInParser, key: number, value: Function): void {}\n\n  setLaFuncCacheUsingMap(\n    this: MixedInParser,\n    key: number,\n    value: Function\n  ): void {\n    this.lookAheadFuncsCache.set(key, value)\n  }\n\n  /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n  setLaFuncUsingObj(this: MixedInParser, key: number, value: Function): void {\n    this.lookAheadFuncsCache[key] = value\n  }\n}\n"]},"metadata":{},"sourceType":"script"}