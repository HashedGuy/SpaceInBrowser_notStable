{"ast":null,"code":"import _createClass from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _assertThisInitialized from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Mesh, Color, Plane, Vector3, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, ShaderMaterial, UniformsUtils } from 'three';\n\nvar Reflector = /*#__PURE__*/function (_Mesh) {\n  _inherits(Reflector, _Mesh);\n\n  var _super = _createSuper(Reflector);\n\n  function Reflector(geometry) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Reflector);\n\n    _this = _super.call(this, geometry);\n    _this.type = 'Reflector';\n\n    var scope = _assertThisInitialized(_this);\n\n    var color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n    var textureWidth = options.textureWidth || 512;\n    var textureHeight = options.textureHeight || 512;\n    var clipBias = options.clipBias || 0;\n    var shader = options.shader || Reflector.ReflectorShader; //\n\n    var reflectorPlane = new Plane();\n    var normal = new Vector3();\n    var reflectorWorldPosition = new Vector3();\n    var cameraWorldPosition = new Vector3();\n    var rotationMatrix = new Matrix4();\n    var lookAtPosition = new Vector3(0, 0, -1);\n    var clipPlane = new Vector4();\n    var view = new Vector3();\n    var target = new Vector3();\n    var q = new Vector4();\n    var textureMatrix = new Matrix4();\n    var virtualCamera = new PerspectiveCamera();\n    var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);\n    var material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms['tDiffuse'].value = renderTarget.texture;\n    material.uniforms['color'].value = color;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n    _this.material = material;\n\n    _this.onBeforeRender = function (renderer, scene, camera) {\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far; // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n      var projectionMatrix = virtualCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1.0;\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w; // Render\n\n      renderTarget.texture.encoding = renderer.outputEncoding;\n      scope.visible = false;\n      var currentRenderTarget = renderer.getRenderTarget();\n      var currentXrEnabled = renderer.xr.enabled;\n      var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      renderer.xr.enabled = false; // Avoid camera modification\n\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n      var viewport = camera.viewport;\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n\n      scope.visible = true;\n    };\n\n    _this.getRenderTarget = function () {\n      return renderTarget;\n    };\n\n    _this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n\n    return _this;\n  }\n\n  return _createClass(Reflector);\n}(Mesh);\n\nReflector.prototype.isReflector = true;\nReflector.ReflectorShader = {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader:\n  /* glsl */\n  \"\\n\\t\\tuniform mat4 textureMatrix;\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\t#include <common>\\n\\t\\t#include <logdepthbuf_pars_vertex>\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv = textureMatrix * vec4( position, 1.0 );\\n\\n\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n\\t\\t\\t#include <logdepthbuf_vertex>\\n\\n\\t\\t}\",\n  fragmentShader:\n  /* glsl */\n  \"\\n\\t\\tuniform vec3 color;\\n\\t\\tuniform sampler2D tDiffuse;\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\t#include <logdepthbuf_pars_fragment>\\n\\n\\t\\tfloat blendOverlay( float base, float blend ) {\\n\\n\\t\\t\\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\\n\\n\\t\\t}\\n\\n\\t\\tvec3 blendOverlay( vec3 base, vec3 blend ) {\\n\\n\\t\\t\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\\n\\n\\t\\t}\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\t#include <logdepthbuf_fragment>\\n\\n\\t\\t\\tvec4 base = texture2DProj( tDiffuse, vUv );\\n\\t\\t\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\\n\\n\\t\\t}\"\n};\nexport { Reflector };","map":{"version":3,"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/three-stdlib/objects/Reflector.js"],"names":["Mesh","Color","Plane","Vector3","Matrix4","Vector4","PerspectiveCamera","WebGLRenderTarget","ShaderMaterial","UniformsUtils","Reflector","geometry","options","type","scope","color","undefined","textureWidth","textureHeight","clipBias","shader","ReflectorShader","reflectorPlane","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","virtualCamera","renderTarget","material","uniforms","clone","fragmentShader","vertexShader","value","texture","onBeforeRender","renderer","scene","camera","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","encoding","outputEncoding","visible","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","dispose","prototype","isReflector","tDiffuse"],"mappings":"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","sourcesContent":["import { Mesh, Color, Plane, Vector3, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, ShaderMaterial, UniformsUtils } from 'three';\n\nclass Reflector extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.type = 'Reflector';\n    const scope = this;\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || Reflector.ReflectorShader; //\n\n    const reflectorPlane = new Plane();\n    const normal = new Vector3();\n    const reflectorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const clipPlane = new Vector4();\n    const view = new Vector3();\n    const target = new Vector3();\n    const q = new Vector4();\n    const textureMatrix = new Matrix4();\n    const virtualCamera = new PerspectiveCamera();\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);\n    const material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms['tDiffuse'].value = renderTarget.texture;\n    material.uniforms['color'].value = color;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n    this.material = material;\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far; // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n      const projectionMatrix = virtualCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1.0;\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w; // Render\n\n      renderTarget.texture.encoding = renderer.outputEncoding;\n      scope.visible = false;\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      renderer.xr.enabled = false; // Avoid camera modification\n\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n      const viewport = camera.viewport;\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n\n      scope.visible = true;\n    };\n\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n\n    this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n\n}\n\nReflector.prototype.isReflector = true;\nReflector.ReflectorShader = {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`,\n  fragmentShader:\n  /* glsl */\n  `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t}`\n};\n\nexport { Reflector };\n"]},"metadata":{},"sourceType":"module"}