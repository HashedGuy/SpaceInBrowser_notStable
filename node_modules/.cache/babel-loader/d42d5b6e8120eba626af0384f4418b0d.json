{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isTokenType = exports.hasExtendingTokensTypesMapProperty = exports.hasExtendingTokensTypesProperty = exports.hasCategoriesProperty = exports.hasShortKeyProperty = exports.singleAssignCategoriesToksMap = exports.assignCategoriesMapProp = exports.assignCategoriesTokensProp = exports.assignTokenDefaultProps = exports.expandCategories = exports.augmentTokenTypes = exports.tokenIdxToClass = exports.tokenShortNameIdx = exports.tokenStructuredMatcherNoCategories = exports.tokenStructuredMatcher = void 0;\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nfunction tokenStructuredMatcher(tokInstance, tokConstructor) {\n  var instanceType = tokInstance.tokenTypeIdx;\n\n  if (instanceType === tokConstructor.tokenTypeIdx) {\n    return true;\n  } else {\n    return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;\n  }\n}\n\nexports.tokenStructuredMatcher = tokenStructuredMatcher; // Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\n\nfunction tokenStructuredMatcherNoCategories(token, tokType) {\n  return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\n\nexports.tokenStructuredMatcherNoCategories = tokenStructuredMatcherNoCategories;\nexports.tokenShortNameIdx = 1;\nexports.tokenIdxToClass = {};\n\nfunction augmentTokenTypes(tokenTypes) {\n  // collect the parent Token Types as well.\n  var tokenTypesAndParents = expandCategories(tokenTypes); // add required tokenType and categoryMatches properties\n\n  assignTokenDefaultProps(tokenTypesAndParents); // fill up the categoryMatches\n\n  assignCategoriesMapProp(tokenTypesAndParents);\n  assignCategoriesTokensProp(tokenTypesAndParents);\n  (0, utils_1.forEach)(tokenTypesAndParents, function (tokType) {\n    tokType.isParent = tokType.categoryMatches.length > 0;\n  });\n}\n\nexports.augmentTokenTypes = augmentTokenTypes;\n\nfunction expandCategories(tokenTypes) {\n  var result = (0, utils_1.cloneArr)(tokenTypes);\n  var categories = tokenTypes;\n  var searching = true;\n\n  while (searching) {\n    categories = (0, utils_1.compact)((0, utils_1.flatten)((0, utils_1.map)(categories, function (currTokType) {\n      return currTokType.CATEGORIES;\n    })));\n    var newCategories = (0, utils_1.difference)(categories, result);\n    result = result.concat(newCategories);\n\n    if ((0, utils_1.isEmpty)(newCategories)) {\n      searching = false;\n    } else {\n      categories = newCategories;\n    }\n  }\n\n  return result;\n}\n\nexports.expandCategories = expandCategories;\n\nfunction assignTokenDefaultProps(tokenTypes) {\n  (0, utils_1.forEach)(tokenTypes, function (currTokType) {\n    if (!hasShortKeyProperty(currTokType)) {\n      exports.tokenIdxToClass[exports.tokenShortNameIdx] = currTokType;\n      currTokType.tokenTypeIdx = exports.tokenShortNameIdx++;\n    } // CATEGORIES? : TokenType | TokenType[]\n\n\n    if (hasCategoriesProperty(currTokType) && !(0, utils_1.isArray)(currTokType.CATEGORIES) // &&\n    // !isUndefined(currTokType.CATEGORIES.PATTERN)\n    ) {\n      currTokType.CATEGORIES = [currTokType.CATEGORIES];\n    }\n\n    if (!hasCategoriesProperty(currTokType)) {\n      currTokType.CATEGORIES = [];\n    }\n\n    if (!hasExtendingTokensTypesProperty(currTokType)) {\n      currTokType.categoryMatches = [];\n    }\n\n    if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n      currTokType.categoryMatchesMap = {};\n    }\n  });\n}\n\nexports.assignTokenDefaultProps = assignTokenDefaultProps;\n\nfunction assignCategoriesTokensProp(tokenTypes) {\n  (0, utils_1.forEach)(tokenTypes, function (currTokType) {\n    // avoid duplications\n    currTokType.categoryMatches = [];\n    (0, utils_1.forEach)(currTokType.categoryMatchesMap, function (val, key) {\n      currTokType.categoryMatches.push(exports.tokenIdxToClass[key].tokenTypeIdx);\n    });\n  });\n}\n\nexports.assignCategoriesTokensProp = assignCategoriesTokensProp;\n\nfunction assignCategoriesMapProp(tokenTypes) {\n  (0, utils_1.forEach)(tokenTypes, function (currTokType) {\n    singleAssignCategoriesToksMap([], currTokType);\n  });\n}\n\nexports.assignCategoriesMapProp = assignCategoriesMapProp;\n\nfunction singleAssignCategoriesToksMap(path, nextNode) {\n  (0, utils_1.forEach)(path, function (pathNode) {\n    nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n  });\n  (0, utils_1.forEach)(nextNode.CATEGORIES, function (nextCategory) {\n    var newPath = path.concat(nextNode); // avoids infinite loops due to cyclic categories.\n\n    if (!(0, utils_1.contains)(newPath, nextCategory)) {\n      singleAssignCategoriesToksMap(newPath, nextCategory);\n    }\n  });\n}\n\nexports.singleAssignCategoriesToksMap = singleAssignCategoriesToksMap;\n\nfunction hasShortKeyProperty(tokType) {\n  return (0, utils_1.has)(tokType, \"tokenTypeIdx\");\n}\n\nexports.hasShortKeyProperty = hasShortKeyProperty;\n\nfunction hasCategoriesProperty(tokType) {\n  return (0, utils_1.has)(tokType, \"CATEGORIES\");\n}\n\nexports.hasCategoriesProperty = hasCategoriesProperty;\n\nfunction hasExtendingTokensTypesProperty(tokType) {\n  return (0, utils_1.has)(tokType, \"categoryMatches\");\n}\n\nexports.hasExtendingTokensTypesProperty = hasExtendingTokensTypesProperty;\n\nfunction hasExtendingTokensTypesMapProperty(tokType) {\n  return (0, utils_1.has)(tokType, \"categoryMatchesMap\");\n}\n\nexports.hasExtendingTokensTypesMapProperty = hasExtendingTokensTypesMapProperty;\n\nfunction isTokenType(tokType) {\n  return (0, utils_1.has)(tokType, \"tokenTypeIdx\");\n}\n\nexports.isTokenType = isTokenType;","map":{"version":3,"mappings":"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","names":["tokenStructuredMatcher","tokInstance","tokConstructor","instanceType","tokenTypeIdx","isParent","categoryMatchesMap","exports","tokenStructuredMatcherNoCategories","token","tokType","augmentTokenTypes","tokenTypes","tokenTypesAndParents","expandCategories","assignTokenDefaultProps","assignCategoriesMapProp","assignCategoriesTokensProp","categoryMatches","length","result","categories","searching","currTokType","CATEGORIES","newCategories","concat","hasShortKeyProperty","hasCategoriesProperty","hasExtendingTokensTypesProperty","hasExtendingTokensTypesMapProperty","val","key","push","singleAssignCategoriesToksMap","path","nextNode","pathNode","nextCategory","newPath","isTokenType"],"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/chevrotain/src/scan/tokens.ts"],"sourcesContent":["import {\n  cloneArr,\n  compact,\n  contains,\n  difference,\n  flatten,\n  forEach,\n  has,\n  isArray,\n  isEmpty,\n  map\n} from \"@chevrotain/utils\"\nimport { TokenType } from \"@chevrotain/types\"\n\nexport function tokenStructuredMatcher(tokInstance, tokConstructor) {\n  const instanceType = tokInstance.tokenTypeIdx\n  if (instanceType === tokConstructor.tokenTypeIdx) {\n    return true\n  } else {\n    return (\n      tokConstructor.isParent === true &&\n      tokConstructor.categoryMatchesMap[instanceType] === true\n    )\n  }\n}\n\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nexport function tokenStructuredMatcherNoCategories(token, tokType) {\n  return token.tokenTypeIdx === tokType.tokenTypeIdx\n}\n\nexport let tokenShortNameIdx = 1\nexport const tokenIdxToClass = {}\n\nexport function augmentTokenTypes(tokenTypes: TokenType[]): void {\n  // collect the parent Token Types as well.\n  const tokenTypesAndParents = expandCategories(tokenTypes)\n\n  // add required tokenType and categoryMatches properties\n  assignTokenDefaultProps(tokenTypesAndParents)\n\n  // fill up the categoryMatches\n  assignCategoriesMapProp(tokenTypesAndParents)\n  assignCategoriesTokensProp(tokenTypesAndParents)\n\n  forEach(tokenTypesAndParents, (tokType) => {\n    tokType.isParent = tokType.categoryMatches.length > 0\n  })\n}\n\nexport function expandCategories(tokenTypes: TokenType[]): TokenType[] {\n  let result = cloneArr(tokenTypes)\n\n  let categories = tokenTypes\n  let searching = true\n  while (searching) {\n    categories = compact(\n      flatten(map(categories, (currTokType) => currTokType.CATEGORIES))\n    )\n\n    const newCategories = difference(categories, result)\n\n    result = result.concat(newCategories)\n\n    if (isEmpty(newCategories)) {\n      searching = false\n    } else {\n      categories = newCategories\n    }\n  }\n  return result\n}\n\nexport function assignTokenDefaultProps(tokenTypes: TokenType[]): void {\n  forEach(tokenTypes, (currTokType) => {\n    if (!hasShortKeyProperty(currTokType)) {\n      tokenIdxToClass[tokenShortNameIdx] = currTokType\n      ;(<any>currTokType).tokenTypeIdx = tokenShortNameIdx++\n    }\n\n    // CATEGORIES? : TokenType | TokenType[]\n    if (\n      hasCategoriesProperty(currTokType) &&\n      !isArray(currTokType.CATEGORIES)\n      // &&\n      // !isUndefined(currTokType.CATEGORIES.PATTERN)\n    ) {\n      currTokType.CATEGORIES = [currTokType.CATEGORIES]\n    }\n\n    if (!hasCategoriesProperty(currTokType)) {\n      currTokType.CATEGORIES = []\n    }\n\n    if (!hasExtendingTokensTypesProperty(currTokType)) {\n      currTokType.categoryMatches = []\n    }\n\n    if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n      currTokType.categoryMatchesMap = {}\n    }\n  })\n}\n\nexport function assignCategoriesTokensProp(tokenTypes: TokenType[]): void {\n  forEach(tokenTypes, (currTokType) => {\n    // avoid duplications\n    currTokType.categoryMatches = []\n    forEach(currTokType.categoryMatchesMap, (val, key) => {\n      currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx)\n    })\n  })\n}\n\nexport function assignCategoriesMapProp(tokenTypes: TokenType[]): void {\n  forEach(tokenTypes, (currTokType) => {\n    singleAssignCategoriesToksMap([], currTokType)\n  })\n}\n\nexport function singleAssignCategoriesToksMap(\n  path: TokenType[],\n  nextNode: TokenType\n): void {\n  forEach(path, (pathNode) => {\n    nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true\n  })\n\n  forEach(nextNode.CATEGORIES, (nextCategory) => {\n    const newPath = path.concat(nextNode)\n    // avoids infinite loops due to cyclic categories.\n    if (!contains(newPath, nextCategory)) {\n      singleAssignCategoriesToksMap(newPath, nextCategory)\n    }\n  })\n}\n\nexport function hasShortKeyProperty(tokType: TokenType): boolean {\n  return has(tokType, \"tokenTypeIdx\")\n}\n\nexport function hasCategoriesProperty(tokType: TokenType): boolean {\n  return has(tokType, \"CATEGORIES\")\n}\n\nexport function hasExtendingTokensTypesProperty(tokType: TokenType): boolean {\n  return has(tokType, \"categoryMatches\")\n}\n\nexport function hasExtendingTokensTypesMapProperty(\n  tokType: TokenType\n): boolean {\n  return has(tokType, \"categoryMatchesMap\")\n}\n\nexport function isTokenType(tokType: TokenType): boolean {\n  return has(tokType, \"tokenTypeIdx\")\n}\n"]},"metadata":{},"sourceType":"script"}