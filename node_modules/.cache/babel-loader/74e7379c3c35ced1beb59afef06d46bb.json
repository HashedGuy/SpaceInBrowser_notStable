{"ast":null,"code":"import _classCallCheck from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Object3D, MeshBasicMaterial, MathUtils, Mesh } from 'three';\nimport { LightningStrike } from '../geometries/LightningStrike.js';\n/**\n * @fileoverview Lightning strike object generator\n *\n *\n * Usage\n *\n * const myStorm = new LightningStorm( paramsObject );\n * myStorm.position.set( ... );\n * scene.add( myStorm );\n * ...\n * myStorm.update( currentTime );\n *\n * The \"currentTime\" can only go forwards or be stopped.\n *\n *\n * LightningStorm parameters:\n *\n * @param {double} size Size of the storm. If no 'onRayPosition' parameter is defined, it means the side of the rectangle the storm covers.\n *\n * @param {double} minHeight Minimum height a ray can start at. If no 'onRayPosition' parameter is defined, it means the height above plane y = 0.\n *\n * @param {double} maxHeight Maximum height a ray can start at. If no 'onRayPosition' parameter is defined, it means the height above plane y = 0.\n *\n * @param {double} maxSlope The maximum inclination slope of a ray. If no 'onRayPosition' parameter is defined, it means the slope relative to plane y = 0.\n *\n * @param {integer} maxLightnings Greater than 0. The maximum number of simultaneous rays.\n *\n * @param {double} lightningMinPeriod minimum time between two consecutive rays.\n *\n * @param {double} lightningMaxPeriod maximum time between two consecutive rays.\n *\n * @param {double} lightningMinDuration The minimum time a ray can last.\n *\n * @param {double} lightningMaxDuration The maximum time a ray can last.\n *\n * @param {Object} lightningParameters The parameters for created rays. See LightningStrike (geometry)\n *\n * @param {Material} lightningMaterial The THREE.Material used for the created rays.\n *\n * @param {function} onRayPosition Optional callback with two Vector3 parameters (source, dest). You can set here the start and end points for each created ray, using the standard size, minHeight, etc parameters and other values in your algorithm.\n *\n * @param {function} onLightningDown This optional callback is called with one parameter (lightningStrike) when a ray ends propagating, so it has hit the ground.\n *\n *\n */\n\nvar LightningStorm = /*#__PURE__*/function (_Object3D) {\n  _inherits(LightningStorm, _Object3D);\n\n  var _super = _createSuper(LightningStorm);\n\n  function LightningStorm() {\n    var _this;\n\n    var stormParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LightningStorm);\n\n    _this = _super.call(this); // Parameters\n\n    _this.stormParams = stormParams;\n    stormParams.size = stormParams.size !== undefined ? stormParams.size : 1000.0;\n    stormParams.minHeight = stormParams.minHeight !== undefined ? stormParams.minHeight : 80.0;\n    stormParams.maxHeight = stormParams.maxHeight !== undefined ? stormParams.maxHeight : 100.0;\n    stormParams.maxSlope = stormParams.maxSlope !== undefined ? stormParams.maxSlope : 1.1;\n    stormParams.maxLightnings = stormParams.maxLightnings !== undefined ? stormParams.maxLightnings : 3;\n    stormParams.lightningMinPeriod = stormParams.lightningMinPeriod !== undefined ? stormParams.lightningMinPeriod : 3.0;\n    stormParams.lightningMaxPeriod = stormParams.lightningMaxPeriod !== undefined ? stormParams.lightningMaxPeriod : 7.0;\n    stormParams.lightningMinDuration = stormParams.lightningMinDuration !== undefined ? stormParams.lightningMinDuration : 1.0;\n    stormParams.lightningMaxDuration = stormParams.lightningMaxDuration !== undefined ? stormParams.lightningMaxDuration : 2.5;\n    _this.lightningParameters = LightningStrike.copyParameters(stormParams.lightningParameters, stormParams.lightningParameters);\n    _this.lightningParameters.isEternal = false;\n    _this.lightningMaterial = stormParams.lightningMaterial !== undefined ? stormParams.lightningMaterial : new MeshBasicMaterial({\n      color: 0xb0ffff\n    });\n\n    if (stormParams.onRayPosition !== undefined) {\n      _this.onRayPosition = stormParams.onRayPosition;\n    } else {\n      _this.onRayPosition = function (source, dest) {\n        dest.set((Math.random() - 0.5) * stormParams.size, 0, (Math.random() - 0.5) * stormParams.size);\n        var height = MathUtils.lerp(stormParams.minHeight, stormParams.maxHeight, Math.random());\n        source.set(stormParams.maxSlope * (2 * Math.random() - 1), 1, stormParams.maxSlope * (2 * Math.random() - 1)).multiplyScalar(height).add(dest);\n      };\n    }\n\n    _this.onLightningDown = stormParams.onLightningDown; // Internal state\n\n    _this.inited = false;\n    _this.nextLightningTime = 0;\n    _this.lightningsMeshes = [];\n    _this.deadLightningsMeshes = [];\n\n    for (var i = 0; i < _this.stormParams.maxLightnings; i++) {\n      var lightning = new LightningStrike(LightningStrike.copyParameters({}, _this.lightningParameters));\n      var mesh = new Mesh(lightning, _this.lightningMaterial);\n\n      _this.deadLightningsMeshes.push(mesh);\n    }\n\n    return _this;\n  }\n\n  _createClass(LightningStorm, [{\n    key: \"update\",\n    value: function update(time) {\n      if (!this.inited) {\n        this.nextLightningTime = this.getNextLightningTime(time) * Math.random();\n        this.inited = true;\n      }\n\n      if (time >= this.nextLightningTime) {\n        // Lightning creation\n        var lightningMesh = this.deadLightningsMeshes.pop();\n\n        if (lightningMesh) {\n          var lightningParams1 = LightningStrike.copyParameters(lightningMesh.geometry.rayParameters, this.lightningParameters);\n          lightningParams1.birthTime = time;\n          lightningParams1.deathTime = time + MathUtils.lerp(this.stormParams.lightningMinDuration, this.stormParams.lightningMaxDuration, Math.random());\n          this.onRayPosition(lightningParams1.sourceOffset, lightningParams1.destOffset);\n          lightningParams1.noiseSeed = Math.random();\n          this.add(lightningMesh);\n          this.lightningsMeshes.push(lightningMesh);\n        } // Schedule next lightning\n\n\n        this.nextLightningTime = this.getNextLightningTime(time);\n      }\n\n      var i = 0,\n          il = this.lightningsMeshes.length;\n\n      while (i < il) {\n        var mesh = this.lightningsMeshes[i];\n        var lightning = mesh.geometry;\n        var prevState = lightning.state;\n        lightning.update(time);\n\n        if (prevState === LightningStrike.RAY_PROPAGATING && lightning.state > prevState) {\n          if (this.onLightningDown) {\n            this.onLightningDown(lightning);\n          }\n        }\n\n        if (lightning.state === LightningStrike.RAY_EXTINGUISHED) {\n          // Lightning is to be destroyed\n          this.lightningsMeshes.splice(this.lightningsMeshes.indexOf(mesh), 1);\n          this.deadLightningsMeshes.push(mesh);\n          this.remove(mesh);\n          il--;\n        } else {\n          i++;\n        }\n      }\n    }\n  }, {\n    key: \"getNextLightningTime\",\n    value: function getNextLightningTime(currentTime) {\n      return currentTime + MathUtils.lerp(this.stormParams.lightningMinPeriod, this.stormParams.lightningMaxPeriod, Math.random()) / (this.stormParams.maxLightnings + 1);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      _get(_getPrototypeOf(LightningStorm.prototype), \"copy\", this).call(this, source);\n\n      this.stormParams.size = source.stormParams.size;\n      this.stormParams.minHeight = source.stormParams.minHeight;\n      this.stormParams.maxHeight = source.stormParams.maxHeight;\n      this.stormParams.maxSlope = source.stormParams.maxSlope;\n      this.stormParams.maxLightnings = source.stormParams.maxLightnings;\n      this.stormParams.lightningMinPeriod = source.stormParams.lightningMinPeriod;\n      this.stormParams.lightningMaxPeriod = source.stormParams.lightningMaxPeriod;\n      this.stormParams.lightningMinDuration = source.stormParams.lightningMinDuration;\n      this.stormParams.lightningMaxDuration = source.stormParams.lightningMaxDuration;\n      this.lightningParameters = LightningStrike.copyParameters({}, source.lightningParameters);\n      this.lightningMaterial = source.stormParams.lightningMaterial;\n      this.onLightningDown = source.onLightningDown;\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor(this.stormParams).copy(this);\n    }\n  }]);\n\n  return LightningStorm;\n}(Object3D);\n\nLightningStorm.prototype.isLightningStorm = true;\nexport { LightningStorm };","map":{"version":3,"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/three-stdlib/objects/LightningStorm.js"],"names":["Object3D","MeshBasicMaterial","MathUtils","Mesh","LightningStrike","LightningStorm","stormParams","size","undefined","minHeight","maxHeight","maxSlope","maxLightnings","lightningMinPeriod","lightningMaxPeriod","lightningMinDuration","lightningMaxDuration","lightningParameters","copyParameters","isEternal","lightningMaterial","color","onRayPosition","source","dest","set","Math","random","height","lerp","multiplyScalar","add","onLightningDown","inited","nextLightningTime","lightningsMeshes","deadLightningsMeshes","i","lightning","mesh","push","time","getNextLightningTime","lightningMesh","pop","lightningParams1","geometry","rayParameters","birthTime","deathTime","sourceOffset","destOffset","noiseSeed","il","length","prevState","state","update","RAY_PROPAGATING","RAY_EXTINGUISHED","splice","indexOf","remove","currentTime","constructor","copy","prototype","isLightningStorm"],"mappings":"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","sourcesContent":["import { Object3D, MeshBasicMaterial, MathUtils, Mesh } from 'three';\nimport { LightningStrike } from '../geometries/LightningStrike.js';\n\n/**\n * @fileoverview Lightning strike object generator\n *\n *\n * Usage\n *\n * const myStorm = new LightningStorm( paramsObject );\n * myStorm.position.set( ... );\n * scene.add( myStorm );\n * ...\n * myStorm.update( currentTime );\n *\n * The \"currentTime\" can only go forwards or be stopped.\n *\n *\n * LightningStorm parameters:\n *\n * @param {double} size Size of the storm. If no 'onRayPosition' parameter is defined, it means the side of the rectangle the storm covers.\n *\n * @param {double} minHeight Minimum height a ray can start at. If no 'onRayPosition' parameter is defined, it means the height above plane y = 0.\n *\n * @param {double} maxHeight Maximum height a ray can start at. If no 'onRayPosition' parameter is defined, it means the height above plane y = 0.\n *\n * @param {double} maxSlope The maximum inclination slope of a ray. If no 'onRayPosition' parameter is defined, it means the slope relative to plane y = 0.\n *\n * @param {integer} maxLightnings Greater than 0. The maximum number of simultaneous rays.\n *\n * @param {double} lightningMinPeriod minimum time between two consecutive rays.\n *\n * @param {double} lightningMaxPeriod maximum time between two consecutive rays.\n *\n * @param {double} lightningMinDuration The minimum time a ray can last.\n *\n * @param {double} lightningMaxDuration The maximum time a ray can last.\n *\n * @param {Object} lightningParameters The parameters for created rays. See LightningStrike (geometry)\n *\n * @param {Material} lightningMaterial The THREE.Material used for the created rays.\n *\n * @param {function} onRayPosition Optional callback with two Vector3 parameters (source, dest). You can set here the start and end points for each created ray, using the standard size, minHeight, etc parameters and other values in your algorithm.\n *\n * @param {function} onLightningDown This optional callback is called with one parameter (lightningStrike) when a ray ends propagating, so it has hit the ground.\n *\n *\n */\n\nclass LightningStorm extends Object3D {\n  constructor(stormParams = {}) {\n    super(); // Parameters\n\n    this.stormParams = stormParams;\n    stormParams.size = stormParams.size !== undefined ? stormParams.size : 1000.0;\n    stormParams.minHeight = stormParams.minHeight !== undefined ? stormParams.minHeight : 80.0;\n    stormParams.maxHeight = stormParams.maxHeight !== undefined ? stormParams.maxHeight : 100.0;\n    stormParams.maxSlope = stormParams.maxSlope !== undefined ? stormParams.maxSlope : 1.1;\n    stormParams.maxLightnings = stormParams.maxLightnings !== undefined ? stormParams.maxLightnings : 3;\n    stormParams.lightningMinPeriod = stormParams.lightningMinPeriod !== undefined ? stormParams.lightningMinPeriod : 3.0;\n    stormParams.lightningMaxPeriod = stormParams.lightningMaxPeriod !== undefined ? stormParams.lightningMaxPeriod : 7.0;\n    stormParams.lightningMinDuration = stormParams.lightningMinDuration !== undefined ? stormParams.lightningMinDuration : 1.0;\n    stormParams.lightningMaxDuration = stormParams.lightningMaxDuration !== undefined ? stormParams.lightningMaxDuration : 2.5;\n    this.lightningParameters = LightningStrike.copyParameters(stormParams.lightningParameters, stormParams.lightningParameters);\n    this.lightningParameters.isEternal = false;\n    this.lightningMaterial = stormParams.lightningMaterial !== undefined ? stormParams.lightningMaterial : new MeshBasicMaterial({\n      color: 0xb0ffff\n    });\n\n    if (stormParams.onRayPosition !== undefined) {\n      this.onRayPosition = stormParams.onRayPosition;\n    } else {\n      this.onRayPosition = function (source, dest) {\n        dest.set((Math.random() - 0.5) * stormParams.size, 0, (Math.random() - 0.5) * stormParams.size);\n        const height = MathUtils.lerp(stormParams.minHeight, stormParams.maxHeight, Math.random());\n        source.set(stormParams.maxSlope * (2 * Math.random() - 1), 1, stormParams.maxSlope * (2 * Math.random() - 1)).multiplyScalar(height).add(dest);\n      };\n    }\n\n    this.onLightningDown = stormParams.onLightningDown; // Internal state\n\n    this.inited = false;\n    this.nextLightningTime = 0;\n    this.lightningsMeshes = [];\n    this.deadLightningsMeshes = [];\n\n    for (let i = 0; i < this.stormParams.maxLightnings; i++) {\n      const lightning = new LightningStrike(LightningStrike.copyParameters({}, this.lightningParameters));\n      const mesh = new Mesh(lightning, this.lightningMaterial);\n      this.deadLightningsMeshes.push(mesh);\n    }\n  }\n\n  update(time) {\n    if (!this.inited) {\n      this.nextLightningTime = this.getNextLightningTime(time) * Math.random();\n      this.inited = true;\n    }\n\n    if (time >= this.nextLightningTime) {\n      // Lightning creation\n      const lightningMesh = this.deadLightningsMeshes.pop();\n\n      if (lightningMesh) {\n        const lightningParams1 = LightningStrike.copyParameters(lightningMesh.geometry.rayParameters, this.lightningParameters);\n        lightningParams1.birthTime = time;\n        lightningParams1.deathTime = time + MathUtils.lerp(this.stormParams.lightningMinDuration, this.stormParams.lightningMaxDuration, Math.random());\n        this.onRayPosition(lightningParams1.sourceOffset, lightningParams1.destOffset);\n        lightningParams1.noiseSeed = Math.random();\n        this.add(lightningMesh);\n        this.lightningsMeshes.push(lightningMesh);\n      } // Schedule next lightning\n\n\n      this.nextLightningTime = this.getNextLightningTime(time);\n    }\n\n    let i = 0,\n        il = this.lightningsMeshes.length;\n\n    while (i < il) {\n      const mesh = this.lightningsMeshes[i];\n      const lightning = mesh.geometry;\n      const prevState = lightning.state;\n      lightning.update(time);\n\n      if (prevState === LightningStrike.RAY_PROPAGATING && lightning.state > prevState) {\n        if (this.onLightningDown) {\n          this.onLightningDown(lightning);\n        }\n      }\n\n      if (lightning.state === LightningStrike.RAY_EXTINGUISHED) {\n        // Lightning is to be destroyed\n        this.lightningsMeshes.splice(this.lightningsMeshes.indexOf(mesh), 1);\n        this.deadLightningsMeshes.push(mesh);\n        this.remove(mesh);\n        il--;\n      } else {\n        i++;\n      }\n    }\n  }\n\n  getNextLightningTime(currentTime) {\n    return currentTime + MathUtils.lerp(this.stormParams.lightningMinPeriod, this.stormParams.lightningMaxPeriod, Math.random()) / (this.stormParams.maxLightnings + 1);\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.stormParams.size = source.stormParams.size;\n    this.stormParams.minHeight = source.stormParams.minHeight;\n    this.stormParams.maxHeight = source.stormParams.maxHeight;\n    this.stormParams.maxSlope = source.stormParams.maxSlope;\n    this.stormParams.maxLightnings = source.stormParams.maxLightnings;\n    this.stormParams.lightningMinPeriod = source.stormParams.lightningMinPeriod;\n    this.stormParams.lightningMaxPeriod = source.stormParams.lightningMaxPeriod;\n    this.stormParams.lightningMinDuration = source.stormParams.lightningMinDuration;\n    this.stormParams.lightningMaxDuration = source.stormParams.lightningMaxDuration;\n    this.lightningParameters = LightningStrike.copyParameters({}, source.lightningParameters);\n    this.lightningMaterial = source.stormParams.lightningMaterial;\n    this.onLightningDown = source.onLightningDown;\n    return this;\n  }\n\n  clone() {\n    return new this.constructor(this.stormParams).copy(this);\n  }\n\n}\n\nLightningStorm.prototype.isLightningStorm = true;\n\nexport { LightningStorm };\n"]},"metadata":{},"sourceType":"module"}