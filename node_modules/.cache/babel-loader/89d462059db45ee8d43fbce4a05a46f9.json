{"ast":null,"code":"import { intersectTri } from './ThreeRayIntersectUtilities.js';\nexport function intersectTris(geo, side, ray, offset, count, intersections) {\n  for (var i = offset, end = offset + count; i < end; i++) {\n    intersectTri(geo, side, ray, i, intersections);\n  }\n}\nexport function intersectClosestTri(geo, side, ray, offset, count) {\n  var dist = Infinity;\n  var res = null;\n\n  for (var i = offset, end = offset + count; i < end; i++) {\n    var intersection = intersectTri(geo, side, ray, i);\n\n    if (intersection && intersection.distance < dist) {\n      res = intersection;\n      dist = intersection.distance;\n    }\n  }\n\n  return res;\n} // converts the given BVH raycast intersection to align with the three.js raycast\n// structure (include object, world space distance and point).\n\nexport function convertRaycastIntersect(hit, object, raycaster) {\n  if (hit === null) {\n    return null;\n  }\n\n  hit.point.applyMatrix4(object.matrixWorld);\n  hit.distance = hit.point.distanceTo(raycaster.ray.origin);\n  hit.object = object;\n\n  if (hit.distance < raycaster.near || hit.distance > raycaster.far) {\n    return null;\n  } else {\n    return hit;\n  }\n}","map":{"version":3,"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js"],"names":["intersectTri","intersectTris","geo","side","ray","offset","count","intersections","i","end","intersectClosestTri","dist","Infinity","res","intersection","distance","convertRaycastIntersect","hit","object","raycaster","point","applyMatrix4","matrixWorld","distanceTo","origin","near","far"],"mappings":"AAAA,SAASA,YAAT,QAA6B,iCAA7B;AAEA,OAAO,SAASC,aAAT,CAAwBC,GAAxB,EAA6BC,IAA7B,EAAmCC,GAAnC,EAAwCC,MAAxC,EAAgDC,KAAhD,EAAuDC,aAAvD,EAAuE;AAE7E,OAAM,IAAIC,CAAC,GAAGH,MAAR,EAAgBI,GAAG,GAAGJ,MAAM,GAAGC,KAArC,EAA4CE,CAAC,GAAGC,GAAhD,EAAqDD,CAAC,EAAtD,EAA4D;AAE3DR,IAAAA,YAAY,CAAEE,GAAF,EAAOC,IAAP,EAAaC,GAAb,EAAkBI,CAAlB,EAAqBD,aAArB,CAAZ;AAEA;AAED;AAED,OAAO,SAASG,mBAAT,CAA8BR,GAA9B,EAAmCC,IAAnC,EAAyCC,GAAzC,EAA8CC,MAA9C,EAAsDC,KAAtD,EAA8D;AAEpE,MAAIK,IAAI,GAAGC,QAAX;AACA,MAAIC,GAAG,GAAG,IAAV;;AACA,OAAM,IAAIL,CAAC,GAAGH,MAAR,EAAgBI,GAAG,GAAGJ,MAAM,GAAGC,KAArC,EAA4CE,CAAC,GAAGC,GAAhD,EAAqDD,CAAC,EAAtD,EAA4D;AAE3D,QAAMM,YAAY,GAAGd,YAAY,CAAEE,GAAF,EAAOC,IAAP,EAAaC,GAAb,EAAkBI,CAAlB,CAAjC;;AACA,QAAKM,YAAY,IAAIA,YAAY,CAACC,QAAb,GAAwBJ,IAA7C,EAAoD;AAEnDE,MAAAA,GAAG,GAAGC,YAAN;AACAH,MAAAA,IAAI,GAAGG,YAAY,CAACC,QAApB;AAEA;AAED;;AAED,SAAOF,GAAP;AAEA,C,CAED;AACA;;AACA,OAAO,SAASG,uBAAT,CAAkCC,GAAlC,EAAuCC,MAAvC,EAA+CC,SAA/C,EAA2D;AAEjE,MAAKF,GAAG,KAAK,IAAb,EAAoB;AAEnB,WAAO,IAAP;AAEA;;AAEDA,EAAAA,GAAG,CAACG,KAAJ,CAAUC,YAAV,CAAwBH,MAAM,CAACI,WAA/B;AACAL,EAAAA,GAAG,CAACF,QAAJ,GAAeE,GAAG,CAACG,KAAJ,CAAUG,UAAV,CAAsBJ,SAAS,CAACf,GAAV,CAAcoB,MAApC,CAAf;AACAP,EAAAA,GAAG,CAACC,MAAJ,GAAaA,MAAb;;AAEA,MAAKD,GAAG,CAACF,QAAJ,GAAeI,SAAS,CAACM,IAAzB,IAAiCR,GAAG,CAACF,QAAJ,GAAeI,SAAS,CAACO,GAA/D,EAAqE;AAEpE,WAAO,IAAP;AAEA,GAJD,MAIO;AAEN,WAAOT,GAAP;AAEA;AAED","sourcesContent":["import { intersectTri } from './ThreeRayIntersectUtilities.js';\r\n\r\nexport function intersectTris( geo, side, ray, offset, count, intersections ) {\r\n\r\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\tintersectTri( geo, side, ray, i, intersections );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function intersectClosestTri( geo, side, ray, offset, count ) {\r\n\r\n\tlet dist = Infinity;\r\n\tlet res = null;\r\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\tconst intersection = intersectTri( geo, side, ray, i );\r\n\t\tif ( intersection && intersection.distance < dist ) {\r\n\r\n\t\t\tres = intersection;\r\n\t\t\tdist = intersection.distance;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn res;\r\n\r\n}\r\n\r\n// converts the given BVH raycast intersection to align with the three.js raycast\r\n// structure (include object, world space distance and point).\r\nexport function convertRaycastIntersect( hit, object, raycaster ) {\r\n\r\n\tif ( hit === null ) {\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n\thit.point.applyMatrix4( object.matrixWorld );\r\n\thit.distance = hit.point.distanceTo( raycaster.ray.origin );\r\n\thit.object = object;\r\n\r\n\tif ( hit.distance < raycaster.near || hit.distance > raycaster.far ) {\r\n\r\n\t\treturn null;\r\n\r\n\t} else {\r\n\r\n\t\treturn hit;\r\n\r\n\t}\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}