{"ast":null,"code":"function bidiFactory() {\n  var bidi = function (exports) {\n    // Bidi character types data, auto generated\n    var DATA = {\n      \"R\": \"13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73\",\n      \"EN\": \"1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9\",\n      \"ES\": \"17,2,6dp+1,f+1,av,16vr,mx+1,4o,2\",\n      \"ET\": \"z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj\",\n      \"AN\": \"16o+5,2j+9,2+1,35,ed,1ff2+9,87+u\",\n      \"CS\": \"18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b\",\n      \"B\": \"a,3,f+2,2v,690\",\n      \"S\": \"9,2,k\",\n      \"WS\": \"c,k,4f4,1vk+a,u,1j,335\",\n      \"ON\": \"x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i\",\n      \"BN\": \"0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1\",\n      \"NSM\": \"lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n\",\n      \"AL\": \"16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d\",\n      \"LRO\": \"6ct\",\n      \"RLO\": \"6cu\",\n      \"LRE\": \"6cq\",\n      \"RLE\": \"6cr\",\n      \"PDF\": \"6cs\",\n      \"LRI\": \"6ee\",\n      \"RLI\": \"6ef\",\n      \"FSI\": \"6eg\",\n      \"PDI\": \"6eh\"\n    };\n    var TYPES = {};\n    var TYPES_TO_NAMES = {};\n    TYPES.L = 1; //L is the default\n\n    TYPES_TO_NAMES[1] = 'L';\n    Object.keys(DATA).forEach(function (type, i) {\n      TYPES[type] = 1 << i + 1;\n      TYPES_TO_NAMES[TYPES[type]] = type;\n    });\n    Object.freeze(TYPES);\n    var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;\n    var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;\n    var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;\n    var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;\n    var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;\n    var map = null;\n\n    function parseData() {\n      if (!map) {\n        //const start = performance.now()\n        map = new Map();\n\n        var loop = function loop(type) {\n          if (DATA.hasOwnProperty(type)) {\n            var lastCode = 0;\n            DATA[type].split(',').forEach(function (range) {\n              var ref = range.split('+');\n              var skip = ref[0];\n              var step = ref[1];\n              skip = parseInt(skip, 36);\n              step = step ? parseInt(step, 36) : 0;\n              map.set(lastCode += skip, TYPES[type]);\n\n              for (var i = 0; i < step; i++) {\n                map.set(++lastCode, TYPES[type]);\n              }\n            });\n          }\n        };\n\n        for (var type in DATA) {\n          loop(type);\n        } //console.log(`char types parsed in ${performance.now() - start}ms`)\n\n      }\n    }\n    /**\n     * @param {string} char\n     * @return {number}\n     */\n\n\n    function getBidiCharType(char) {\n      parseData();\n      return map.get(char.codePointAt(0)) || TYPES.L;\n    }\n\n    function getBidiCharTypeName(char) {\n      return TYPES_TO_NAMES[getBidiCharType(char)];\n    } // Bidi bracket pairs data, auto generated\n\n\n    var data$1 = {\n      \"pairs\": \"14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1\",\n      \"canonical\": \"6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye\"\n    };\n    /**\n     * Parses an string that holds encoded codepoint mappings, e.g. for bracket pairs or\n     * mirroring characters, as encoded by scripts/generateBidiData.js. Returns an object\n     * holding the `map`, and optionally a `reverseMap` if `includeReverse:true`.\n     * @param {string} encodedString\n     * @param {boolean} includeReverse - true if you want reverseMap in the output\n     * @return {{map: Map<number, number>, reverseMap?: Map<number, number>}}\n     */\n\n    function parseCharacterMap(encodedString, includeReverse) {\n      var radix = 36;\n      var lastCode = 0;\n      var map = new Map();\n      var reverseMap = includeReverse && new Map();\n      var prevPair;\n      encodedString.split(',').forEach(function visit(entry) {\n        if (entry.indexOf('+') !== -1) {\n          for (var i = +entry; i--;) {\n            visit(prevPair);\n          }\n        } else {\n          prevPair = entry;\n          var ref = entry.split('>');\n          var a = ref[0];\n          var b = ref[1];\n          a = String.fromCodePoint(lastCode += parseInt(a, radix));\n          b = String.fromCodePoint(lastCode += parseInt(b, radix));\n          map.set(a, b);\n          includeReverse && reverseMap.set(b, a);\n        }\n      });\n      return {\n        map: map,\n        reverseMap: reverseMap\n      };\n    }\n\n    var openToClose, closeToOpen, canonical;\n\n    function parse$1() {\n      if (!openToClose) {\n        //const start = performance.now()\n        var ref = parseCharacterMap(data$1.pairs, true);\n        var map = ref.map;\n        var reverseMap = ref.reverseMap;\n        openToClose = map;\n        closeToOpen = reverseMap;\n        canonical = parseCharacterMap(data$1.canonical, false).map; //console.log(`brackets parsed in ${performance.now() - start}ms`)\n      }\n    }\n\n    function openingToClosingBracket(char) {\n      parse$1();\n      return openToClose.get(char) || null;\n    }\n\n    function closingToOpeningBracket(char) {\n      parse$1();\n      return closeToOpen.get(char) || null;\n    }\n\n    function getCanonicalBracket(char) {\n      parse$1();\n      return canonical.get(char) || null;\n    } // Local type aliases\n\n\n    var TYPE_L = TYPES.L;\n    var TYPE_R = TYPES.R;\n    var TYPE_EN = TYPES.EN;\n    var TYPE_ES = TYPES.ES;\n    var TYPE_ET = TYPES.ET;\n    var TYPE_AN = TYPES.AN;\n    var TYPE_CS = TYPES.CS;\n    var TYPE_B = TYPES.B;\n    var TYPE_S = TYPES.S;\n    var TYPE_ON = TYPES.ON;\n    var TYPE_BN = TYPES.BN;\n    var TYPE_NSM = TYPES.NSM;\n    var TYPE_AL = TYPES.AL;\n    var TYPE_LRO = TYPES.LRO;\n    var TYPE_RLO = TYPES.RLO;\n    var TYPE_LRE = TYPES.LRE;\n    var TYPE_RLE = TYPES.RLE;\n    var TYPE_PDF = TYPES.PDF;\n    var TYPE_LRI = TYPES.LRI;\n    var TYPE_RLI = TYPES.RLI;\n    var TYPE_FSI = TYPES.FSI;\n    var TYPE_PDI = TYPES.PDI;\n    /**\n     * @typedef {object} GetEmbeddingLevelsResult\n     * @property {{start, end, level}[]} paragraphs\n     * @property {Uint8Array} levels\n     */\n\n    /**\n     * This function applies the Bidirectional Algorithm to a string, returning the resolved embedding levels\n     * in a single Uint8Array plus a list of objects holding each paragraph's start and end indices and resolved\n     * base embedding level.\n     *\n     * @param {string} string - The input string\n     * @param {\"ltr\"|\"rtl\"|\"auto\"} [baseDirection] - Use \"ltr\" or \"rtl\" to force a base paragraph direction,\n     *        otherwise a direction will be chosen automatically from each paragraph's contents.\n     * @return {GetEmbeddingLevelsResult}\n     */\n\n    function getEmbeddingLevels(string, baseDirection) {\n      var MAX_DEPTH = 125; // Start by mapping all characters to their unicode type, as a bitmask integer\n\n      var charTypes = new Uint32Array(string.length);\n\n      for (var i = 0; i < string.length; i++) {\n        charTypes[i] = getBidiCharType(string[i]);\n      }\n\n      var charTypeCounts = new Map(); //will be cleared at start of each paragraph\n\n      function changeCharType(i, type) {\n        var oldType = charTypes[i];\n        charTypes[i] = type;\n        charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);\n\n        if (oldType & NEUTRAL_ISOLATE_TYPES) {\n          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);\n        }\n\n        charTypeCounts.set(type, (charTypeCounts.get(type) || 0) + 1);\n\n        if (type & NEUTRAL_ISOLATE_TYPES) {\n          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n        }\n      }\n\n      var embedLevels = new Uint8Array(string.length);\n      var isolationPairs = new Map(); //init->pdi and pdi->init\n      // === 3.3.1 The Paragraph Level ===\n      // 3.3.1 P1: Split the text into paragraphs\n\n      var paragraphs = []; // [{start, end, level}, ...]\n\n      var paragraph = null;\n\n      for (var i$1 = 0; i$1 < string.length; i$1++) {\n        if (!paragraph) {\n          paragraphs.push(paragraph = {\n            start: i$1,\n            end: string.length - 1,\n            // 3.3.1 P2-P3: Determine the paragraph level\n            level: baseDirection === 'rtl' ? 1 : baseDirection === 'ltr' ? 0 : determineAutoEmbedLevel(i$1, false)\n          });\n        }\n\n        if (charTypes[i$1] & TYPE_B) {\n          paragraph.end = i$1;\n          paragraph = null;\n        }\n      }\n\n      var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;\n\n      var nextEven = function nextEven(n) {\n        return n + (n & 1 ? 1 : 2);\n      };\n\n      var nextOdd = function nextOdd(n) {\n        return n + (n & 1 ? 2 : 1);\n      }; // Everything from here on will operate per paragraph.\n\n\n      for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {\n        paragraph = paragraphs[paraIdx];\n        var statusStack = [{\n          _level: paragraph.level,\n          _override: 0,\n          //0=neutral, 1=L, 2=R\n          _isolate: 0 //bool\n\n        }];\n        var stackTop = void 0;\n        var overflowIsolateCount = 0;\n        var overflowEmbeddingCount = 0;\n        var validIsolateCount = 0;\n        charTypeCounts.clear(); // === 3.3.2 Explicit Levels and Directions ===\n\n        for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {\n          var charType = charTypes[i$2];\n          stackTop = statusStack[statusStack.length - 1]; // Set initial counts\n\n          charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);\n\n          if (charType & NEUTRAL_ISOLATE_TYPES) {\n            charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n          } // Explicit Embeddings: 3.3.2 X2 - X3\n\n\n          if (charType & FORMATTING_TYPES) {\n            //prefilter all formatters\n            if (charType & (TYPE_RLE | TYPE_LRE)) {\n              embedLevels[i$2] = stackTop._level; // 5.2\n\n              var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);\n\n              if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n                statusStack.push({\n                  _level: level,\n                  _override: 0,\n                  _isolate: 0\n                });\n              } else if (!overflowIsolateCount) {\n                overflowEmbeddingCount++;\n              }\n            } // Explicit Overrides: 3.3.2 X4 - X5\n            else if (charType & (TYPE_RLO | TYPE_LRO)) {\n              embedLevels[i$2] = stackTop._level; // 5.2\n\n              var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);\n\n              if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n                statusStack.push({\n                  _level: level$1,\n                  _override: charType & TYPE_RLO ? TYPE_R : TYPE_L,\n                  _isolate: 0\n                });\n              } else if (!overflowIsolateCount) {\n                overflowEmbeddingCount++;\n              }\n            } // Isolates: 3.3.2 X5a - X5c\n            else if (charType & ISOLATE_INIT_TYPES) {\n              // X5c - FSI becomes either RLI or LRI\n              if (charType & TYPE_FSI) {\n                charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;\n              }\n\n              embedLevels[i$2] = stackTop._level;\n\n              if (stackTop._override) {\n                changeCharType(i$2, stackTop._override);\n              }\n\n              var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);\n\n              if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {\n                validIsolateCount++;\n                statusStack.push({\n                  _level: level$2,\n                  _override: 0,\n                  _isolate: 1,\n                  _isolInitIndex: i$2\n                });\n              } else {\n                overflowIsolateCount++;\n              }\n            } // Terminating Isolates: 3.3.2 X6a\n            else if (charType & TYPE_PDI) {\n              if (overflowIsolateCount > 0) {\n                overflowIsolateCount--;\n              } else if (validIsolateCount > 0) {\n                overflowEmbeddingCount = 0;\n\n                while (!statusStack[statusStack.length - 1]._isolate) {\n                  statusStack.pop();\n                } // Add to isolation pairs bidirectional mapping:\n\n\n                var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;\n\n                if (isolInitIndex != null) {\n                  isolationPairs.set(isolInitIndex, i$2);\n                  isolationPairs.set(i$2, isolInitIndex);\n                }\n\n                statusStack.pop();\n                validIsolateCount--;\n              }\n\n              stackTop = statusStack[statusStack.length - 1];\n              embedLevels[i$2] = stackTop._level;\n\n              if (stackTop._override) {\n                changeCharType(i$2, stackTop._override);\n              }\n            } // Terminating Embeddings and Overrides: 3.3.2 X7\n            else if (charType & TYPE_PDF) {\n              if (overflowIsolateCount === 0) {\n                if (overflowEmbeddingCount > 0) {\n                  overflowEmbeddingCount--;\n                } else if (!stackTop._isolate && statusStack.length > 1) {\n                  statusStack.pop();\n                  stackTop = statusStack[statusStack.length - 1];\n                }\n              }\n\n              embedLevels[i$2] = stackTop._level; // 5.2\n            } // End of Paragraph: 3.3.2 X8\n            else if (charType & TYPE_B) {\n              embedLevels[i$2] = paragraph.level;\n            }\n          } // Non-formatting characters: 3.3.2 X6\n          else {\n            embedLevels[i$2] = stackTop._level; // NOTE: This exclusion of BN seems to go against what section 5.2 says, but is required for test passage\n\n            if (stackTop._override && charType !== TYPE_BN) {\n              changeCharType(i$2, stackTop._override);\n            }\n          }\n        } // === 3.3.3 Preparations for Implicit Processing ===\n        // Remove all RLE, LRE, RLO, LRO, PDF, and BN characters: 3.3.3 X9\n        // Note: Due to section 5.2, we won't remove them, but we'll use the BN_LIKE_TYPES bitset to\n        // easily ignore them all from here on out.\n        // 3.3.3 X10\n        // Compute the set of isolating run sequences as specified by BD13\n\n\n        var levelRuns = [];\n        var currentRun = null;\n\n        for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {\n          var charType$1 = charTypes[i$3];\n\n          if (!(charType$1 & BN_LIKE_TYPES)) {\n            var lvl = embedLevels[i$3];\n            var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;\n            var isPDI = charType$1 === TYPE_PDI;\n\n            if (currentRun && lvl === currentRun._level) {\n              currentRun._end = i$3;\n              currentRun._endsWithIsolInit = isIsolInit;\n            } else {\n              levelRuns.push(currentRun = {\n                _start: i$3,\n                _end: i$3,\n                _level: lvl,\n                _startsWithPDI: isPDI,\n                _endsWithIsolInit: isIsolInit\n              });\n            }\n          }\n        }\n\n        var isolatingRunSeqs = []; // [{seqIndices: [], sosType: L|R, eosType: L|R}]\n\n        for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {\n          var run = levelRuns[runIdx];\n\n          if (!run._startsWithPDI || run._startsWithPDI && !isolationPairs.has(run._start)) {\n            var seqRuns = [currentRun = run];\n\n            for (var pdiIndex = void 0; currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null;) {\n              for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {\n                if (levelRuns[i$4]._start === pdiIndex) {\n                  seqRuns.push(currentRun = levelRuns[i$4]);\n                  break;\n                }\n              }\n            } // build flat list of indices across all runs:\n\n\n            var seqIndices = [];\n\n            for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {\n              var run$1 = seqRuns[i$5];\n\n              for (var j = run$1._start; j <= run$1._end; j++) {\n                seqIndices.push(j);\n              }\n            } // determine the sos/eos types:\n\n\n            var firstLevel = embedLevels[seqIndices[0]];\n            var prevLevel = paragraph.level;\n\n            for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {\n              if (!(charTypes[i$6] & BN_LIKE_TYPES)) {\n                //5.2\n                prevLevel = embedLevels[i$6];\n                break;\n              }\n            }\n\n            var lastIndex = seqIndices[seqIndices.length - 1];\n            var lastLevel = embedLevels[lastIndex];\n            var nextLevel = paragraph.level;\n\n            if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {\n              for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {\n                if (!(charTypes[i$7] & BN_LIKE_TYPES)) {\n                  //5.2\n                  nextLevel = embedLevels[i$7];\n                  break;\n                }\n              }\n            }\n\n            isolatingRunSeqs.push({\n              _seqIndices: seqIndices,\n              _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,\n              _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L\n            });\n          }\n        } // The next steps are done per isolating run sequence\n\n\n        for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {\n          var ref = isolatingRunSeqs[seqIdx];\n          var seqIndices$1 = ref._seqIndices;\n          var sosType = ref._sosType;\n          var eosType = ref._eosType; // === 3.3.4 Resolving Weak Types ===\n          // W1 + 5.2. Search backward from each NSM to the first character in the isolating run sequence whose\n          // bidirectional type is not BN, and set the NSM to ON if it is an isolate initiator or PDI, and to its\n          // type otherwise. If the NSM is the first non-BN character, change the NSM to the type of sos.\n\n          if (charTypeCounts.get(TYPE_NSM)) {\n            for (var si = 0; si < seqIndices$1.length; si++) {\n              var i$8 = seqIndices$1[si];\n\n              if (charTypes[i$8] & TYPE_NSM) {\n                var prevType = sosType;\n\n                for (var sj = si - 1; sj >= 0; sj--) {\n                  if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) {\n                    //5.2 scan back to first non-BN\n                    prevType = charTypes[seqIndices$1[sj]];\n                    break;\n                  }\n                }\n\n                changeCharType(i$8, prevType & (ISOLATE_INIT_TYPES | TYPE_PDI) ? TYPE_ON : prevType);\n              }\n            }\n          } // W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sos)\n          // is found. If an AL is found, change the type of the European number to Arabic number.\n\n\n          if (charTypeCounts.get(TYPE_EN)) {\n            for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {\n              var i$9 = seqIndices$1[si$1];\n\n              if (charTypes[i$9] & TYPE_EN) {\n                for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {\n                  var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];\n\n                  if (prevCharType & STRONG_TYPES) {\n                    if (prevCharType === TYPE_AL) {\n                      changeCharType(i$9, TYPE_AN);\n                    }\n\n                    break;\n                  }\n                }\n              }\n            }\n          } // W3. Change all ALs to R\n\n\n          if (charTypeCounts.get(TYPE_AL)) {\n            for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {\n              var i$10 = seqIndices$1[si$2];\n\n              if (charTypes[i$10] & TYPE_AL) {\n                changeCharType(i$10, TYPE_R);\n              }\n            }\n          } // W4. A single European separator between two European numbers changes to a European number. A single common\n          // separator between two numbers of the same type changes to that type.\n\n\n          if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n            for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {\n              var i$11 = seqIndices$1[si$3];\n\n              if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {\n                var prevType$1 = 0,\n                    nextType = 0;\n\n                for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {\n                  prevType$1 = charTypes[seqIndices$1[sj$2]];\n\n                  if (!(prevType$1 & BN_LIKE_TYPES)) {\n                    //5.2\n                    break;\n                  }\n                }\n\n                for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {\n                  nextType = charTypes[seqIndices$1[sj$3]];\n\n                  if (!(nextType & BN_LIKE_TYPES)) {\n                    //5.2\n                    break;\n                  }\n                }\n\n                if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : prevType$1 & (TYPE_EN | TYPE_AN))) {\n                  changeCharType(i$11, prevType$1);\n                }\n              }\n            }\n          } // W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.\n\n\n          if (charTypeCounts.get(TYPE_EN)) {\n            for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {\n              var i$12 = seqIndices$1[si$4];\n\n              if (charTypes[i$12] & TYPE_EN) {\n                for (var sj$4 = si$4 - 1; sj$4 >= 0 && charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES); sj$4--) {\n                  changeCharType(seqIndices$1[sj$4], TYPE_EN);\n                }\n\n                for (var sj$5 = si$4 + 1; sj$5 < seqIndices$1.length && charTypes[seqIndices$1[sj$5]] & (TYPE_ET | BN_LIKE_TYPES); sj$5++) {\n                  changeCharType(seqIndices$1[sj$5], TYPE_EN);\n                }\n              }\n            }\n          } // W6. Otherwise, separators and terminators change to Other Neutral.\n\n\n          if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n            for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {\n              var i$13 = seqIndices$1[si$5];\n\n              if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {\n                changeCharType(i$13, TYPE_ON); // 5.2 transform adjacent BNs too:\n\n                for (var sj$6 = si$5 - 1; sj$6 >= 0 && charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES; sj$6--) {\n                  changeCharType(seqIndices$1[sj$6], TYPE_ON);\n                }\n\n                for (var sj$7 = si$5 + 1; sj$7 < seqIndices$1.length && charTypes[seqIndices$1[sj$7]] & BN_LIKE_TYPES; sj$7++) {\n                  changeCharType(seqIndices$1[sj$7], TYPE_ON);\n                }\n              }\n            }\n          } // W7. Search backward from each instance of a European number until the first strong type (R, L, or sos)\n          // is found. If an L is found, then change the type of the European number to L.\n          // NOTE: implemented in single forward pass for efficiency\n\n\n          if (charTypeCounts.get(TYPE_EN)) {\n            for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {\n              var i$14 = seqIndices$1[si$6];\n              var type = charTypes[i$14];\n\n              if (type & TYPE_EN) {\n                if (prevStrongType === TYPE_L) {\n                  changeCharType(i$14, TYPE_L);\n                }\n              } else if (type & STRONG_TYPES) {\n                prevStrongType = type;\n              }\n            }\n          } // === 3.3.5 Resolving Neutral and Isolate Formatting Types ===\n\n\n          if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {\n            // N0. Process bracket pairs in an isolating run sequence sequentially in the logical order of the text\n            // positions of the opening paired brackets using the logic given below. Within this scope, bidirectional\n            // types EN and AN are treated as R.\n            var R_TYPES_FOR_N_STEPS = TYPE_R | TYPE_EN | TYPE_AN;\n            var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L; // * Identify the bracket pairs in the current isolating run sequence according to BD16.\n\n            var bracketPairs = [];\n            {\n              var openerStack = [];\n\n              for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {\n                // NOTE: for any potential bracket character we also test that it still carries a NI\n                // type, as that may have been changed earlier. This doesn't seem to be explicitly\n                // called out in the spec, but is required for passage of certain tests.\n                if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {\n                  var char = string[seqIndices$1[si$7]];\n                  var oppositeBracket = void 0; // Opening bracket\n\n                  if (openingToClosingBracket(char) !== null) {\n                    if (openerStack.length < 63) {\n                      openerStack.push({\n                        char: char,\n                        seqIndex: si$7\n                      });\n                    } else {\n                      break;\n                    }\n                  } // Closing bracket\n                  else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {\n                    for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {\n                      var stackChar = openerStack[stackIdx].char;\n\n                      if (stackChar === oppositeBracket || stackChar === closingToOpeningBracket(getCanonicalBracket(char)) || openingToClosingBracket(getCanonicalBracket(stackChar)) === char) {\n                        bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);\n                        openerStack.length = stackIdx; //pop the matching bracket and all following\n\n                        break;\n                      }\n                    }\n                  }\n                }\n              }\n\n              bracketPairs.sort(function (a, b) {\n                return a[0] - b[0];\n              });\n            } // * For each bracket-pair element in the list of pairs of text positions\n\n            for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {\n              var ref$1 = bracketPairs[pairIdx];\n              var openSeqIdx = ref$1[0];\n              var closeSeqIdx = ref$1[1]; // a. Inspect the bidirectional types of the characters enclosed within the bracket pair.\n              // b. If any strong type (either L or R) matching the embedding direction is found, set the type for both\n              // brackets in the pair to match the embedding direction.\n\n              var foundStrongType = false;\n              var useStrongType = 0;\n\n              for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {\n                var i$15 = seqIndices$1[si$8];\n\n                if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {\n                  foundStrongType = true;\n                  var lr = charTypes[i$15] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;\n\n                  if (lr === getEmbedDirection(i$15)) {\n                    useStrongType = lr;\n                    break;\n                  }\n                }\n              } // c. Otherwise, if there is a strong type it must be opposite the embedding direction. Therefore, test\n              // for an established context with a preceding strong type by checking backwards before the opening paired\n              // bracket until the first strong type (L, R, or sos) is found.\n              //    1. If the preceding strong type is also opposite the embedding direction, context is established, so\n              //    set the type for both brackets in the pair to that direction.\n              //    2. Otherwise set the type for both brackets in the pair to the embedding direction.\n\n\n              if (foundStrongType && !useStrongType) {\n                useStrongType = sosType;\n\n                for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {\n                  var i$16 = seqIndices$1[si$9];\n\n                  if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {\n                    var lr$1 = charTypes[i$16] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;\n\n                    if (lr$1 !== getEmbedDirection(i$16)) {\n                      useStrongType = lr$1;\n                    } else {\n                      useStrongType = getEmbedDirection(i$16);\n                    }\n\n                    break;\n                  }\n                }\n              }\n\n              if (useStrongType) {\n                charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType; // * Any number of characters that had original bidirectional character type NSM prior to the application\n                // of W1 that immediately follow a paired bracket which changed to L or R under N0 should change to match\n                // the type of their preceding bracket.\n\n                if (useStrongType !== getEmbedDirection(seqIndices$1[openSeqIdx])) {\n                  for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {\n                    if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {\n                      if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {\n                        charTypes[seqIndices$1[si$10]] = useStrongType;\n                      }\n\n                      break;\n                    }\n                  }\n                }\n\n                if (useStrongType !== getEmbedDirection(seqIndices$1[closeSeqIdx])) {\n                  for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {\n                    if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {\n                      if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {\n                        charTypes[seqIndices$1[si$11]] = useStrongType;\n                      }\n\n                      break;\n                    }\n                  }\n                }\n              }\n            } // N1. A sequence of NIs takes the direction of the surrounding strong text if the text on both sides has the\n            // same direction.\n            // N2. Any remaining NIs take the embedding direction.\n\n\n            for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {\n              if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {\n                var niRunStart = si$12,\n                    niRunEnd = si$12;\n                var prevType$2 = sosType; //si === 0 ? sosType : (charTypes[seqIndices[si - 1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L\n\n                for (var si2 = si$12 - 1; si2 >= 0; si2--) {\n                  if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {\n                    niRunStart = si2; //5.2 treat BNs adjacent to NIs as NIs\n                  } else {\n                    prevType$2 = charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;\n                    break;\n                  }\n                }\n\n                var nextType$1 = eosType;\n\n                for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {\n                  if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {\n                    niRunEnd = si2$1;\n                  } else {\n                    nextType$1 = charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;\n                    break;\n                  }\n                }\n\n                for (var sj$8 = niRunStart; sj$8 <= niRunEnd; sj$8++) {\n                  charTypes[seqIndices$1[sj$8]] = prevType$2 === nextType$1 ? prevType$2 : getEmbedDirection(seqIndices$1[sj$8]);\n                }\n\n                si$12 = niRunEnd;\n              }\n            }\n          }\n        } // === 3.3.6 Resolving Implicit Levels ===\n\n\n        for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {\n          var level$3 = embedLevels[i$17];\n          var type$1 = charTypes[i$17]; // I2. For all characters with an odd (right-to-left) embedding level, those of type L, EN or AN go up one level.\n\n          if (level$3 & 1) {\n            if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {\n              embedLevels[i$17]++;\n            }\n          } // I1. For all characters with an even (left-to-right) embedding level, those of type R go up one level\n          // and those of type AN or EN go up two levels.\n          else {\n            if (type$1 & TYPE_R) {\n              embedLevels[i$17]++;\n            } else if (type$1 & (TYPE_AN | TYPE_EN)) {\n              embedLevels[i$17] += 2;\n            }\n          } // 5.2: Resolve any LRE, RLE, LRO, RLO, PDF, or BN to the level of the preceding character if there is one,\n          // and otherwise to the base level.\n\n\n          if (type$1 & BN_LIKE_TYPES) {\n            embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];\n          } // 3.4 L1.1-4: Reset the embedding level of segment/paragraph separators, and any sequence of whitespace or\n          // isolate formatting characters preceding them or the end of the paragraph, to the paragraph level.\n          // NOTE: this will also need to be applied to each individual line ending after line wrapping occurs.\n\n\n          if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {\n            for (var j$1 = i$17; j$1 >= 0 && getBidiCharType(string[j$1]) & TRAILING_TYPES; j$1--) {\n              embedLevels[j$1] = paragraph.level;\n            }\n          }\n        }\n      } // DONE! The resolved levels can then be used, after line wrapping, to flip runs of characters\n      // according to section 3.4 Reordering Resolved Levels\n\n\n      return {\n        levels: embedLevels,\n        paragraphs: paragraphs\n      };\n\n      function determineAutoEmbedLevel(start, isFSI) {\n        // 3.3.1 P2 - P3\n        for (var i = start; i < string.length; i++) {\n          var charType = charTypes[i];\n\n          if (charType & (TYPE_R | TYPE_AL)) {\n            return 1;\n          }\n\n          if (charType & (TYPE_B | TYPE_L) || isFSI && charType === TYPE_PDI) {\n            return 0;\n          }\n\n          if (charType & ISOLATE_INIT_TYPES) {\n            var pdi = indexOfMatchingPDI(i);\n            i = pdi === -1 ? string.length : pdi;\n          }\n        }\n\n        return 0;\n      }\n\n      function indexOfMatchingPDI(isolateStart) {\n        // 3.1.2 BD9\n        var isolationLevel = 1;\n\n        for (var i = isolateStart + 1; i < string.length; i++) {\n          var charType = charTypes[i];\n\n          if (charType & TYPE_B) {\n            break;\n          }\n\n          if (charType & TYPE_PDI) {\n            if (--isolationLevel === 0) {\n              return i;\n            }\n          } else if (charType & ISOLATE_INIT_TYPES) {\n            isolationLevel++;\n          }\n        }\n\n        return -1;\n      }\n\n      function getEmbedDirection(i) {\n        return embedLevels[i] & 1 ? TYPE_R : TYPE_L;\n      }\n    } // Bidi mirrored chars data, auto generated\n\n\n    var data = \"14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1\";\n    var mirrorMap;\n\n    function parse() {\n      if (!mirrorMap) {\n        //const start = performance.now()\n        var ref = parseCharacterMap(data, true);\n        var map = ref.map;\n        var reverseMap = ref.reverseMap; // Combine both maps into one\n\n        reverseMap.forEach(function (value, key) {\n          map.set(key, value);\n        });\n        mirrorMap = map; //console.log(`mirrored chars parsed in ${performance.now() - start}ms`)\n      }\n    }\n\n    function getMirroredCharacter(char) {\n      parse();\n      return mirrorMap.get(char) || null;\n    }\n    /**\n     * Given a string and its resolved embedding levels, build a map of indices to replacement chars\n     * for any characters in right-to-left segments that have defined mirrored characters.\n     * @param string\n     * @param embeddingLevels\n     * @param [start]\n     * @param [end]\n     * @return {Map<number, string>}\n     */\n\n\n    function getMirroredCharactersMap(string, embeddingLevels, start, end) {\n      var strLen = string.length;\n      start = Math.max(0, start == null ? 0 : +start);\n      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n      var map = new Map();\n\n      for (var i = start; i <= end; i++) {\n        if (embeddingLevels[i] & 1) {\n          //only odd (rtl) levels\n          var mirror = getMirroredCharacter(string[i]);\n\n          if (mirror !== null) {\n            map.set(i, mirror);\n          }\n        }\n      }\n\n      return map;\n    }\n    /**\n     * Given a start and end denoting a single line within a string, and a set of precalculated\n     * bidi embedding levels, produce a list of segments whose ordering should be flipped, in sequence.\n     * @param {string} string - the full input string\n     * @param {GetEmbeddingLevelsResult} embeddingLevelsResult - the result object from getEmbeddingLevels\n     * @param {number} [start] - first character in a subset of the full string\n     * @param {number} [end] - last character in a subset of the full string\n     * @return {number[][]} - the list of start/end segments that should be flipped, in order.\n     */\n\n\n    function getReorderSegments(string, embeddingLevelsResult, start, end) {\n      var strLen = string.length;\n      start = Math.max(0, start == null ? 0 : +start);\n      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n      var segments = [];\n      embeddingLevelsResult.paragraphs.forEach(function (paragraph) {\n        var lineStart = Math.max(start, paragraph.start);\n        var lineEnd = Math.min(end, paragraph.end);\n\n        if (lineStart < lineEnd) {\n          // Local slice for mutation\n          var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1); // 3.4 L1.4: Reset any sequence of whitespace characters and/or isolate formatting characters at the\n          // end of the line to the paragraph level.\n\n          for (var i = lineEnd; i >= lineStart && getBidiCharType(string[i]) & TRAILING_TYPES; i--) {\n            lineLevels[i] = paragraph.level;\n          } // L2. From the highest level found in the text to the lowest odd level on each line, including intermediate levels\n          // not actually present in the text, reverse any contiguous sequence of characters that are at that level or higher.\n\n\n          var maxLevel = paragraph.level;\n          var minOddLevel = Infinity;\n\n          for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {\n            var level = lineLevels[i$1];\n\n            if (level > maxLevel) {\n              maxLevel = level;\n            }\n\n            if (level < minOddLevel) {\n              minOddLevel = level | 1;\n            }\n          }\n\n          for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {\n            for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {\n              if (lineLevels[i$2] >= lvl) {\n                var segStart = i$2;\n\n                while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {\n                  i$2++;\n                }\n\n                if (i$2 > segStart) {\n                  segments.push([segStart + start, i$2 + start]);\n                }\n              }\n            }\n          }\n        }\n      });\n      return segments;\n    }\n    /**\n     * @param {string} string\n     * @param {GetEmbeddingLevelsResult} embedLevelsResult\n     * @param {number} [start]\n     * @param {number} [end]\n     * @return {string} the new string with bidi segments reordered\n     */\n\n\n    function getReorderedString(string, embedLevelsResult, start, end) {\n      var indices = getReorderedIndices(string, embedLevelsResult, start, end);\n      var chars = [].concat(string);\n      indices.forEach(function (charIndex, i) {\n        chars[i] = (embedLevelsResult.levels[charIndex] & 1 ? getMirroredCharacter(string[charIndex]) : null) || string[charIndex];\n      });\n      return chars.join('');\n    }\n    /**\n     * @param {string} string\n     * @param {GetEmbeddingLevelsResult} embedLevelsResult\n     * @param {number} [start]\n     * @param {number} [end]\n     * @return {number[]} an array with character indices in their new bidi order\n     */\n\n\n    function getReorderedIndices(string, embedLevelsResult, start, end) {\n      var segments = getReorderSegments(string, embedLevelsResult, start, end); // Fill an array with indices\n\n      var indices = [];\n\n      for (var i = 0; i < string.length; i++) {\n        indices[i] = i;\n      } // Reverse each segment in order\n\n\n      segments.forEach(function (ref) {\n        var start = ref[0];\n        var end = ref[1];\n        var slice = indices.slice(start, end + 1);\n\n        for (var i = slice.length; i--;) {\n          indices[end - i] = slice[i];\n        }\n      });\n      return indices;\n    }\n\n    exports.closingToOpeningBracket = closingToOpeningBracket;\n    exports.getBidiCharType = getBidiCharType;\n    exports.getBidiCharTypeName = getBidiCharTypeName;\n    exports.getCanonicalBracket = getCanonicalBracket;\n    exports.getEmbeddingLevels = getEmbeddingLevels;\n    exports.getMirroredCharacter = getMirroredCharacter;\n    exports.getMirroredCharactersMap = getMirroredCharactersMap;\n    exports.getReorderSegments = getReorderSegments;\n    exports.getReorderedIndices = getReorderedIndices;\n    exports.getReorderedString = getReorderedString;\n    exports.openingToClosingBracket = openingToClosingBracket;\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    return exports;\n  }({});\n\n  return bidi;\n}\n\nexport default bidiFactory;","map":{"version":3,"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/bidi-js/dist/bidi.mjs"],"names":["bidiFactory","bidi","exports","DATA","TYPES","TYPES_TO_NAMES","L","Object","keys","forEach","type","i","freeze","ISOLATE_INIT_TYPES","LRI","RLI","FSI","STRONG_TYPES","R","AL","NEUTRAL_ISOLATE_TYPES","B","S","WS","ON","PDI","BN_LIKE_TYPES","BN","RLE","LRE","RLO","LRO","PDF","TRAILING_TYPES","map","parseData","Map","loop","hasOwnProperty","lastCode","split","range","ref","skip","step","parseInt","set","getBidiCharType","char","get","codePointAt","getBidiCharTypeName","data$1","parseCharacterMap","encodedString","includeReverse","radix","reverseMap","prevPair","visit","entry","indexOf","a","b","String","fromCodePoint","openToClose","closeToOpen","canonical","parse$1","pairs","openingToClosingBracket","closingToOpeningBracket","getCanonicalBracket","TYPE_L","TYPE_R","TYPE_EN","EN","TYPE_ES","ES","TYPE_ET","ET","TYPE_AN","AN","TYPE_CS","CS","TYPE_B","TYPE_S","TYPE_ON","TYPE_BN","TYPE_NSM","NSM","TYPE_AL","TYPE_LRO","TYPE_RLO","TYPE_LRE","TYPE_RLE","TYPE_PDF","TYPE_LRI","TYPE_RLI","TYPE_FSI","TYPE_PDI","getEmbeddingLevels","string","baseDirection","MAX_DEPTH","charTypes","Uint32Array","length","charTypeCounts","changeCharType","oldType","embedLevels","Uint8Array","isolationPairs","paragraphs","paragraph","i$1","push","start","end","level","determineAutoEmbedLevel","FORMATTING_TYPES","nextEven","n","nextOdd","paraIdx","statusStack","_level","_override","_isolate","stackTop","overflowIsolateCount","overflowEmbeddingCount","validIsolateCount","clear","i$2","charType","level$1","level$2","_isolInitIndex","pop","isolInitIndex","levelRuns","currentRun","i$3","charType$1","lvl","isIsolInit","isPDI","_end","_endsWithIsolInit","_start","_startsWithPDI","isolatingRunSeqs","runIdx","run","has","seqRuns","pdiIndex","i$4","seqIndices","i$5","run$1","j","firstLevel","prevLevel","i$6","lastIndex","lastLevel","nextLevel","i$7","_seqIndices","_sosType","Math","max","_eosType","seqIdx","seqIndices$1","sosType","eosType","si","i$8","prevType","sj","si$1","i$9","sj$1","prevCharType","si$2","i$10","si$3","i$11","prevType$1","nextType","sj$2","sj$3","si$4","i$12","sj$4","sj$5","si$5","i$13","sj$6","sj$7","si$6","prevStrongType","i$14","R_TYPES_FOR_N_STEPS","STRONG_TYPES_FOR_N_STEPS","bracketPairs","openerStack","si$7","oppositeBracket","seqIndex","stackIdx","stackChar","sort","pairIdx","ref$1","openSeqIdx","closeSeqIdx","foundStrongType","useStrongType","si$8","i$15","lr","getEmbedDirection","si$9","i$16","lr$1","si$10","si$11","si$12","niRunStart","niRunEnd","prevType$2","si2","nextType$1","si2$1","sj$8","i$17","level$3","type$1","j$1","levels","isFSI","pdi","indexOfMatchingPDI","isolateStart","isolationLevel","data","mirrorMap","parse","value","key","getMirroredCharacter","getMirroredCharactersMap","embeddingLevels","strLen","min","mirror","getReorderSegments","embeddingLevelsResult","segments","lineStart","lineEnd","lineLevels","slice","maxLevel","minOddLevel","Infinity","segStart","getReorderedString","embedLevelsResult","indices","getReorderedIndices","chars","concat","charIndex","join","defineProperty"],"mappings":"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","sourcesContent":["function bidiFactory() {\nvar bidi = (function (exports) {\n\n  // Bidi character types data, auto generated\n  var DATA = {\n    \"R\": \"13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73\",\n    \"EN\": \"1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9\",\n    \"ES\": \"17,2,6dp+1,f+1,av,16vr,mx+1,4o,2\",\n    \"ET\": \"z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj\",\n    \"AN\": \"16o+5,2j+9,2+1,35,ed,1ff2+9,87+u\",\n    \"CS\": \"18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b\",\n    \"B\": \"a,3,f+2,2v,690\",\n    \"S\": \"9,2,k\",\n    \"WS\": \"c,k,4f4,1vk+a,u,1j,335\",\n    \"ON\": \"x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i\",\n    \"BN\": \"0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1\",\n    \"NSM\": \"lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n\",\n    \"AL\": \"16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d\",\n    \"LRO\": \"6ct\",\n    \"RLO\": \"6cu\",\n    \"LRE\": \"6cq\",\n    \"RLE\": \"6cr\",\n    \"PDF\": \"6cs\",\n    \"LRI\": \"6ee\",\n    \"RLI\": \"6ef\",\n    \"FSI\": \"6eg\",\n    \"PDI\": \"6eh\"\n  };\n\n  var TYPES = {};\n  var TYPES_TO_NAMES = {};\n  TYPES.L = 1; //L is the default\n  TYPES_TO_NAMES[1] = 'L';\n  Object.keys(DATA).forEach(function (type, i) {\n    TYPES[type] = 1 << (i + 1);\n    TYPES_TO_NAMES[TYPES[type]] = type;\n  });\n  Object.freeze(TYPES);\n\n  var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;\n  var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;\n  var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;\n  var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;\n  var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;\n\n  var map = null;\n\n  function parseData () {\n    if (!map) {\n      //const start = performance.now()\n      map = new Map();\n      var loop = function ( type ) {\n        if (DATA.hasOwnProperty(type)) {\n          var lastCode = 0;\n          DATA[type].split(',').forEach(function (range) {\n            var ref = range.split('+');\n            var skip = ref[0];\n            var step = ref[1];\n            skip = parseInt(skip, 36);\n            step = step ? parseInt(step, 36) : 0;\n            map.set(lastCode += skip, TYPES[type]);\n            for (var i = 0; i < step; i++) {\n              map.set(++lastCode, TYPES[type]);\n            }\n          });\n        }\n      };\n\n      for (var type in DATA) loop( type );\n      //console.log(`char types parsed in ${performance.now() - start}ms`)\n    }\n  }\n\n  /**\n   * @param {string} char\n   * @return {number}\n   */\n  function getBidiCharType (char) {\n    parseData();\n    return map.get(char.codePointAt(0)) || TYPES.L\n  }\n\n  function getBidiCharTypeName(char) {\n    return TYPES_TO_NAMES[getBidiCharType(char)]\n  }\n\n  // Bidi bracket pairs data, auto generated\n  var data$1 = {\n    \"pairs\": \"14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1\",\n    \"canonical\": \"6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye\"\n  };\n\n  /**\n   * Parses an string that holds encoded codepoint mappings, e.g. for bracket pairs or\n   * mirroring characters, as encoded by scripts/generateBidiData.js. Returns an object\n   * holding the `map`, and optionally a `reverseMap` if `includeReverse:true`.\n   * @param {string} encodedString\n   * @param {boolean} includeReverse - true if you want reverseMap in the output\n   * @return {{map: Map<number, number>, reverseMap?: Map<number, number>}}\n   */\n  function parseCharacterMap (encodedString, includeReverse) {\n    var radix = 36;\n    var lastCode = 0;\n    var map = new Map();\n    var reverseMap = includeReverse && new Map();\n    var prevPair;\n    encodedString.split(',').forEach(function visit(entry) {\n      if (entry.indexOf('+') !== -1) {\n        for (var i = +entry; i--;) {\n          visit(prevPair);\n        }\n      } else {\n        prevPair = entry;\n        var ref = entry.split('>');\n        var a = ref[0];\n        var b = ref[1];\n        a = String.fromCodePoint(lastCode += parseInt(a, radix));\n        b = String.fromCodePoint(lastCode += parseInt(b, radix));\n        map.set(a, b);\n        includeReverse && reverseMap.set(b, a);\n      }\n    });\n    return { map: map, reverseMap: reverseMap }\n  }\n\n  var openToClose, closeToOpen, canonical;\n\n  function parse$1 () {\n    if (!openToClose) {\n      //const start = performance.now()\n      var ref = parseCharacterMap(data$1.pairs, true);\n      var map = ref.map;\n      var reverseMap = ref.reverseMap;\n      openToClose = map;\n      closeToOpen = reverseMap;\n      canonical = parseCharacterMap(data$1.canonical, false).map;\n      //console.log(`brackets parsed in ${performance.now() - start}ms`)\n    }\n  }\n\n  function openingToClosingBracket (char) {\n    parse$1();\n    return openToClose.get(char) || null\n  }\n\n  function closingToOpeningBracket (char) {\n    parse$1();\n    return closeToOpen.get(char) || null\n  }\n\n  function getCanonicalBracket (char) {\n    parse$1();\n    return canonical.get(char) || null\n  }\n\n  // Local type aliases\n  var TYPE_L = TYPES.L;\n  var TYPE_R = TYPES.R;\n  var TYPE_EN = TYPES.EN;\n  var TYPE_ES = TYPES.ES;\n  var TYPE_ET = TYPES.ET;\n  var TYPE_AN = TYPES.AN;\n  var TYPE_CS = TYPES.CS;\n  var TYPE_B = TYPES.B;\n  var TYPE_S = TYPES.S;\n  var TYPE_ON = TYPES.ON;\n  var TYPE_BN = TYPES.BN;\n  var TYPE_NSM = TYPES.NSM;\n  var TYPE_AL = TYPES.AL;\n  var TYPE_LRO = TYPES.LRO;\n  var TYPE_RLO = TYPES.RLO;\n  var TYPE_LRE = TYPES.LRE;\n  var TYPE_RLE = TYPES.RLE;\n  var TYPE_PDF = TYPES.PDF;\n  var TYPE_LRI = TYPES.LRI;\n  var TYPE_RLI = TYPES.RLI;\n  var TYPE_FSI = TYPES.FSI;\n  var TYPE_PDI = TYPES.PDI;\n\n  /**\n   * @typedef {object} GetEmbeddingLevelsResult\n   * @property {{start, end, level}[]} paragraphs\n   * @property {Uint8Array} levels\n   */\n\n  /**\n   * This function applies the Bidirectional Algorithm to a string, returning the resolved embedding levels\n   * in a single Uint8Array plus a list of objects holding each paragraph's start and end indices and resolved\n   * base embedding level.\n   *\n   * @param {string} string - The input string\n   * @param {\"ltr\"|\"rtl\"|\"auto\"} [baseDirection] - Use \"ltr\" or \"rtl\" to force a base paragraph direction,\n   *        otherwise a direction will be chosen automatically from each paragraph's contents.\n   * @return {GetEmbeddingLevelsResult}\n   */\n  function getEmbeddingLevels (string, baseDirection) {\n    var MAX_DEPTH = 125;\n\n    // Start by mapping all characters to their unicode type, as a bitmask integer\n    var charTypes = new Uint32Array(string.length);\n    for (var i = 0; i < string.length; i++) {\n      charTypes[i] = getBidiCharType(string[i]);\n    }\n\n    var charTypeCounts = new Map(); //will be cleared at start of each paragraph\n    function changeCharType(i, type) {\n      var oldType = charTypes[i];\n      charTypes[i] = type;\n      charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);\n      if (oldType & NEUTRAL_ISOLATE_TYPES) {\n        charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);\n      }\n      charTypeCounts.set(type, (charTypeCounts.get(type) || 0) + 1);\n      if (type & NEUTRAL_ISOLATE_TYPES) {\n        charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n      }\n    }\n\n    var embedLevels = new Uint8Array(string.length);\n    var isolationPairs = new Map(); //init->pdi and pdi->init\n\n    // === 3.3.1 The Paragraph Level ===\n    // 3.3.1 P1: Split the text into paragraphs\n    var paragraphs = []; // [{start, end, level}, ...]\n    var paragraph = null;\n    for (var i$1 = 0; i$1 < string.length; i$1++) {\n      if (!paragraph) {\n        paragraphs.push(paragraph = {\n          start: i$1,\n          end: string.length - 1,\n          // 3.3.1 P2-P3: Determine the paragraph level\n          level: baseDirection === 'rtl' ? 1 : baseDirection === 'ltr' ? 0 : determineAutoEmbedLevel(i$1, false)\n        });\n      }\n      if (charTypes[i$1] & TYPE_B) {\n        paragraph.end = i$1;\n        paragraph = null;\n      }\n    }\n\n    var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;\n    var nextEven = function (n) { return n + ((n & 1) ? 1 : 2); };\n    var nextOdd = function (n) { return n + ((n & 1) ? 2 : 1); };\n\n    // Everything from here on will operate per paragraph.\n    for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {\n      paragraph = paragraphs[paraIdx];\n      var statusStack = [{\n        _level: paragraph.level,\n        _override: 0, //0=neutral, 1=L, 2=R\n        _isolate: 0 //bool\n      }];\n      var stackTop = (void 0);\n      var overflowIsolateCount = 0;\n      var overflowEmbeddingCount = 0;\n      var validIsolateCount = 0;\n      charTypeCounts.clear();\n\n      // === 3.3.2 Explicit Levels and Directions ===\n      for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {\n        var charType = charTypes[i$2];\n        stackTop = statusStack[statusStack.length - 1];\n\n        // Set initial counts\n        charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);\n        if (charType & NEUTRAL_ISOLATE_TYPES) {\n          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n        }\n\n        // Explicit Embeddings: 3.3.2 X2 - X3\n        if (charType & FORMATTING_TYPES) { //prefilter all formatters\n          if (charType & (TYPE_RLE | TYPE_LRE)) {\n            embedLevels[i$2] = stackTop._level; // 5.2\n            var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);\n            if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n              statusStack.push({\n                _level: level,\n                _override: 0,\n                _isolate: 0\n              });\n            } else if (!overflowIsolateCount) {\n              overflowEmbeddingCount++;\n            }\n          }\n\n          // Explicit Overrides: 3.3.2 X4 - X5\n          else if (charType & (TYPE_RLO | TYPE_LRO)) {\n            embedLevels[i$2] = stackTop._level; // 5.2\n            var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);\n            if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n              statusStack.push({\n                _level: level$1,\n                _override: (charType & TYPE_RLO) ? TYPE_R : TYPE_L,\n                _isolate: 0\n              });\n            } else if (!overflowIsolateCount) {\n              overflowEmbeddingCount++;\n            }\n          }\n\n          // Isolates: 3.3.2 X5a - X5c\n          else if (charType & ISOLATE_INIT_TYPES) {\n            // X5c - FSI becomes either RLI or LRI\n            if (charType & TYPE_FSI) {\n              charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;\n            }\n\n            embedLevels[i$2] = stackTop._level;\n            if (stackTop._override) {\n              changeCharType(i$2, stackTop._override);\n            }\n            var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);\n            if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {\n              validIsolateCount++;\n              statusStack.push({\n                _level: level$2,\n                _override: 0,\n                _isolate: 1,\n                _isolInitIndex: i$2\n              });\n            } else {\n              overflowIsolateCount++;\n            }\n          }\n\n          // Terminating Isolates: 3.3.2 X6a\n          else if (charType & TYPE_PDI) {\n            if (overflowIsolateCount > 0) {\n              overflowIsolateCount--;\n            } else if (validIsolateCount > 0) {\n              overflowEmbeddingCount = 0;\n              while (!statusStack[statusStack.length - 1]._isolate) {\n                statusStack.pop();\n              }\n              // Add to isolation pairs bidirectional mapping:\n              var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;\n              if (isolInitIndex != null) {\n                isolationPairs.set(isolInitIndex, i$2);\n                isolationPairs.set(i$2, isolInitIndex);\n              }\n              statusStack.pop();\n              validIsolateCount--;\n            }\n            stackTop = statusStack[statusStack.length - 1];\n            embedLevels[i$2] = stackTop._level;\n            if (stackTop._override) {\n              changeCharType(i$2, stackTop._override);\n            }\n          }\n\n\n          // Terminating Embeddings and Overrides: 3.3.2 X7\n          else if (charType & TYPE_PDF) {\n            if (overflowIsolateCount === 0) {\n              if (overflowEmbeddingCount > 0) {\n                overflowEmbeddingCount--;\n              } else if (!stackTop._isolate && statusStack.length > 1) {\n                statusStack.pop();\n                stackTop = statusStack[statusStack.length - 1];\n              }\n            }\n            embedLevels[i$2] = stackTop._level; // 5.2\n          }\n\n          // End of Paragraph: 3.3.2 X8\n          else if (charType & TYPE_B) {\n            embedLevels[i$2] = paragraph.level;\n          }\n        }\n\n        // Non-formatting characters: 3.3.2 X6\n        else {\n          embedLevels[i$2] = stackTop._level;\n          // NOTE: This exclusion of BN seems to go against what section 5.2 says, but is required for test passage\n          if (stackTop._override && charType !== TYPE_BN) {\n            changeCharType(i$2, stackTop._override);\n          }\n        }\n      }\n\n      // === 3.3.3 Preparations for Implicit Processing ===\n\n      // Remove all RLE, LRE, RLO, LRO, PDF, and BN characters: 3.3.3 X9\n      // Note: Due to section 5.2, we won't remove them, but we'll use the BN_LIKE_TYPES bitset to\n      // easily ignore them all from here on out.\n\n      // 3.3.3 X10\n      // Compute the set of isolating run sequences as specified by BD13\n      var levelRuns = [];\n      var currentRun = null;\n      for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {\n        var charType$1 = charTypes[i$3];\n        if (!(charType$1 & BN_LIKE_TYPES)) {\n          var lvl = embedLevels[i$3];\n          var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;\n          var isPDI = charType$1 === TYPE_PDI;\n          if (currentRun && lvl === currentRun._level) {\n            currentRun._end = i$3;\n            currentRun._endsWithIsolInit = isIsolInit;\n          } else {\n            levelRuns.push(currentRun = {\n              _start: i$3,\n              _end: i$3,\n              _level: lvl,\n              _startsWithPDI: isPDI,\n              _endsWithIsolInit: isIsolInit\n            });\n          }\n        }\n      }\n      var isolatingRunSeqs = []; // [{seqIndices: [], sosType: L|R, eosType: L|R}]\n      for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {\n        var run = levelRuns[runIdx];\n        if (!run._startsWithPDI || (run._startsWithPDI && !isolationPairs.has(run._start))) {\n          var seqRuns = [currentRun = run];\n          for (var pdiIndex = (void 0); currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null;) {\n            for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {\n              if (levelRuns[i$4]._start === pdiIndex) {\n                seqRuns.push(currentRun = levelRuns[i$4]);\n                break\n              }\n            }\n          }\n          // build flat list of indices across all runs:\n          var seqIndices = [];\n          for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {\n            var run$1 = seqRuns[i$5];\n            for (var j = run$1._start; j <= run$1._end; j++) {\n              seqIndices.push(j);\n            }\n          }\n          // determine the sos/eos types:\n          var firstLevel = embedLevels[seqIndices[0]];\n          var prevLevel = paragraph.level;\n          for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {\n            if (!(charTypes[i$6] & BN_LIKE_TYPES)) { //5.2\n              prevLevel = embedLevels[i$6];\n              break\n            }\n          }\n          var lastIndex = seqIndices[seqIndices.length - 1];\n          var lastLevel = embedLevels[lastIndex];\n          var nextLevel = paragraph.level;\n          if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {\n            for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {\n              if (!(charTypes[i$7] & BN_LIKE_TYPES)) { //5.2\n                nextLevel = embedLevels[i$7];\n                break\n              }\n            }\n          }\n          isolatingRunSeqs.push({\n            _seqIndices: seqIndices,\n            _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,\n            _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L\n          });\n        }\n      }\n\n      // The next steps are done per isolating run sequence\n      for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {\n        var ref = isolatingRunSeqs[seqIdx];\n        var seqIndices$1 = ref._seqIndices;\n        var sosType = ref._sosType;\n        var eosType = ref._eosType;\n\n        // === 3.3.4 Resolving Weak Types ===\n\n        // W1 + 5.2. Search backward from each NSM to the first character in the isolating run sequence whose\n        // bidirectional type is not BN, and set the NSM to ON if it is an isolate initiator or PDI, and to its\n        // type otherwise. If the NSM is the first non-BN character, change the NSM to the type of sos.\n        if (charTypeCounts.get(TYPE_NSM)) {\n          for (var si = 0; si < seqIndices$1.length; si++) {\n            var i$8 = seqIndices$1[si];\n            if (charTypes[i$8] & TYPE_NSM) {\n              var prevType = sosType;\n              for (var sj = si - 1; sj >= 0; sj--) {\n                if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) { //5.2 scan back to first non-BN\n                  prevType = charTypes[seqIndices$1[sj]];\n                  break\n                }\n              }\n              changeCharType(i$8, (prevType & (ISOLATE_INIT_TYPES | TYPE_PDI)) ? TYPE_ON : prevType);\n            }\n          }\n        }\n\n        // W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sos)\n        // is found. If an AL is found, change the type of the European number to Arabic number.\n        if (charTypeCounts.get(TYPE_EN)) {\n          for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {\n            var i$9 = seqIndices$1[si$1];\n            if (charTypes[i$9] & TYPE_EN) {\n              for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {\n                var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];\n                if (prevCharType & STRONG_TYPES) {\n                  if (prevCharType === TYPE_AL) {\n                    changeCharType(i$9, TYPE_AN);\n                  }\n                  break\n                }\n              }\n            }\n          }\n        }\n\n        // W3. Change all ALs to R\n        if (charTypeCounts.get(TYPE_AL)) {\n          for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {\n            var i$10 = seqIndices$1[si$2];\n            if (charTypes[i$10] & TYPE_AL) {\n              changeCharType(i$10, TYPE_R);\n            }\n          }\n        }\n\n        // W4. A single European separator between two European numbers changes to a European number. A single common\n        // separator between two numbers of the same type changes to that type.\n        if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n          for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {\n            var i$11 = seqIndices$1[si$3];\n            if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {\n              var prevType$1 = 0, nextType = 0;\n              for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {\n                prevType$1 = charTypes[seqIndices$1[sj$2]];\n                if (!(prevType$1 & BN_LIKE_TYPES)) { //5.2\n                  break\n                }\n              }\n              for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {\n                nextType = charTypes[seqIndices$1[sj$3]];\n                if (!(nextType & BN_LIKE_TYPES)) { //5.2\n                  break\n                }\n              }\n              if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : (prevType$1 & (TYPE_EN | TYPE_AN)))) {\n                changeCharType(i$11, prevType$1);\n              }\n            }\n          }\n        }\n\n        // W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.\n        if (charTypeCounts.get(TYPE_EN)) {\n          for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {\n            var i$12 = seqIndices$1[si$4];\n            if (charTypes[i$12] & TYPE_EN) {\n              for (var sj$4 = si$4 - 1; sj$4 >= 0 && (charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES)); sj$4--) {\n                changeCharType(seqIndices$1[sj$4], TYPE_EN);\n              }\n              for (var sj$5 = si$4 + 1; sj$5 < seqIndices$1.length && (charTypes[seqIndices$1[sj$5]] & (TYPE_ET | BN_LIKE_TYPES)); sj$5++) {\n                changeCharType(seqIndices$1[sj$5], TYPE_EN);\n              }\n            }\n          }\n        }\n\n        // W6. Otherwise, separators and terminators change to Other Neutral.\n        if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n          for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {\n            var i$13 = seqIndices$1[si$5];\n            if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {\n              changeCharType(i$13, TYPE_ON);\n              // 5.2 transform adjacent BNs too:\n              for (var sj$6 = si$5 - 1; sj$6 >= 0 && (charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES); sj$6--) {\n                changeCharType(seqIndices$1[sj$6], TYPE_ON);\n              }\n              for (var sj$7 = si$5 + 1; sj$7 < seqIndices$1.length && (charTypes[seqIndices$1[sj$7]] & BN_LIKE_TYPES); sj$7++) {\n                changeCharType(seqIndices$1[sj$7], TYPE_ON);\n              }\n            }\n          }\n        }\n\n        // W7. Search backward from each instance of a European number until the first strong type (R, L, or sos)\n        // is found. If an L is found, then change the type of the European number to L.\n        // NOTE: implemented in single forward pass for efficiency\n        if (charTypeCounts.get(TYPE_EN)) {\n          for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {\n            var i$14 = seqIndices$1[si$6];\n            var type = charTypes[i$14];\n            if (type & TYPE_EN) {\n              if (prevStrongType === TYPE_L) {\n                changeCharType(i$14, TYPE_L);\n              }\n            } else if (type & STRONG_TYPES) {\n              prevStrongType = type;\n            }\n          }\n        }\n\n        // === 3.3.5 Resolving Neutral and Isolate Formatting Types ===\n\n        if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {\n          // N0. Process bracket pairs in an isolating run sequence sequentially in the logical order of the text\n          // positions of the opening paired brackets using the logic given below. Within this scope, bidirectional\n          // types EN and AN are treated as R.\n          var R_TYPES_FOR_N_STEPS = (TYPE_R | TYPE_EN | TYPE_AN);\n          var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;\n\n          // * Identify the bracket pairs in the current isolating run sequence according to BD16.\n          var bracketPairs = [];\n          {\n            var openerStack = [];\n            for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {\n              // NOTE: for any potential bracket character we also test that it still carries a NI\n              // type, as that may have been changed earlier. This doesn't seem to be explicitly\n              // called out in the spec, but is required for passage of certain tests.\n              if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {\n                var char = string[seqIndices$1[si$7]];\n                var oppositeBracket = (void 0);\n                // Opening bracket\n                if (openingToClosingBracket(char) !== null) {\n                  if (openerStack.length < 63) {\n                    openerStack.push({ char: char, seqIndex: si$7 });\n                  } else {\n                    break\n                  }\n                }\n                // Closing bracket\n                else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {\n                  for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {\n                    var stackChar = openerStack[stackIdx].char;\n                    if (stackChar === oppositeBracket ||\n                      stackChar === closingToOpeningBracket(getCanonicalBracket(char)) ||\n                      openingToClosingBracket(getCanonicalBracket(stackChar)) === char\n                    ) {\n                      bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);\n                      openerStack.length = stackIdx; //pop the matching bracket and all following\n                      break\n                    }\n                  }\n                }\n              }\n            }\n            bracketPairs.sort(function (a, b) { return a[0] - b[0]; });\n          }\n          // * For each bracket-pair element in the list of pairs of text positions\n          for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {\n            var ref$1 = bracketPairs[pairIdx];\n            var openSeqIdx = ref$1[0];\n            var closeSeqIdx = ref$1[1];\n            // a. Inspect the bidirectional types of the characters enclosed within the bracket pair.\n            // b. If any strong type (either L or R) matching the embedding direction is found, set the type for both\n            // brackets in the pair to match the embedding direction.\n            var foundStrongType = false;\n            var useStrongType = 0;\n            for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {\n              var i$15 = seqIndices$1[si$8];\n              if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {\n                foundStrongType = true;\n                var lr = (charTypes[i$15] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                if (lr === getEmbedDirection(i$15)) {\n                  useStrongType = lr;\n                  break\n                }\n              }\n            }\n            // c. Otherwise, if there is a strong type it must be opposite the embedding direction. Therefore, test\n            // for an established context with a preceding strong type by checking backwards before the opening paired\n            // bracket until the first strong type (L, R, or sos) is found.\n            //    1. If the preceding strong type is also opposite the embedding direction, context is established, so\n            //    set the type for both brackets in the pair to that direction.\n            //    2. Otherwise set the type for both brackets in the pair to the embedding direction.\n            if (foundStrongType && !useStrongType) {\n              useStrongType = sosType;\n              for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {\n                var i$16 = seqIndices$1[si$9];\n                if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {\n                  var lr$1 = (charTypes[i$16] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                  if (lr$1 !== getEmbedDirection(i$16)) {\n                    useStrongType = lr$1;\n                  } else {\n                    useStrongType = getEmbedDirection(i$16);\n                  }\n                  break\n                }\n              }\n            }\n            if (useStrongType) {\n              charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;\n              // * Any number of characters that had original bidirectional character type NSM prior to the application\n              // of W1 that immediately follow a paired bracket which changed to L or R under N0 should change to match\n              // the type of their preceding bracket.\n              if (useStrongType !== getEmbedDirection(seqIndices$1[openSeqIdx])) {\n                for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {\n                  if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {\n                    if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {\n                      charTypes[seqIndices$1[si$10]] = useStrongType;\n                    }\n                    break\n                  }\n                }\n              }\n              if (useStrongType !== getEmbedDirection(seqIndices$1[closeSeqIdx])) {\n                for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {\n                  if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {\n                    if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {\n                      charTypes[seqIndices$1[si$11]] = useStrongType;\n                    }\n                    break\n                  }\n                }\n              }\n            }\n          }\n\n          // N1. A sequence of NIs takes the direction of the surrounding strong text if the text on both sides has the\n          // same direction.\n          // N2. Any remaining NIs take the embedding direction.\n          for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {\n            if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {\n              var niRunStart = si$12, niRunEnd = si$12;\n              var prevType$2 = sosType; //si === 0 ? sosType : (charTypes[seqIndices[si - 1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L\n              for (var si2 = si$12 - 1; si2 >= 0; si2--) {\n                if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {\n                  niRunStart = si2; //5.2 treat BNs adjacent to NIs as NIs\n                } else {\n                  prevType$2 = (charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                  break\n                }\n              }\n              var nextType$1 = eosType;\n              for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {\n                if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {\n                  niRunEnd = si2$1;\n                } else {\n                  nextType$1 = (charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                  break\n                }\n              }\n              for (var sj$8 = niRunStart; sj$8 <= niRunEnd; sj$8++) {\n                charTypes[seqIndices$1[sj$8]] = prevType$2 === nextType$1 ? prevType$2 : getEmbedDirection(seqIndices$1[sj$8]);\n              }\n              si$12 = niRunEnd;\n            }\n          }\n        }\n      }\n\n      // === 3.3.6 Resolving Implicit Levels ===\n\n      for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {\n        var level$3 = embedLevels[i$17];\n        var type$1 = charTypes[i$17];\n        // I2. For all characters with an odd (right-to-left) embedding level, those of type L, EN or AN go up one level.\n        if (level$3 & 1) {\n          if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {\n            embedLevels[i$17]++;\n          }\n        }\n          // I1. For all characters with an even (left-to-right) embedding level, those of type R go up one level\n        // and those of type AN or EN go up two levels.\n        else {\n          if (type$1 & TYPE_R) {\n            embedLevels[i$17]++;\n          } else if (type$1 & (TYPE_AN | TYPE_EN)) {\n            embedLevels[i$17] += 2;\n          }\n        }\n\n        // 5.2: Resolve any LRE, RLE, LRO, RLO, PDF, or BN to the level of the preceding character if there is one,\n        // and otherwise to the base level.\n        if (type$1 & BN_LIKE_TYPES) {\n          embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];\n        }\n\n        // 3.4 L1.1-4: Reset the embedding level of segment/paragraph separators, and any sequence of whitespace or\n        // isolate formatting characters preceding them or the end of the paragraph, to the paragraph level.\n        // NOTE: this will also need to be applied to each individual line ending after line wrapping occurs.\n        if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {\n          for (var j$1 = i$17; j$1 >= 0 && (getBidiCharType(string[j$1]) & TRAILING_TYPES); j$1--) {\n            embedLevels[j$1] = paragraph.level;\n          }\n        }\n      }\n    }\n\n    // DONE! The resolved levels can then be used, after line wrapping, to flip runs of characters\n    // according to section 3.4 Reordering Resolved Levels\n    return {\n      levels: embedLevels,\n      paragraphs: paragraphs\n    }\n\n    function determineAutoEmbedLevel (start, isFSI) {\n      // 3.3.1 P2 - P3\n      for (var i = start; i < string.length; i++) {\n        var charType = charTypes[i];\n        if (charType & (TYPE_R | TYPE_AL)) {\n          return 1\n        }\n        if ((charType & (TYPE_B | TYPE_L)) || (isFSI && charType === TYPE_PDI)) {\n          return 0\n        }\n        if (charType & ISOLATE_INIT_TYPES) {\n          var pdi = indexOfMatchingPDI(i);\n          i = pdi === -1 ? string.length : pdi;\n        }\n      }\n      return 0\n    }\n\n    function indexOfMatchingPDI (isolateStart) {\n      // 3.1.2 BD9\n      var isolationLevel = 1;\n      for (var i = isolateStart + 1; i < string.length; i++) {\n        var charType = charTypes[i];\n        if (charType & TYPE_B) {\n          break\n        }\n        if (charType & TYPE_PDI) {\n          if (--isolationLevel === 0) {\n            return i\n          }\n        } else if (charType & ISOLATE_INIT_TYPES) {\n          isolationLevel++;\n        }\n      }\n      return -1\n    }\n\n    function getEmbedDirection (i) {\n      return (embedLevels[i] & 1) ? TYPE_R : TYPE_L\n    }\n\n  }\n\n  // Bidi mirrored chars data, auto generated\n  var data = \"14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1\";\n\n  var mirrorMap;\n\n  function parse () {\n    if (!mirrorMap) {\n      //const start = performance.now()\n      var ref = parseCharacterMap(data, true);\n      var map = ref.map;\n      var reverseMap = ref.reverseMap;\n      // Combine both maps into one\n      reverseMap.forEach(function (value, key) {\n        map.set(key, value);\n      });\n      mirrorMap = map;\n      //console.log(`mirrored chars parsed in ${performance.now() - start}ms`)\n    }\n  }\n\n  function getMirroredCharacter (char) {\n    parse();\n    return mirrorMap.get(char) || null\n  }\n\n  /**\n   * Given a string and its resolved embedding levels, build a map of indices to replacement chars\n   * for any characters in right-to-left segments that have defined mirrored characters.\n   * @param string\n   * @param embeddingLevels\n   * @param [start]\n   * @param [end]\n   * @return {Map<number, string>}\n   */\n  function getMirroredCharactersMap(string, embeddingLevels, start, end) {\n    var strLen = string.length;\n    start = Math.max(0, start == null ? 0 : +start);\n    end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n\n    var map = new Map();\n    for (var i = start; i <= end; i++) {\n      if (embeddingLevels[i] & 1) { //only odd (rtl) levels\n        var mirror = getMirroredCharacter(string[i]);\n        if (mirror !== null) {\n          map.set(i, mirror);\n        }\n      }\n    }\n    return map\n  }\n\n  /**\n   * Given a start and end denoting a single line within a string, and a set of precalculated\n   * bidi embedding levels, produce a list of segments whose ordering should be flipped, in sequence.\n   * @param {string} string - the full input string\n   * @param {GetEmbeddingLevelsResult} embeddingLevelsResult - the result object from getEmbeddingLevels\n   * @param {number} [start] - first character in a subset of the full string\n   * @param {number} [end] - last character in a subset of the full string\n   * @return {number[][]} - the list of start/end segments that should be flipped, in order.\n   */\n  function getReorderSegments(string, embeddingLevelsResult, start, end) {\n    var strLen = string.length;\n    start = Math.max(0, start == null ? 0 : +start);\n    end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n\n    var segments = [];\n    embeddingLevelsResult.paragraphs.forEach(function (paragraph) {\n      var lineStart = Math.max(start, paragraph.start);\n      var lineEnd = Math.min(end, paragraph.end);\n      if (lineStart < lineEnd) {\n        // Local slice for mutation\n        var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);\n\n        // 3.4 L1.4: Reset any sequence of whitespace characters and/or isolate formatting characters at the\n        // end of the line to the paragraph level.\n        for (var i = lineEnd; i >= lineStart && (getBidiCharType(string[i]) & TRAILING_TYPES); i--) {\n          lineLevels[i] = paragraph.level;\n        }\n\n        // L2. From the highest level found in the text to the lowest odd level on each line, including intermediate levels\n        // not actually present in the text, reverse any contiguous sequence of characters that are at that level or higher.\n        var maxLevel = paragraph.level;\n        var minOddLevel = Infinity;\n        for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {\n          var level = lineLevels[i$1];\n          if (level > maxLevel) { maxLevel = level; }\n          if (level < minOddLevel) { minOddLevel = level | 1; }\n        }\n        for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {\n          for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {\n            if (lineLevels[i$2] >= lvl) {\n              var segStart = i$2;\n              while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {\n                i$2++;\n              }\n              if (i$2 > segStart) {\n                segments.push([segStart + start, i$2 + start]);\n              }\n            }\n          }\n        }\n      }\n    });\n    return segments\n  }\n\n  /**\n   * @param {string} string\n   * @param {GetEmbeddingLevelsResult} embedLevelsResult\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {string} the new string with bidi segments reordered\n   */\n  function getReorderedString(string, embedLevelsResult, start, end) {\n    var indices = getReorderedIndices(string, embedLevelsResult, start, end);\n    var chars = [].concat( string );\n    indices.forEach(function (charIndex, i) {\n      chars[i] = (\n        (embedLevelsResult.levels[charIndex] & 1) ? getMirroredCharacter(string[charIndex]) : null\n      ) || string[charIndex];\n    });\n    return chars.join('')\n  }\n\n  /**\n   * @param {string} string\n   * @param {GetEmbeddingLevelsResult} embedLevelsResult\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {number[]} an array with character indices in their new bidi order\n   */\n  function getReorderedIndices(string, embedLevelsResult, start, end) {\n    var segments = getReorderSegments(string, embedLevelsResult, start, end);\n    // Fill an array with indices\n    var indices = [];\n    for (var i = 0; i < string.length; i++) {\n      indices[i] = i;\n    }\n    // Reverse each segment in order\n    segments.forEach(function (ref) {\n      var start = ref[0];\n      var end = ref[1];\n\n      var slice = indices.slice(start, end + 1);\n      for (var i = slice.length; i--;) {\n        indices[end - i] = slice[i];\n      }\n    });\n    return indices\n  }\n\n  exports.closingToOpeningBracket = closingToOpeningBracket;\n  exports.getBidiCharType = getBidiCharType;\n  exports.getBidiCharTypeName = getBidiCharTypeName;\n  exports.getCanonicalBracket = getCanonicalBracket;\n  exports.getEmbeddingLevels = getEmbeddingLevels;\n  exports.getMirroredCharacter = getMirroredCharacter;\n  exports.getMirroredCharactersMap = getMirroredCharactersMap;\n  exports.getReorderSegments = getReorderSegments;\n  exports.getReorderedIndices = getReorderedIndices;\n  exports.getReorderedString = getReorderedString;\n  exports.openingToClosingBracket = openingToClosingBracket;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n}({}));\nreturn bidi}\n\nexport default bidiFactory;\n"]},"metadata":{},"sourceType":"module"}