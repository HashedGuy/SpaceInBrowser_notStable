{"ast":null,"code":"import { cloneElement } from 'react';\nimport PropTypes from 'prop-types';\nexport default function Composer(props) {\n  return renderRecursive(props.children, props.components);\n}\nComposer.propTypes = {\n  children: PropTypes.func.isRequired,\n  components: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.element, PropTypes.func])).isRequired\n};\n/**\n * Recursively build up elements from props.components and accumulate `results` along the way.\n * @param {function} render\n * @param {Array.<ReactElement|Function>} remaining\n * @param {Array} [results]\n * @returns {ReactElement}\n */\n\nfunction renderRecursive(render, remaining, results) {\n  results = results || []; // Once components is exhausted, we can render out the results array.\n\n  if (!remaining[0]) {\n    return render(results);\n  } // Continue recursion for remaining items.\n  // results.concat([value]) ensures [...results, value] instead of [...results, ...value]\n\n\n  function nextRender(value) {\n    return renderRecursive(render, remaining.slice(1), results.concat([value]));\n  } // Each props.components entry is either an element or function [element factory]\n\n\n  return typeof remaining[0] === 'function' ? // When it is a function, produce an element by invoking it with \"render component values\".\n  remaining[0]({\n    results: results,\n    render: nextRender\n  }) : // When it is an element, enhance the element's props with the render prop.\n  cloneElement(remaining[0], {\n    children: nextRender\n  });\n}","map":{"version":3,"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/@react-three/drei/node_modules/react-composer/es/index.js"],"names":["cloneElement","PropTypes","Composer","props","renderRecursive","children","components","propTypes","func","isRequired","arrayOf","oneOfType","element","render","remaining","results","nextRender","value","slice","concat"],"mappings":"AAAA,SAASA,YAAT,QAA6B,OAA7B;AACA,OAAOC,SAAP,MAAsB,YAAtB;AAEA,eAAe,SAASC,QAAT,CAAkBC,KAAlB,EAAyB;AACtC,SAAOC,eAAe,CAACD,KAAK,CAACE,QAAP,EAAiBF,KAAK,CAACG,UAAvB,CAAtB;AACD;AAEDJ,QAAQ,CAACK,SAAT,GAAqB;AACnBF,EAAAA,QAAQ,EAAEJ,SAAS,CAACO,IAAV,CAAeC,UADN;AAEnBH,EAAAA,UAAU,EAAEL,SAAS,CAACS,OAAV,CAAkBT,SAAS,CAACU,SAAV,CAAoB,CAACV,SAAS,CAACW,OAAX,EAAoBX,SAAS,CAACO,IAA9B,CAApB,CAAlB,EAA4EC;AAFrE,CAArB;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASL,eAAT,CAAyBS,MAAzB,EAAiCC,SAAjC,EAA4CC,OAA5C,EAAqD;AACnDA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB,CADmD,CAEnD;;AACA,MAAI,CAACD,SAAS,CAAC,CAAD,CAAd,EAAmB;AACjB,WAAOD,MAAM,CAACE,OAAD,CAAb;AACD,GALkD,CAOnD;AACA;;;AACA,WAASC,UAAT,CAAoBC,KAApB,EAA2B;AACzB,WAAOb,eAAe,CAACS,MAAD,EAASC,SAAS,CAACI,KAAV,CAAgB,CAAhB,CAAT,EAA6BH,OAAO,CAACI,MAAR,CAAe,CAACF,KAAD,CAAf,CAA7B,CAAtB;AACD,GAXkD,CAanD;;;AACA,SAAO,OAAOH,SAAS,CAAC,CAAD,CAAhB,KAAwB,UAAxB,GAAqC;AAC5CA,EAAAA,SAAS,CAAC,CAAD,CAAT,CAAa;AAAEC,IAAAA,OAAO,EAAEA,OAAX;AAAoBF,IAAAA,MAAM,EAAEG;AAA5B,GAAb,CADO,GACkD;AACzDhB,EAAAA,YAAY,CAACc,SAAS,CAAC,CAAD,CAAV,EAAe;AAAET,IAAAA,QAAQ,EAAEW;AAAZ,GAAf,CAFZ;AAGD","sourcesContent":["import { cloneElement } from 'react';\nimport PropTypes from 'prop-types';\n\nexport default function Composer(props) {\n  return renderRecursive(props.children, props.components);\n}\n\nComposer.propTypes = {\n  children: PropTypes.func.isRequired,\n  components: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.element, PropTypes.func])).isRequired\n};\n\n/**\n * Recursively build up elements from props.components and accumulate `results` along the way.\n * @param {function} render\n * @param {Array.<ReactElement|Function>} remaining\n * @param {Array} [results]\n * @returns {ReactElement}\n */\nfunction renderRecursive(render, remaining, results) {\n  results = results || [];\n  // Once components is exhausted, we can render out the results array.\n  if (!remaining[0]) {\n    return render(results);\n  }\n\n  // Continue recursion for remaining items.\n  // results.concat([value]) ensures [...results, value] instead of [...results, ...value]\n  function nextRender(value) {\n    return renderRecursive(render, remaining.slice(1), results.concat([value]));\n  }\n\n  // Each props.components entry is either an element or function [element factory]\n  return typeof remaining[0] === 'function' ? // When it is a function, produce an element by invoking it with \"render component values\".\n  remaining[0]({ results: results, render: nextRender }) : // When it is an element, enhance the element's props with the render prop.\n  cloneElement(remaining[0], { children: nextRender });\n}"]},"metadata":{},"sourceType":"module"}