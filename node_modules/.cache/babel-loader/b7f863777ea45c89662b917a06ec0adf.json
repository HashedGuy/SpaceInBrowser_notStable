{"ast":null,"code":"import { Box3, Vector3 } from 'three';\nimport { TRAVERSAL_COST, TRIANGLE_INTERSECT_COST } from '../core/Constants.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\n\nvar _box1 = /* @__PURE__ */new Box3();\n\nvar _box2 = /* @__PURE__ */new Box3();\n\nvar _vec = /* @__PURE__ */new Vector3(); // https://stackoverflow.com/questions/1248302/how-to-get-the-size-of-a-javascript-object\n\n\nfunction getPrimitiveSize(el) {\n  switch (typeof el) {\n    case 'number':\n      return 8;\n\n    case 'string':\n      return el.length * 2;\n\n    case 'boolean':\n      return 4;\n\n    default:\n      return 0;\n  }\n}\n\nfunction isTypedArray(arr) {\n  var regex = /(Uint|Int|Float)(8|16|32)Array/;\n  return regex.test(arr.constructor.name);\n}\n\nfunction getRootExtremes(bvh, group) {\n  var result = {\n    nodeCount: 0,\n    leafNodeCount: 0,\n    depth: {\n      min: Infinity,\n      max: -Infinity\n    },\n    tris: {\n      min: Infinity,\n      max: -Infinity\n    },\n    splits: [0, 0, 0],\n    surfaceAreaScore: 0\n  };\n  bvh.traverse(function (depth, isLeaf, boundingData, offsetOrSplit, count) {\n    var l0 = boundingData[0 + 3] - boundingData[0];\n    var l1 = boundingData[1 + 3] - boundingData[1];\n    var l2 = boundingData[2 + 3] - boundingData[2];\n    var surfaceArea = 2 * (l0 * l1 + l1 * l2 + l2 * l0);\n    result.nodeCount++;\n\n    if (isLeaf) {\n      result.leafNodeCount++;\n      result.depth.min = Math.min(depth, result.depth.min);\n      result.depth.max = Math.max(depth, result.depth.max);\n      result.tris.min = Math.min(count, result.tris.min);\n      result.tris.max = Math.max(count, result.tris.max);\n      result.surfaceAreaScore += surfaceArea * TRIANGLE_INTERSECT_COST * count;\n    } else {\n      result.splits[offsetOrSplit]++;\n      result.surfaceAreaScore += surfaceArea * TRAVERSAL_COST;\n    }\n  }, group); // If there are no leaf nodes because the tree hasn't finished generating yet.\n\n  if (result.tris.min === Infinity) {\n    result.tris.min = 0;\n    result.tris.max = 0;\n  }\n\n  if (result.depth.min === Infinity) {\n    result.depth.min = 0;\n    result.depth.max = 0;\n  }\n\n  return result;\n}\n\nfunction getBVHExtremes(bvh) {\n  return bvh._roots.map(function (root, i) {\n    return getRootExtremes(bvh, i);\n  });\n}\n\nfunction estimateMemoryInBytes(obj) {\n  var traversed = new Set();\n  var stack = [obj];\n  var bytes = 0;\n\n  while (stack.length) {\n    var curr = stack.pop();\n\n    if (traversed.has(curr)) {\n      continue;\n    }\n\n    traversed.add(curr);\n\n    for (var key in curr) {\n      if (!curr.hasOwnProperty(key)) {\n        continue;\n      }\n\n      bytes += getPrimitiveSize(key);\n      var value = curr[key];\n\n      if (value && (typeof value === 'object' || typeof value === 'function')) {\n        if (isTypedArray(value)) {\n          bytes += value.byteLength;\n        } else if (value instanceof ArrayBuffer) {\n          bytes += value.byteLength;\n        } else {\n          stack.push(value);\n        }\n      } else {\n        bytes += getPrimitiveSize(value);\n      }\n    }\n  }\n\n  return bytes;\n}\n\nfunction validateBounds(bvh) {\n  var geometry = bvh.geometry;\n  var depthStack = [];\n  var index = geometry.index;\n  var position = geometry.getAttribute('position');\n  var passes = true;\n  bvh.traverse(function (depth, isLeaf, boundingData, offset, count) {\n    var info = {\n      depth: depth,\n      isLeaf: isLeaf,\n      boundingData: boundingData,\n      offset: offset,\n      count: count\n    };\n    depthStack[depth] = info;\n    arrayToBox(0, boundingData, _box1);\n    var parent = depthStack[depth - 1];\n\n    if (isLeaf) {\n      // check triangles\n      for (var i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n        var i0 = index.getX(i);\n        var i1 = index.getX(i + 1);\n        var i2 = index.getX(i + 2);\n        var isContained = void 0;\n\n        _vec.fromBufferAttribute(position, i0);\n\n        isContained = _box1.containsPoint(_vec);\n\n        _vec.fromBufferAttribute(position, i1);\n\n        isContained = isContained && _box1.containsPoint(_vec);\n\n        _vec.fromBufferAttribute(position, i2);\n\n        isContained = isContained && _box1.containsPoint(_vec);\n        console.assert(isContained, 'Leaf bounds does not fully contain triangle.');\n        passes = passes && isContained;\n      }\n    }\n\n    if (parent) {\n      // check if my bounds fit in my parents\n      arrayToBox(0, boundingData, _box2);\n\n      var _isContained = _box2.containsBox(_box1);\n\n      console.assert(_isContained, 'Parent bounds does not fully contain child.');\n      passes = passes && _isContained;\n    }\n  });\n  return passes;\n} // Returns a simple, human readable object that represents the BVH.\n\n\nfunction getJSONStructure(bvh) {\n  var depthStack = [];\n  bvh.traverse(function (depth, isLeaf, boundingData, offset, count) {\n    var info = {\n      bounds: arrayToBox(0, boundingData, new Box3())\n    };\n\n    if (isLeaf) {\n      info.count = count;\n      info.offset = offset;\n    } else {\n      info.left = null;\n      info.right = null;\n    }\n\n    depthStack[depth] = info; // traversal hits the left then right node\n\n    var parent = depthStack[depth - 1];\n\n    if (parent) {\n      if (parent.left === null) {\n        parent.left = info;\n      } else {\n        parent.right = info;\n      }\n    }\n  });\n  return depthStack[0];\n}\n\nexport { estimateMemoryInBytes, getBVHExtremes, validateBounds, getJSONStructure };","map":{"version":3,"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/three-mesh-bvh/src/debug/Debug.js"],"names":["Box3","Vector3","TRAVERSAL_COST","TRIANGLE_INTERSECT_COST","arrayToBox","_box1","_box2","_vec","getPrimitiveSize","el","length","isTypedArray","arr","regex","test","constructor","name","getRootExtremes","bvh","group","result","nodeCount","leafNodeCount","depth","min","Infinity","max","tris","splits","surfaceAreaScore","traverse","isLeaf","boundingData","offsetOrSplit","count","l0","l1","l2","surfaceArea","Math","getBVHExtremes","_roots","map","root","i","estimateMemoryInBytes","obj","traversed","Set","stack","bytes","curr","pop","has","add","key","hasOwnProperty","value","byteLength","ArrayBuffer","push","validateBounds","geometry","depthStack","index","position","getAttribute","passes","offset","info","parent","l","i0","getX","i1","i2","isContained","fromBufferAttribute","containsPoint","console","assert","containsBox","getJSONStructure","bounds","left","right"],"mappings":"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","sourcesContent":["import { Box3, Vector3 } from 'three';\r\nimport { TRAVERSAL_COST, TRIANGLE_INTERSECT_COST } from '../core/Constants.js';\r\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\r\n\r\nconst _box1 = /* @__PURE__ */ new Box3();\r\nconst _box2 = /* @__PURE__ */ new Box3();\r\nconst _vec = /* @__PURE__ */ new Vector3();\r\n\r\n// https://stackoverflow.com/questions/1248302/how-to-get-the-size-of-a-javascript-object\r\nfunction getPrimitiveSize( el ) {\r\n\r\n\tswitch ( typeof el ) {\r\n\r\n\t\tcase 'number':\r\n\t\t\treturn 8;\r\n\t\tcase 'string':\r\n\t\t\treturn el.length * 2;\r\n\t\tcase 'boolean':\r\n\t\t\treturn 4;\r\n\t\tdefault:\r\n\t\t\treturn 0;\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction isTypedArray( arr ) {\r\n\r\n\tconst regex = /(Uint|Int|Float)(8|16|32)Array/;\r\n\treturn regex.test( arr.constructor.name );\r\n\r\n}\r\n\r\nfunction getRootExtremes( bvh, group ) {\r\n\r\n\tconst result = {\r\n\t\tnodeCount: 0,\r\n\t\tleafNodeCount: 0,\r\n\r\n\t\tdepth: {\r\n\t\t\tmin: Infinity, max: - Infinity\r\n\t\t},\r\n\t\ttris: {\r\n\t\t\tmin: Infinity, max: - Infinity\r\n\t\t},\r\n\t\tsplits: [ 0, 0, 0 ],\r\n\t\tsurfaceAreaScore: 0,\r\n\t};\r\n\r\n\tbvh.traverse( ( depth, isLeaf, boundingData, offsetOrSplit, count ) => {\r\n\r\n\t\tconst l0 = boundingData[ 0 + 3 ] - boundingData[ 0 ];\r\n\t\tconst l1 = boundingData[ 1 + 3 ] - boundingData[ 1 ];\r\n\t\tconst l2 = boundingData[ 2 + 3 ] - boundingData[ 2 ];\r\n\r\n\t\tconst surfaceArea = 2 * ( l0 * l1 + l1 * l2 + l2 * l0 );\r\n\r\n\t\tresult.nodeCount ++;\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tresult.leafNodeCount ++;\r\n\r\n\t\t\tresult.depth.min = Math.min( depth, result.depth.min );\r\n\t\t\tresult.depth.max = Math.max( depth, result.depth.max );\r\n\r\n\t\t\tresult.tris.min = Math.min( count, result.tris.min );\r\n\t\t\tresult.tris.max = Math.max( count, result.tris.max );\r\n\r\n\t\t\tresult.surfaceAreaScore += surfaceArea * TRIANGLE_INTERSECT_COST * count;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tresult.splits[ offsetOrSplit ] ++;\r\n\r\n\t\t\tresult.surfaceAreaScore += surfaceArea * TRAVERSAL_COST;\r\n\r\n\t\t}\r\n\r\n\t}, group );\r\n\r\n\t// If there are no leaf nodes because the tree hasn't finished generating yet.\r\n\tif ( result.tris.min === Infinity ) {\r\n\r\n\t\tresult.tris.min = 0;\r\n\t\tresult.tris.max = 0;\r\n\r\n\t}\r\n\r\n\tif ( result.depth.min === Infinity ) {\r\n\r\n\t\tresult.depth.min = 0;\r\n\t\tresult.depth.max = 0;\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\nfunction getBVHExtremes( bvh ) {\r\n\r\n\treturn bvh._roots.map( ( root, i ) => getRootExtremes( bvh, i ) );\r\n\r\n}\r\n\r\nfunction estimateMemoryInBytes( obj ) {\r\n\r\n\tconst traversed = new Set();\r\n\tconst stack = [ obj ];\r\n\tlet bytes = 0;\r\n\r\n\twhile ( stack.length ) {\r\n\r\n\t\tconst curr = stack.pop();\r\n\t\tif ( traversed.has( curr ) ) {\r\n\r\n\t\t\tcontinue;\r\n\r\n\t\t}\r\n\r\n\t\ttraversed.add( curr );\r\n\r\n\t\tfor ( let key in curr ) {\r\n\r\n\t\t\tif ( ! curr.hasOwnProperty( key ) ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbytes += getPrimitiveSize( key );\r\n\r\n\t\t\tconst value = curr[ key ];\r\n\t\t\tif ( value && ( typeof value === 'object' || typeof value === 'function' ) ) {\r\n\r\n\t\t\t\tif ( isTypedArray( value ) ) {\r\n\r\n\t\t\t\t\tbytes += value.byteLength;\r\n\r\n\t\t\t\t} else if ( value instanceof ArrayBuffer ) {\r\n\r\n\t\t\t\t\tbytes += value.byteLength;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tstack.push( value );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbytes += getPrimitiveSize( value );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn bytes;\r\n\r\n}\r\n\r\nfunction validateBounds( bvh ) {\r\n\r\n\tconst geometry = bvh.geometry;\r\n\tconst depthStack = [];\r\n\tconst index = geometry.index;\r\n\tconst position = geometry.getAttribute( 'position' );\r\n\tlet passes = true;\r\n\r\n\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\r\n\r\n\t\tconst info = {\r\n\t\t\tdepth,\r\n\t\t\tisLeaf,\r\n\t\t\tboundingData,\r\n\t\t\toffset,\r\n\t\t\tcount,\r\n\t\t};\r\n\t\tdepthStack[ depth ] = info;\r\n\r\n\t\tarrayToBox( 0, boundingData, _box1 );\r\n\t\tconst parent = depthStack[ depth - 1 ];\r\n\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\t// check triangles\r\n\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\tconst i0 = index.getX( i );\r\n\t\t\t\tconst i1 = index.getX( i + 1 );\r\n\t\t\t\tconst i2 = index.getX( i + 2 );\r\n\r\n\t\t\t\tlet isContained;\r\n\r\n\t\t\t\t_vec.fromBufferAttribute( position, i0 );\r\n\t\t\t\tisContained = _box1.containsPoint( _vec );\r\n\r\n\t\t\t\t_vec.fromBufferAttribute( position, i1 );\r\n\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\r\n\r\n\t\t\t\t_vec.fromBufferAttribute( position, i2 );\r\n\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\r\n\r\n\t\t\t\tconsole.assert( isContained, 'Leaf bounds does not fully contain triangle.' );\r\n\t\t\t\tpasses = passes && isContained;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( parent ) {\r\n\r\n\t\t\t// check if my bounds fit in my parents\r\n\t\t\tarrayToBox( 0, boundingData, _box2 );\r\n\r\n\t\t\tconst isContained = _box2.containsBox( _box1 );\r\n\t\t\tconsole.assert( isContained, 'Parent bounds does not fully contain child.' );\r\n\t\t\tpasses = passes && isContained;\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\treturn passes;\r\n\r\n}\r\n\r\n// Returns a simple, human readable object that represents the BVH.\r\nfunction getJSONStructure( bvh ) {\r\n\r\n\tconst depthStack = [];\r\n\r\n\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\r\n\r\n\t\tconst info = {\r\n\t\t\tbounds: arrayToBox( 0, boundingData, new Box3() ),\r\n\t\t};\r\n\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tinfo.count = count;\r\n\t\t\tinfo.offset = offset;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tinfo.left = null;\r\n\t\t\tinfo.right = null;\r\n\r\n\t\t}\r\n\r\n\t\tdepthStack[ depth ] = info;\r\n\r\n\t\t// traversal hits the left then right node\r\n\t\tconst parent = depthStack[ depth - 1 ];\r\n\t\tif ( parent ) {\r\n\r\n\t\t\tif ( parent.left === null ) {\r\n\r\n\t\t\t\tparent.left = info;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tparent.right = info;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\treturn depthStack[ 0 ];\r\n\r\n}\r\n\r\nexport { estimateMemoryInBytes, getBVHExtremes, validateBounds, getJSONStructure };\r\n"]},"metadata":{},"sourceType":"module"}