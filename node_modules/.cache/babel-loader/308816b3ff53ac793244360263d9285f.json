{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RecognizerEngine = void 0;\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar keys_1 = require(\"../../grammar/keys\");\n\nvar exceptions_public_1 = require(\"../../exceptions_public\");\n\nvar lookahead_1 = require(\"../../grammar/lookahead\");\n\nvar interpreter_1 = require(\"../../grammar/interpreter\");\n\nvar parser_1 = require(\"../parser\");\n\nvar recoverable_1 = require(\"./recoverable\");\n\nvar tokens_public_1 = require(\"../../../scan/tokens_public\");\n\nvar tokens_1 = require(\"../../../scan/tokens\");\n\nvar lang_extensions_1 = require(\"../../../lang/lang_extensions\");\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\n\n\nvar RecognizerEngine =\n/** @class */\nfunction () {\n  function RecognizerEngine() {}\n\n  RecognizerEngine.prototype.initRecognizerEngine = function (tokenVocabulary, config) {\n    this.className = (0, lang_extensions_1.classNameFromInstance)(this); // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n\n    this.shortRuleNameToFull = {};\n    this.fullRuleNameToShort = {};\n    this.ruleShortNameIdx = 256;\n    this.tokenMatcher = tokens_1.tokenStructuredMatcherNoCategories;\n    this.definedRulesNames = [];\n    this.tokensMap = {};\n    this.isBackTrackingStack = [];\n    this.RULE_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n    this.gastProductionsCache = {};\n\n    if ((0, utils_1.has)(config, \"serializedGrammar\")) {\n      throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" + \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" + \"\\tFor Further details.\");\n    }\n\n    if ((0, utils_1.isArray)(tokenVocabulary)) {\n      // This only checks for Token vocabularies provided as arrays.\n      // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n      // rather than all edge cases of empty Token vocabularies.\n      if ((0, utils_1.isEmpty)(tokenVocabulary)) {\n        throw Error(\"A Token Vocabulary cannot be empty.\\n\" + \"\\tNote that the first argument for the parser constructor\\n\" + \"\\tis no longer a Token vector (since v4.0).\");\n      }\n\n      if (typeof tokenVocabulary[0].startOffset === \"number\") {\n        throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\" + \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" + \"\\tFor Further details.\");\n      }\n    }\n\n    if ((0, utils_1.isArray)(tokenVocabulary)) {\n      this.tokensMap = (0, utils_1.reduce)(tokenVocabulary, function (acc, tokType) {\n        acc[tokType.name] = tokType;\n        return acc;\n      }, {});\n    } else if ((0, utils_1.has)(tokenVocabulary, \"modes\") && (0, utils_1.every)((0, utils_1.flatten)((0, utils_1.values)(tokenVocabulary.modes)), tokens_1.isTokenType)) {\n      var allTokenTypes = (0, utils_1.flatten)((0, utils_1.values)(tokenVocabulary.modes));\n      var uniqueTokens = (0, utils_1.uniq)(allTokenTypes);\n      this.tokensMap = (0, utils_1.reduce)(uniqueTokens, function (acc, tokType) {\n        acc[tokType.name] = tokType;\n        return acc;\n      }, {});\n    } else if ((0, utils_1.isObject)(tokenVocabulary)) {\n      this.tokensMap = (0, utils_1.cloneObj)(tokenVocabulary);\n    } else {\n      throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors,\" + \" A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n    } // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n    // parsed with a clear error message (\"expecting EOF but found ...\")\n\n    /* tslint:disable */\n\n\n    this.tokensMap[\"EOF\"] = tokens_public_1.EOF; // TODO: This check may not be accurate for multi mode lexers\n\n    var noTokenCategoriesUsed = (0, utils_1.every)((0, utils_1.values)(tokenVocabulary), function (tokenConstructor) {\n      return (0, utils_1.isEmpty)(tokenConstructor.categoryMatches);\n    });\n    this.tokenMatcher = noTokenCategoriesUsed ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher; // Because ES2015+ syntax should be supported for creating Token classes\n    // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n    // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n\n    (0, tokens_1.augmentTokenTypes)((0, utils_1.values)(this.tokensMap));\n  };\n\n  RecognizerEngine.prototype.defineRule = function (ruleName, impl, config) {\n    if (this.selfAnalysisDone) {\n      throw Error(\"Grammar rule <\" + ruleName + \"> may not be defined after the 'performSelfAnalysis' method has been called'\\n\" + \"Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.\");\n    }\n\n    var resyncEnabled = (0, utils_1.has)(config, \"resyncEnabled\") ? config.resyncEnabled : parser_1.DEFAULT_RULE_CONFIG.resyncEnabled;\n    var recoveryValueFunc = (0, utils_1.has)(config, \"recoveryValueFunc\") ? config.recoveryValueFunc : parser_1.DEFAULT_RULE_CONFIG.recoveryValueFunc; // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n    // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n\n    /* tslint:disable */\n\n    var shortName = this.ruleShortNameIdx << keys_1.BITS_FOR_METHOD_TYPE + keys_1.BITS_FOR_OCCURRENCE_IDX;\n    /* tslint:enable */\n\n    this.ruleShortNameIdx++;\n    this.shortRuleNameToFull[shortName] = ruleName;\n    this.fullRuleNameToShort[ruleName] = shortName;\n\n    function invokeRuleWithTry(args) {\n      try {\n        if (this.outputCst === true) {\n          impl.apply(this, args);\n          var cst = this.CST_STACK[this.CST_STACK.length - 1];\n          this.cstPostRule(cst);\n          return cst;\n        } else {\n          return impl.apply(this, args);\n        }\n      } catch (e) {\n        return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n      } finally {\n        this.ruleFinallyStateUpdate();\n      }\n    }\n\n    var wrappedGrammarRule = function wrappedGrammarRule(idxInCallingRule, args) {\n      if (idxInCallingRule === void 0) {\n        idxInCallingRule = 0;\n      }\n\n      this.ruleInvocationStateUpdate(shortName, ruleName, idxInCallingRule);\n      return invokeRuleWithTry.call(this, args);\n    };\n\n    var ruleNamePropName = \"ruleName\";\n    wrappedGrammarRule[ruleNamePropName] = ruleName;\n    wrappedGrammarRule[\"originalGrammarAction\"] = impl;\n    return wrappedGrammarRule;\n  };\n\n  RecognizerEngine.prototype.invokeRuleCatch = function (e, resyncEnabledConfig, recoveryValueFunc) {\n    var isFirstInvokedRule = this.RULE_STACK.length === 1; // note the reSync is always enabled for the first rule invocation, because we must always be able to\n    // reSync with EOF and just output some INVALID ParseTree\n    // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n    // path is really the most valid one\n\n    var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n\n    if ((0, exceptions_public_1.isRecognitionException)(e)) {\n      var recogError = e;\n\n      if (reSyncEnabled) {\n        var reSyncTokType = this.findReSyncTokenType();\n\n        if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n          recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n\n          if (this.outputCst) {\n            var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            return partialCstResult;\n          } else {\n            return recoveryValueFunc();\n          }\n        } else {\n          if (this.outputCst) {\n            var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            recogError.partialCstResult = partialCstResult;\n          } // to be handled Further up the call stack\n\n\n          throw recogError;\n        }\n      } else if (isFirstInvokedRule) {\n        // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n        this.moveToTerminatedState(); // the parser should never throw one of its own errors outside its flow.\n        // even if error recovery is disabled\n\n        return recoveryValueFunc();\n      } else {\n        // to be recovered Further up the call stack\n        throw recogError;\n      }\n    } else {\n      // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n      throw e;\n    }\n  }; // Implementation of parsing DSL\n\n\n  RecognizerEngine.prototype.optionInternal = function (actionORMethodDef, occurrence) {\n    var key = this.getKeyForAutomaticLookahead(keys_1.OPTION_IDX, occurrence);\n    return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n  };\n\n  RecognizerEngine.prototype.optionInternalLogic = function (actionORMethodDef, occurrence, key) {\n    var _this = this;\n\n    var lookAheadFunc = this.getLaFuncFromCache(key);\n    var action;\n    var predicate;\n\n    if (actionORMethodDef.DEF !== undefined) {\n      action = actionORMethodDef.DEF;\n      predicate = actionORMethodDef.GATE; // predicate present\n\n      if (predicate !== undefined) {\n        var orgLookaheadFunction_1 = lookAheadFunc;\n\n        lookAheadFunc = function lookAheadFunc() {\n          return predicate.call(_this) && orgLookaheadFunction_1.call(_this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n\n    if (lookAheadFunc.call(this) === true) {\n      return action.call(this);\n    }\n\n    return undefined;\n  };\n\n  RecognizerEngine.prototype.atLeastOneInternal = function (prodOccurrence, actionORMethodDef) {\n    var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_IDX, prodOccurrence);\n    return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n  };\n\n  RecognizerEngine.prototype.atLeastOneInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n    var _this = this;\n\n    var lookAheadFunc = this.getLaFuncFromCache(key);\n    var action;\n    var predicate;\n\n    if (actionORMethodDef.DEF !== undefined) {\n      action = actionORMethodDef.DEF;\n      predicate = actionORMethodDef.GATE; // predicate present\n\n      if (predicate !== undefined) {\n        var orgLookaheadFunction_2 = lookAheadFunc;\n\n        lookAheadFunc = function lookAheadFunc() {\n          return predicate.call(_this) && orgLookaheadFunction_2.call(_this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n\n    if (lookAheadFunc.call(this) === true) {\n      var notStuck = this.doSingleRepetition(action);\n\n      while (lookAheadFunc.call(this) === true && notStuck === true) {\n        notStuck = this.doSingleRepetition(action);\n      }\n    } else {\n      throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n    } // note that while it may seem that this can cause an error because by using a recursive call to\n    // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n    // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n\n    this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, keys_1.AT_LEAST_ONE_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneWalker);\n  };\n\n  RecognizerEngine.prototype.atLeastOneSepFirstInternal = function (prodOccurrence, options) {\n    var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n    this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n  };\n\n  RecognizerEngine.prototype.atLeastOneSepFirstInternalLogic = function (prodOccurrence, options, key) {\n    var _this = this;\n\n    var action = options.DEF;\n    var separator = options.SEP;\n    var firstIterationLookaheadFunc = this.getLaFuncFromCache(key); // 1st iteration\n\n    if (firstIterationLookaheadFunc.call(this) === true) {\n      ;\n      action.call(this); //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n      //  because it is only needed in error recovery scenarios.\n\n      var separatorLookAheadFunc = function separatorLookAheadFunc() {\n        return _this.tokenMatcher(_this.LA(1), separator);\n      }; // 2nd..nth iterations\n\n\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator);\n        action.call(this);\n      } // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n\n      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, interpreter_1.NextTerminalAfterAtLeastOneSepWalker], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneSepWalker);\n    } else {\n      throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n    }\n  };\n\n  RecognizerEngine.prototype.manyInternal = function (prodOccurrence, actionORMethodDef) {\n    var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_IDX, prodOccurrence);\n    return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n  };\n\n  RecognizerEngine.prototype.manyInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n    var _this = this;\n\n    var lookaheadFunction = this.getLaFuncFromCache(key);\n    var action;\n    var predicate;\n\n    if (actionORMethodDef.DEF !== undefined) {\n      action = actionORMethodDef.DEF;\n      predicate = actionORMethodDef.GATE; // predicate present\n\n      if (predicate !== undefined) {\n        var orgLookaheadFunction_3 = lookaheadFunction;\n\n        lookaheadFunction = function lookaheadFunction() {\n          return predicate.call(_this) && orgLookaheadFunction_3.call(_this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n\n    var notStuck = true;\n\n    while (lookaheadFunction.call(this) === true && notStuck === true) {\n      notStuck = this.doSingleRepetition(action);\n    } // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n\n    this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, keys_1.MANY_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManyWalker, // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n    // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n    // An infinite loop cannot occur as:\n    // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n    // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n    notStuck);\n  };\n\n  RecognizerEngine.prototype.manySepFirstInternal = function (prodOccurrence, options) {\n    var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_SEP_IDX, prodOccurrence);\n    this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n  };\n\n  RecognizerEngine.prototype.manySepFirstInternalLogic = function (prodOccurrence, options, key) {\n    var _this = this;\n\n    var action = options.DEF;\n    var separator = options.SEP;\n    var firstIterationLaFunc = this.getLaFuncFromCache(key); // 1st iteration\n\n    if (firstIterationLaFunc.call(this) === true) {\n      action.call(this);\n\n      var separatorLookAheadFunc = function separatorLookAheadFunc() {\n        return _this.tokenMatcher(_this.LA(1), separator);\n      }; // 2nd..nth iterations\n\n\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator); // No need for checking infinite loop here due to consuming the separator.\n\n        action.call(this);\n      } // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n\n      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, interpreter_1.NextTerminalAfterManySepWalker], separatorLookAheadFunc, keys_1.MANY_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManySepWalker);\n    }\n  };\n\n  RecognizerEngine.prototype.repetitionSepSecondInternal = function (prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n    while (separatorLookAheadFunc()) {\n      // note that this CONSUME will never enter recovery because\n      // the separatorLookAheadFunc checks that the separator really does exist.\n      this.CONSUME(separator);\n      action.call(this);\n    } // we can only arrive to this function after an error\n    // has occurred (hence the name 'second') so the following\n    // IF will always be entered, its possible to remove it...\n    // however it is kept to avoid confusion and be consistent.\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n    /* istanbul ignore else */\n\n\n    this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n  };\n\n  RecognizerEngine.prototype.doSingleRepetition = function (action) {\n    var beforeIteration = this.getLexerPosition();\n    action.call(this);\n    var afterIteration = this.getLexerPosition(); // This boolean will indicate if this repetition progressed\n    // or if we are \"stuck\" (potential infinite loop in the repetition).\n\n    return afterIteration > beforeIteration;\n  };\n\n  RecognizerEngine.prototype.orInternal = function (altsOrOpts, occurrence) {\n    var laKey = this.getKeyForAutomaticLookahead(keys_1.OR_IDX, occurrence);\n    var alts = (0, utils_1.isArray)(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n    var laFunc = this.getLaFuncFromCache(laKey);\n    var altIdxToTake = laFunc.call(this, alts);\n\n    if (altIdxToTake !== undefined) {\n      var chosenAlternative = alts[altIdxToTake];\n      return chosenAlternative.ALT.call(this);\n    }\n\n    this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n  };\n\n  RecognizerEngine.prototype.ruleFinallyStateUpdate = function () {\n    this.RULE_STACK.pop();\n    this.RULE_OCCURRENCE_STACK.pop(); // NOOP when cst is disabled\n\n    this.cstFinallyStateUpdate();\n\n    if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n      var firstRedundantTok = this.LA(1);\n      var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n        firstRedundant: firstRedundantTok,\n        ruleName: this.getCurrRuleFullName()\n      });\n      this.SAVE_ERROR(new exceptions_public_1.NotAllInputParsedException(errMsg, firstRedundantTok));\n    }\n  };\n\n  RecognizerEngine.prototype.subruleInternal = function (ruleToCall, idx, options) {\n    var ruleResult;\n\n    try {\n      var args = options !== undefined ? options.ARGS : undefined;\n      ruleResult = ruleToCall.call(this, idx, args);\n      this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleToCall.ruleName);\n      return ruleResult;\n    } catch (e) {\n      this.subruleInternalError(e, options, ruleToCall.ruleName);\n    }\n  };\n\n  RecognizerEngine.prototype.subruleInternalError = function (e, options, ruleName) {\n    if ((0, exceptions_public_1.isRecognitionException)(e) && e.partialCstResult !== undefined) {\n      this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleName);\n      delete e.partialCstResult;\n    }\n\n    throw e;\n  };\n\n  RecognizerEngine.prototype.consumeInternal = function (tokType, idx, options) {\n    var consumedToken;\n\n    try {\n      var nextToken = this.LA(1);\n\n      if (this.tokenMatcher(nextToken, tokType) === true) {\n        this.consumeToken();\n        consumedToken = nextToken;\n      } else {\n        this.consumeInternalError(tokType, nextToken, options);\n      }\n    } catch (eFromConsumption) {\n      consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n    }\n\n    this.cstPostTerminal(options !== undefined && options.LABEL !== undefined ? options.LABEL : tokType.name, consumedToken);\n    return consumedToken;\n  };\n\n  RecognizerEngine.prototype.consumeInternalError = function (tokType, nextToken, options) {\n    var msg;\n    var previousToken = this.LA(0);\n\n    if (options !== undefined && options.ERR_MSG) {\n      msg = options.ERR_MSG;\n    } else {\n      msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: tokType,\n        actual: nextToken,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName()\n      });\n    }\n\n    throw this.SAVE_ERROR(new exceptions_public_1.MismatchedTokenException(msg, nextToken, previousToken));\n  };\n\n  RecognizerEngine.prototype.consumeInternalRecovery = function (tokType, idx, eFromConsumption) {\n    // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n    // but the original syntax could have been parsed successfully without any backtracking + recovery\n    if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n    eFromConsumption.name === \"MismatchedTokenException\" && !this.isBackTracking()) {\n      var follows = this.getFollowsForInRuleRecovery(tokType, idx);\n\n      try {\n        return this.tryInRuleRecovery(tokType, follows);\n      } catch (eFromInRuleRecovery) {\n        if (eFromInRuleRecovery.name === recoverable_1.IN_RULE_RECOVERY_EXCEPTION) {\n          // failed in RuleRecovery.\n          // throw the original error in order to trigger reSync error recovery\n          throw eFromConsumption;\n        } else {\n          throw eFromInRuleRecovery;\n        }\n      }\n    } else {\n      throw eFromConsumption;\n    }\n  };\n\n  RecognizerEngine.prototype.saveRecogState = function () {\n    // errors is a getter which will clone the errors array\n    var savedErrors = this.errors;\n    var savedRuleStack = (0, utils_1.cloneArr)(this.RULE_STACK);\n    return {\n      errors: savedErrors,\n      lexerState: this.exportLexerState(),\n      RULE_STACK: savedRuleStack,\n      CST_STACK: this.CST_STACK\n    };\n  };\n\n  RecognizerEngine.prototype.reloadRecogState = function (newState) {\n    this.errors = newState.errors;\n    this.importLexerState(newState.lexerState);\n    this.RULE_STACK = newState.RULE_STACK;\n  };\n\n  RecognizerEngine.prototype.ruleInvocationStateUpdate = function (shortName, fullName, idxInCallingRule) {\n    this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n    this.RULE_STACK.push(shortName); // NOOP when cst is disabled\n\n    this.cstInvocationStateUpdate(fullName, shortName);\n  };\n\n  RecognizerEngine.prototype.isBackTracking = function () {\n    return this.isBackTrackingStack.length !== 0;\n  };\n\n  RecognizerEngine.prototype.getCurrRuleFullName = function () {\n    var shortName = this.getLastExplicitRuleShortName();\n    return this.shortRuleNameToFull[shortName];\n  };\n\n  RecognizerEngine.prototype.shortRuleNameToFullName = function (shortName) {\n    return this.shortRuleNameToFull[shortName];\n  };\n\n  RecognizerEngine.prototype.isAtEndOfInput = function () {\n    return this.tokenMatcher(this.LA(1), tokens_public_1.EOF);\n  };\n\n  RecognizerEngine.prototype.reset = function () {\n    this.resetLexerState();\n    this.isBackTrackingStack = [];\n    this.errors = [];\n    this.RULE_STACK = []; // TODO: extract a specific reset for TreeBuilder trait\n\n    this.CST_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n  };\n\n  return RecognizerEngine;\n}();\n\nexports.RecognizerEngine = RecognizerEngine;","map":{"version":3,"mappings":"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","names":["RecognizerEngine","tokenVocabulary","config","className","shortRuleNameToFull","fullRuleNameToShort","ruleShortNameIdx","tokenMatcher","tokens_1","definedRulesNames","tokensMap","isBackTrackingStack","RULE_STACK","RULE_OCCURRENCE_STACK","gastProductionsCache","Error","startOffset","acc","tokType","name","modes","allTokenTypes","uniqueTokens","tokens_public_1","noTokenCategoriesUsed","tokenConstructor","categoryMatches","ruleName","impl","selfAnalysisDone","resyncEnabled","parser_1","recoveryValueFunc","shortName","keys_1","invokeRuleWithTry","args","outputCst","apply","cst","CST_STACK","length","cstPostRule","e","invokeRuleCatch","ruleFinallyStateUpdate","wrappedGrammarRule","idxInCallingRule","ruleInvocationStateUpdate","call","ruleNamePropName","resyncEnabledConfig","isFirstInvokedRule","reSyncEnabled","isBackTracking","recoveryEnabled","recogError","reSyncTokType","findReSyncTokenType","isInCurrentRuleReSyncSet","resyncedTokens","reSyncTo","partialCstResult","recoveredNode","moveToTerminatedState","actionORMethodDef","occurrence","key","getKeyForAutomaticLookahead","optionInternalLogic","lookAheadFunc","getLaFuncFromCache","action","predicate","DEF","undefined","GATE","orgLookaheadFunction_1","_this","prodOccurrence","laKey","atLeastOneInternalLogic","orgLookaheadFunction_2","notStuck","doSingleRepetition","raiseEarlyExitException","lookahead_1","REPETITION_MANDATORY","ERR_MSG","attemptInRepetitionRecovery","atLeastOneInternal","interpreter_1","options","atLeastOneSepFirstInternalLogic","separator","SEP","firstIterationLookaheadFunc","separatorLookAheadFunc","LA","CONSUME","repetitionSepSecondInternal","REPETITION_MANDATORY_WITH_SEPARATOR","manyInternalLogic","lookaheadFunction","orgLookaheadFunction_3","manyInternal","manySepFirstInternalLogic","firstIterationLaFunc","nextTerminalAfterWalker","beforeIteration","getLexerPosition","afterIteration","altsOrOpts","alts","laFunc","altIdxToTake","chosenAlternative","ALT","raiseNoAltException","pop","cstFinallyStateUpdate","isAtEndOfInput","firstRedundantTok","errMsg","errorMessageProvider","buildNotAllInputParsedMessage","firstRedundant","getCurrRuleFullName","SAVE_ERROR","exceptions_public_1","ruleToCall","idx","ruleResult","ARGS","cstPostNonTerminal","LABEL","subruleInternalError","consumedToken","nextToken","consumeToken","consumeInternalError","eFromConsumption","consumeInternalRecovery","cstPostTerminal","msg","previousToken","buildMismatchTokenMessage","expected","actual","previous","follows","getFollowsForInRuleRecovery","tryInRuleRecovery","eFromInRuleRecovery","recoverable_1","savedErrors","errors","savedRuleStack","lexerState","exportLexerState","newState","importLexerState","fullName","push","cstInvocationStateUpdate","getLastExplicitRuleShortName","resetLexerState","exports"],"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/chevrotain/src/parse/parser/traits/recognizer_engine.ts"],"sourcesContent":["import {\n  AtLeastOneSepMethodOpts,\n  ConsumeMethodOpts,\n  DSLMethodOpts,\n  DSLMethodOptsWithErr,\n  GrammarAction,\n  IOrAlt,\n  IParserConfig,\n  IRuleConfig,\n  IToken,\n  ManySepMethodOpts,\n  OrMethodOpts,\n  SubruleMethodOpts,\n  TokenType,\n  TokenVocabulary\n} from \"@chevrotain/types\"\nimport {\n  cloneArr,\n  cloneObj,\n  every,\n  flatten,\n  has,\n  isArray,\n  isEmpty,\n  isObject,\n  reduce,\n  uniq,\n  values\n} from \"@chevrotain/utils\"\nimport {\n  AT_LEAST_ONE_IDX,\n  AT_LEAST_ONE_SEP_IDX,\n  BITS_FOR_METHOD_TYPE,\n  BITS_FOR_OCCURRENCE_IDX,\n  MANY_IDX,\n  MANY_SEP_IDX,\n  OPTION_IDX,\n  OR_IDX\n} from \"../../grammar/keys\"\nimport {\n  isRecognitionException,\n  MismatchedTokenException,\n  NotAllInputParsedException\n} from \"../../exceptions_public\"\nimport { PROD_TYPE } from \"../../grammar/lookahead\"\nimport {\n  AbstractNextTerminalAfterProductionWalker,\n  NextTerminalAfterAtLeastOneSepWalker,\n  NextTerminalAfterAtLeastOneWalker,\n  NextTerminalAfterManySepWalker,\n  NextTerminalAfterManyWalker\n} from \"../../grammar/interpreter\"\nimport { DEFAULT_RULE_CONFIG, IParserState, TokenMatcher } from \"../parser\"\nimport { IN_RULE_RECOVERY_EXCEPTION } from \"./recoverable\"\nimport { EOF } from \"../../../scan/tokens_public\"\nimport { MixedInParser } from \"./parser_traits\"\nimport {\n  augmentTokenTypes,\n  isTokenType,\n  tokenStructuredMatcher,\n  tokenStructuredMatcherNoCategories\n} from \"../../../scan/tokens\"\nimport { classNameFromInstance } from \"../../../lang/lang_extensions\"\nimport { Rule } from \"../../grammar/gast/gast_public\"\n\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\nexport class RecognizerEngine {\n  isBackTrackingStack\n  className: string\n  RULE_STACK: string[]\n  RULE_OCCURRENCE_STACK: number[]\n  definedRulesNames: string[]\n  tokensMap: { [fqn: string]: TokenType }\n  gastProductionsCache: Record<string, Rule>\n  shortRuleNameToFull: Record<string, string>\n  fullRuleNameToShort: Record<string, number>\n  // The shortName Index must be coded \"after\" the first 8bits to enable building unique lookahead keys\n  ruleShortNameIdx: number\n  tokenMatcher: TokenMatcher\n\n  initRecognizerEngine(\n    tokenVocabulary: TokenVocabulary,\n    config: IParserConfig\n  ) {\n    this.className = classNameFromInstance(this)\n    // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n    this.shortRuleNameToFull = {}\n    this.fullRuleNameToShort = {}\n    this.ruleShortNameIdx = 256\n    this.tokenMatcher = tokenStructuredMatcherNoCategories\n\n    this.definedRulesNames = []\n    this.tokensMap = {}\n    this.isBackTrackingStack = []\n    this.RULE_STACK = []\n    this.RULE_OCCURRENCE_STACK = []\n    this.gastProductionsCache = {}\n\n    if (has(config, \"serializedGrammar\")) {\n      throw Error(\n        \"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" +\n          \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" +\n          \"\\tFor Further details.\"\n      )\n    }\n\n    if (isArray(tokenVocabulary)) {\n      // This only checks for Token vocabularies provided as arrays.\n      // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n      // rather than all edge cases of empty Token vocabularies.\n      if (isEmpty(tokenVocabulary as any[])) {\n        throw Error(\n          \"A Token Vocabulary cannot be empty.\\n\" +\n            \"\\tNote that the first argument for the parser constructor\\n\" +\n            \"\\tis no longer a Token vector (since v4.0).\"\n        )\n      }\n\n      if (typeof (tokenVocabulary as any[])[0].startOffset === \"number\") {\n        throw Error(\n          \"The Parser constructor no longer accepts a token vector as the first argument.\\n\" +\n            \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" +\n            \"\\tFor Further details.\"\n        )\n      }\n    }\n\n    if (isArray(tokenVocabulary)) {\n      this.tokensMap = <any>reduce(\n        <any>tokenVocabulary,\n        (acc, tokType: TokenType) => {\n          acc[tokType.name] = tokType\n          return acc\n        },\n        {}\n      )\n    } else if (\n      has(tokenVocabulary, \"modes\") &&\n      every(flatten(values((<any>tokenVocabulary).modes)), isTokenType)\n    ) {\n      const allTokenTypes = flatten(values((<any>tokenVocabulary).modes))\n      const uniqueTokens = uniq(allTokenTypes)\n      this.tokensMap = <any>reduce(\n        uniqueTokens,\n        (acc, tokType: TokenType) => {\n          acc[tokType.name] = tokType\n          return acc\n        },\n        {}\n      )\n    } else if (isObject(tokenVocabulary)) {\n      this.tokensMap = cloneObj(tokenVocabulary)\n    } else {\n      throw new Error(\n        \"<tokensDictionary> argument must be An Array of Token constructors,\" +\n          \" A dictionary of Token constructors or an IMultiModeLexerDefinition\"\n      )\n    }\n\n    // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n    // parsed with a clear error message (\"expecting EOF but found ...\")\n    /* tslint:disable */\n    this.tokensMap[\"EOF\"] = EOF\n\n    // TODO: This check may not be accurate for multi mode lexers\n    const noTokenCategoriesUsed = every(\n      values(tokenVocabulary),\n      (tokenConstructor) => isEmpty(tokenConstructor.categoryMatches)\n    )\n\n    this.tokenMatcher = noTokenCategoriesUsed\n      ? tokenStructuredMatcherNoCategories\n      : tokenStructuredMatcher\n\n    // Because ES2015+ syntax should be supported for creating Token classes\n    // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n    // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n    augmentTokenTypes(values(this.tokensMap))\n  }\n\n  defineRule<T>(\n    this: MixedInParser,\n    ruleName: string,\n    impl: (...implArgs: any[]) => T,\n    config: IRuleConfig<T>\n  ): (idxInCallingRule?: number, ...args: any[]) => T {\n    if (this.selfAnalysisDone) {\n      throw Error(\n        `Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'\\n` +\n          `Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`\n      )\n    }\n    const resyncEnabled = has(config, \"resyncEnabled\")\n      ? config.resyncEnabled\n      : DEFAULT_RULE_CONFIG.resyncEnabled\n    const recoveryValueFunc = has(config, \"recoveryValueFunc\")\n      ? config.recoveryValueFunc\n      : DEFAULT_RULE_CONFIG.recoveryValueFunc\n\n    // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n    // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n    /* tslint:disable */\n    const shortName =\n      this.ruleShortNameIdx << (BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX)\n    /* tslint:enable */\n\n    this.ruleShortNameIdx++\n    this.shortRuleNameToFull[shortName] = ruleName\n    this.fullRuleNameToShort[ruleName] = shortName\n\n    function invokeRuleWithTry(args: any[]) {\n      try {\n        if (this.outputCst === true) {\n          impl.apply(this, args)\n          const cst = this.CST_STACK[this.CST_STACK.length - 1]\n          this.cstPostRule(cst)\n          return cst\n        } else {\n          return impl.apply(this, args)\n        }\n      } catch (e) {\n        return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc)\n      } finally {\n        this.ruleFinallyStateUpdate()\n      }\n    }\n\n    const wrappedGrammarRule = function (\n      idxInCallingRule: number = 0,\n      args: any[]\n    ) {\n      this.ruleInvocationStateUpdate(shortName, ruleName, idxInCallingRule)\n      return invokeRuleWithTry.call(this, args)\n    }\n\n    const ruleNamePropName = \"ruleName\"\n    wrappedGrammarRule[ruleNamePropName] = ruleName\n    wrappedGrammarRule[\"originalGrammarAction\"] = impl\n    return wrappedGrammarRule\n  }\n\n  invokeRuleCatch(\n    this: MixedInParser,\n    e: Error,\n    resyncEnabledConfig: boolean,\n    recoveryValueFunc: Function\n  ): void {\n    const isFirstInvokedRule = this.RULE_STACK.length === 1\n    // note the reSync is always enabled for the first rule invocation, because we must always be able to\n    // reSync with EOF and just output some INVALID ParseTree\n    // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n    // path is really the most valid one\n    const reSyncEnabled =\n      resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled\n\n    if (isRecognitionException(e)) {\n      const recogError: any = e\n      if (reSyncEnabled) {\n        const reSyncTokType = this.findReSyncTokenType()\n        if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n          recogError.resyncedTokens = this.reSyncTo(reSyncTokType)\n          if (this.outputCst) {\n            const partialCstResult: any =\n              this.CST_STACK[this.CST_STACK.length - 1]\n            partialCstResult.recoveredNode = true\n            return partialCstResult\n          } else {\n            return recoveryValueFunc()\n          }\n        } else {\n          if (this.outputCst) {\n            const partialCstResult: any =\n              this.CST_STACK[this.CST_STACK.length - 1]\n            partialCstResult.recoveredNode = true\n            recogError.partialCstResult = partialCstResult\n          }\n          // to be handled Further up the call stack\n          throw recogError\n        }\n      } else if (isFirstInvokedRule) {\n        // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n        this.moveToTerminatedState()\n        // the parser should never throw one of its own errors outside its flow.\n        // even if error recovery is disabled\n        return recoveryValueFunc()\n      } else {\n        // to be recovered Further up the call stack\n        throw recogError\n      }\n    } else {\n      // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n      throw e\n    }\n  }\n\n  // Implementation of parsing DSL\n  optionInternal<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    occurrence: number\n  ): OUT {\n    const key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence)\n    return this.optionInternalLogic(actionORMethodDef, occurrence, key)\n  }\n\n  optionInternalLogic<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    occurrence: number,\n    key: number\n  ): OUT {\n    let lookAheadFunc = this.getLaFuncFromCache(key)\n    let action\n    let predicate\n    if ((<DSLMethodOpts<OUT>>actionORMethodDef).DEF !== undefined) {\n      action = (<DSLMethodOpts<OUT>>actionORMethodDef).DEF\n      predicate = (<DSLMethodOpts<OUT>>actionORMethodDef).GATE\n      // predicate present\n      if (predicate !== undefined) {\n        const orgLookaheadFunction = lookAheadFunc\n        lookAheadFunc = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this)\n        }\n      }\n    } else {\n      action = actionORMethodDef\n    }\n\n    if (lookAheadFunc.call(this) === true) {\n      return action.call(this)\n    }\n    return undefined\n  }\n\n  atLeastOneInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(\n      AT_LEAST_ONE_IDX,\n      prodOccurrence\n    )\n    return this.atLeastOneInternalLogic(\n      prodOccurrence,\n      actionORMethodDef,\n      laKey\n    )\n  }\n\n  atLeastOneInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n    key: number\n  ): void {\n    let lookAheadFunc = this.getLaFuncFromCache(key)\n\n    let action\n    let predicate\n    if ((<DSLMethodOptsWithErr<OUT>>actionORMethodDef).DEF !== undefined) {\n      action = (<DSLMethodOptsWithErr<OUT>>actionORMethodDef).DEF\n      predicate = (<DSLMethodOptsWithErr<OUT>>actionORMethodDef).GATE\n      // predicate present\n      if (predicate !== undefined) {\n        const orgLookaheadFunction = lookAheadFunc\n        lookAheadFunc = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this)\n        }\n      }\n    } else {\n      action = actionORMethodDef\n    }\n\n    if ((<Function>lookAheadFunc).call(this) === true) {\n      let notStuck = this.doSingleRepetition(action)\n      while (\n        (<Function>lookAheadFunc).call(this) === true &&\n        notStuck === true\n      ) {\n        notStuck = this.doSingleRepetition(action)\n      }\n    } else {\n      throw this.raiseEarlyExitException(\n        prodOccurrence,\n        PROD_TYPE.REPETITION_MANDATORY,\n        (<DSLMethodOptsWithErr<OUT>>actionORMethodDef).ERR_MSG\n      )\n    }\n\n    // note that while it may seem that this can cause an error because by using a recursive call to\n    // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n    // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    this.attemptInRepetitionRecovery(\n      this.atLeastOneInternal,\n      [prodOccurrence, actionORMethodDef],\n      <any>lookAheadFunc,\n      AT_LEAST_ONE_IDX,\n      prodOccurrence,\n      NextTerminalAfterAtLeastOneWalker\n    )\n  }\n\n  atLeastOneSepFirstInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(\n      AT_LEAST_ONE_SEP_IDX,\n      prodOccurrence\n    )\n    this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey)\n  }\n\n  atLeastOneSepFirstInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: AtLeastOneSepMethodOpts<OUT>,\n    key: number\n  ): void {\n    const action = options.DEF\n    const separator = options.SEP\n\n    const firstIterationLookaheadFunc = this.getLaFuncFromCache(key)\n\n    // 1st iteration\n    if (firstIterationLookaheadFunc.call(this) === true) {\n      ;(<GrammarAction<OUT>>action).call(this)\n\n      //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n      //  because it is only needed in error recovery scenarios.\n      const separatorLookAheadFunc = () => {\n        return this.tokenMatcher(this.LA(1), separator)\n      }\n\n      // 2nd..nth iterations\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator)\n        // No need for checking infinite loop here due to consuming the separator.\n        ;(<GrammarAction<OUT>>action).call(this)\n      }\n\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(\n        this.repetitionSepSecondInternal,\n        [\n          prodOccurrence,\n          separator,\n          separatorLookAheadFunc,\n          action,\n          NextTerminalAfterAtLeastOneSepWalker\n        ],\n        separatorLookAheadFunc,\n        AT_LEAST_ONE_SEP_IDX,\n        prodOccurrence,\n        NextTerminalAfterAtLeastOneSepWalker\n      )\n    } else {\n      throw this.raiseEarlyExitException(\n        prodOccurrence,\n        PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,\n        options.ERR_MSG\n      )\n    }\n  }\n\n  manyInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence)\n    return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey)\n  }\n\n  manyInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    key: number\n  ) {\n    let lookaheadFunction = this.getLaFuncFromCache(key)\n\n    let action\n    let predicate\n    if ((<DSLMethodOpts<OUT>>actionORMethodDef).DEF !== undefined) {\n      action = (<DSLMethodOpts<OUT>>actionORMethodDef).DEF\n      predicate = (<DSLMethodOpts<OUT>>actionORMethodDef).GATE\n      // predicate present\n      if (predicate !== undefined) {\n        const orgLookaheadFunction = lookaheadFunction\n        lookaheadFunction = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this)\n        }\n      }\n    } else {\n      action = actionORMethodDef\n    }\n\n    let notStuck = true\n    while (lookaheadFunction.call(this) === true && notStuck === true) {\n      notStuck = this.doSingleRepetition(action)\n    }\n\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    this.attemptInRepetitionRecovery(\n      this.manyInternal,\n      [prodOccurrence, actionORMethodDef],\n      <any>lookaheadFunction,\n      MANY_IDX,\n      prodOccurrence,\n      NextTerminalAfterManyWalker,\n      // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n      // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n      // An infinite loop cannot occur as:\n      // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n      // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n      notStuck\n    )\n  }\n\n  manySepFirstInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: ManySepMethodOpts<OUT>\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence)\n    this.manySepFirstInternalLogic(prodOccurrence, options, laKey)\n  }\n\n  manySepFirstInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: ManySepMethodOpts<OUT>,\n    key: number\n  ): void {\n    const action = options.DEF\n    const separator = options.SEP\n    const firstIterationLaFunc = this.getLaFuncFromCache(key)\n\n    // 1st iteration\n    if (firstIterationLaFunc.call(this) === true) {\n      action.call(this)\n\n      const separatorLookAheadFunc = () => {\n        return this.tokenMatcher(this.LA(1), separator)\n      }\n      // 2nd..nth iterations\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator)\n        // No need for checking infinite loop here due to consuming the separator.\n        action.call(this)\n      }\n\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(\n        this.repetitionSepSecondInternal,\n        [\n          prodOccurrence,\n          separator,\n          separatorLookAheadFunc,\n          action,\n          NextTerminalAfterManySepWalker\n        ],\n        separatorLookAheadFunc,\n        MANY_SEP_IDX,\n        prodOccurrence,\n        NextTerminalAfterManySepWalker\n      )\n    }\n  }\n\n  repetitionSepSecondInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    separator: TokenType,\n    separatorLookAheadFunc: () => boolean,\n    action: GrammarAction<OUT>,\n    nextTerminalAfterWalker: typeof AbstractNextTerminalAfterProductionWalker\n  ): void {\n    while (separatorLookAheadFunc()) {\n      // note that this CONSUME will never enter recovery because\n      // the separatorLookAheadFunc checks that the separator really does exist.\n      this.CONSUME(separator)\n      action.call(this)\n    }\n\n    // we can only arrive to this function after an error\n    // has occurred (hence the name 'second') so the following\n    // IF will always be entered, its possible to remove it...\n    // however it is kept to avoid confusion and be consistent.\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    /* istanbul ignore else */\n    this.attemptInRepetitionRecovery(\n      this.repetitionSepSecondInternal,\n      [\n        prodOccurrence,\n        separator,\n        separatorLookAheadFunc,\n        action,\n        nextTerminalAfterWalker\n      ],\n      separatorLookAheadFunc,\n      AT_LEAST_ONE_SEP_IDX,\n      prodOccurrence,\n      nextTerminalAfterWalker\n    )\n  }\n\n  doSingleRepetition(this: MixedInParser, action: Function): any {\n    const beforeIteration = this.getLexerPosition()\n    action.call(this)\n    const afterIteration = this.getLexerPosition()\n\n    // This boolean will indicate if this repetition progressed\n    // or if we are \"stuck\" (potential infinite loop in the repetition).\n    return afterIteration > beforeIteration\n  }\n\n  orInternal<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n    occurrence: number\n  ): T {\n    const laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence)\n    const alts = isArray(altsOrOpts)\n      ? (altsOrOpts as IOrAlt<any>[])\n      : (altsOrOpts as OrMethodOpts<unknown>).DEF\n\n    const laFunc = this.getLaFuncFromCache(laKey)\n    const altIdxToTake = laFunc.call(this, alts)\n    if (altIdxToTake !== undefined) {\n      const chosenAlternative: any = alts[altIdxToTake]\n      return chosenAlternative.ALT.call(this)\n    }\n    this.raiseNoAltException(\n      occurrence,\n      (altsOrOpts as OrMethodOpts<unknown>).ERR_MSG\n    )\n  }\n\n  ruleFinallyStateUpdate(this: MixedInParser): void {\n    this.RULE_STACK.pop()\n    this.RULE_OCCURRENCE_STACK.pop()\n\n    // NOOP when cst is disabled\n    this.cstFinallyStateUpdate()\n\n    if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n      const firstRedundantTok = this.LA(1)\n      const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n        firstRedundant: firstRedundantTok,\n        ruleName: this.getCurrRuleFullName()\n      })\n      this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok))\n    }\n  }\n\n  subruleInternal<T>(\n    this: MixedInParser,\n    ruleToCall: (idx: number) => T,\n    idx: number,\n    options?: SubruleMethodOpts\n  ) {\n    let ruleResult\n    try {\n      const args = options !== undefined ? options.ARGS : undefined\n      ruleResult = ruleToCall.call(this, idx, args)\n      this.cstPostNonTerminal(\n        ruleResult,\n        options !== undefined && options.LABEL !== undefined\n          ? options.LABEL\n          : (<any>ruleToCall).ruleName\n      )\n      return ruleResult\n    } catch (e) {\n      this.subruleInternalError(e, options, (<any>ruleToCall).ruleName)\n    }\n  }\n\n  subruleInternalError(\n    this: MixedInParser,\n    e: any,\n    options: SubruleMethodOpts,\n    ruleName: string\n  ): void {\n    if (isRecognitionException(e) && e.partialCstResult !== undefined) {\n      this.cstPostNonTerminal(\n        e.partialCstResult,\n        options !== undefined && options.LABEL !== undefined\n          ? options.LABEL\n          : ruleName\n      )\n\n      delete e.partialCstResult\n    }\n    throw e\n  }\n\n  consumeInternal(\n    this: MixedInParser,\n    tokType: TokenType,\n    idx: number,\n    options: ConsumeMethodOpts\n  ): IToken {\n    let consumedToken\n    try {\n      const nextToken = this.LA(1)\n      if (this.tokenMatcher(nextToken, tokType) === true) {\n        this.consumeToken()\n        consumedToken = nextToken\n      } else {\n        this.consumeInternalError(tokType, nextToken, options)\n      }\n    } catch (eFromConsumption) {\n      consumedToken = this.consumeInternalRecovery(\n        tokType,\n        idx,\n        eFromConsumption\n      )\n    }\n\n    this.cstPostTerminal(\n      options !== undefined && options.LABEL !== undefined\n        ? options.LABEL\n        : tokType.name,\n      consumedToken\n    )\n    return consumedToken\n  }\n\n  consumeInternalError(\n    this: MixedInParser,\n    tokType: TokenType,\n    nextToken: IToken,\n    options: ConsumeMethodOpts\n  ): void {\n    let msg\n    const previousToken = this.LA(0)\n    if (options !== undefined && options.ERR_MSG) {\n      msg = options.ERR_MSG\n    } else {\n      msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: tokType,\n        actual: nextToken,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName()\n      })\n    }\n    throw this.SAVE_ERROR(\n      new MismatchedTokenException(msg, nextToken, previousToken)\n    )\n  }\n\n  consumeInternalRecovery(\n    this: MixedInParser,\n    tokType: TokenType,\n    idx: number,\n    eFromConsumption: Error\n  ): IToken {\n    // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n    // but the original syntax could have been parsed successfully without any backtracking + recovery\n    if (\n      this.recoveryEnabled &&\n      // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n      eFromConsumption.name === \"MismatchedTokenException\" &&\n      !this.isBackTracking()\n    ) {\n      const follows = this.getFollowsForInRuleRecovery(<any>tokType, idx)\n      try {\n        return this.tryInRuleRecovery(<any>tokType, follows)\n      } catch (eFromInRuleRecovery) {\n        if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n          // failed in RuleRecovery.\n          // throw the original error in order to trigger reSync error recovery\n          throw eFromConsumption\n        } else {\n          throw eFromInRuleRecovery\n        }\n      }\n    } else {\n      throw eFromConsumption\n    }\n  }\n\n  saveRecogState(this: MixedInParser): IParserState {\n    // errors is a getter which will clone the errors array\n    const savedErrors = this.errors\n    const savedRuleStack = cloneArr(this.RULE_STACK)\n    return {\n      errors: savedErrors,\n      lexerState: this.exportLexerState(),\n      RULE_STACK: savedRuleStack,\n      CST_STACK: this.CST_STACK\n    }\n  }\n\n  reloadRecogState(this: MixedInParser, newState: IParserState) {\n    this.errors = newState.errors\n    this.importLexerState(newState.lexerState)\n    this.RULE_STACK = newState.RULE_STACK\n  }\n\n  ruleInvocationStateUpdate(\n    this: MixedInParser,\n    shortName: string,\n    fullName: string,\n    idxInCallingRule: number\n  ): void {\n    this.RULE_OCCURRENCE_STACK.push(idxInCallingRule)\n    this.RULE_STACK.push(shortName)\n    // NOOP when cst is disabled\n    this.cstInvocationStateUpdate(fullName, shortName)\n  }\n\n  isBackTracking(this: MixedInParser): boolean {\n    return this.isBackTrackingStack.length !== 0\n  }\n\n  getCurrRuleFullName(this: MixedInParser): string {\n    const shortName = this.getLastExplicitRuleShortName()\n    return this.shortRuleNameToFull[shortName]\n  }\n\n  shortRuleNameToFullName(this: MixedInParser, shortName: string) {\n    return this.shortRuleNameToFull[shortName]\n  }\n\n  public isAtEndOfInput(this: MixedInParser): boolean {\n    return this.tokenMatcher(this.LA(1), EOF)\n  }\n\n  public reset(this: MixedInParser): void {\n    this.resetLexerState()\n\n    this.isBackTrackingStack = []\n    this.errors = []\n    this.RULE_STACK = []\n    // TODO: extract a specific reset for TreeBuilder trait\n    this.CST_STACK = []\n    this.RULE_OCCURRENCE_STACK = []\n  }\n}\n"]},"metadata":{},"sourceType":"script"}