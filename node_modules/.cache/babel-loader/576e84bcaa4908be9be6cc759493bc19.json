{"ast":null,"code":"import { sRGBEncoding, LinearEncoding } from 'three';\nimport { TempNode } from '../core/TempNode.js';\nimport { ConstNode } from '../core/ConstNode.js';\nimport { FunctionNode } from '../core/FunctionNode.js';\n\nfunction ColorSpaceNode(input, method) {\n  TempNode.call(this, 'v4');\n  this.input = input;\n  this.method = method || ColorSpaceNode.LINEAR_TO_LINEAR;\n}\n\nColorSpaceNode.Nodes = function () {\n  var LinearToLinear = new FunctionNode(['vec4 LinearToLinear( in vec4 value ) {', '\treturn value;', '}'].join('\\n'));\n  var sRGBToLinear = new FunctionNode(['vec4 sRGBToLinear( in vec4 value ) {', '\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );', '}'].join('\\n'));\n  var LinearTosRGB = new FunctionNode(['vec4 LinearTosRGB( in vec4 value ) {', '\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );', '}'].join('\\n')); // LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\n  // M matrix, for encoding\n\n  var cLogLuvM = new ConstNode('const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );');\n  var LinearToLogLuv = new FunctionNode(['vec4 LinearToLogLuv( in vec4 value ) {', '\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;', '\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));', '\tvec4 vResult;', '\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;', '\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;', '\tvResult.w = fract(Le);', '\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;', '\treturn vResult;', '}'].join('\\n'), [cLogLuvM]); // Inverse M matrix, for decoding\n\n  var cLogLuvInverseM = new ConstNode('const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );');\n  var LogLuvToLinear = new FunctionNode(['vec4 LogLuvToLinear( in vec4 value ) {', '\tfloat Le = value.z * 255.0 + value.w;', '\tvec3 Xp_Y_XYZp;', '\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);', '\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;', '\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;', '\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;', '\treturn vec4( max(vRGB, 0.0), 1.0 );', '}'].join('\\n'), [cLogLuvInverseM]);\n  return {\n    LinearToLinear: LinearToLinear,\n    sRGBToLinear: sRGBToLinear,\n    LinearTosRGB: LinearTosRGB,\n    cLogLuvM: cLogLuvM,\n    LinearToLogLuv: LinearToLogLuv,\n    cLogLuvInverseM: cLogLuvInverseM,\n    LogLuvToLinear: LogLuvToLinear\n  };\n}();\n\nColorSpaceNode.LINEAR_TO_LINEAR = 'LinearToLinear';\nColorSpaceNode.SRGB_TO_LINEAR = 'sRGBToLinear';\nColorSpaceNode.LINEAR_TO_SRGB = 'LinearTosRGB';\nColorSpaceNode.RGBE_TO_LINEAR = 'RGBEToLinear';\nColorSpaceNode.LINEAR_TO_RGBE = 'LinearToRGBE';\nColorSpaceNode.LINEAR_TO_LOG_LUV = 'LinearToLogLuv';\nColorSpaceNode.LOG_LUV_TO_LINEAR = 'LogLuvToLinear';\n\nColorSpaceNode.getEncodingComponents = function (encoding) {\n  switch (encoding) {\n    case LinearEncoding:\n      return ['Linear'];\n\n    case sRGBEncoding:\n      return ['sRGB'];\n  }\n};\n\nColorSpaceNode.prototype = Object.create(TempNode.prototype);\nColorSpaceNode.prototype.constructor = ColorSpaceNode;\nColorSpaceNode.prototype.nodeType = 'ColorSpace';\nColorSpaceNode.prototype.hashProperties = ['method'];\n\nColorSpaceNode.prototype.generate = function (builder, output) {\n  var input = this.input.build(builder, 'v4');\n  var outputType = this.getType(builder);\n  var methodNode = ColorSpaceNode.Nodes[this.method];\n  var method = builder.include(methodNode);\n\n  if (method === ColorSpaceNode.LINEAR_TO_LINEAR) {\n    return builder.format(input, outputType, output);\n  } else {\n    if (methodNode.inputs.length === 2) {\n      var factor = this.factor.build(builder, 'f');\n      return builder.format(method + '( ' + input + ', ' + factor + ' )', outputType, output);\n    } else {\n      return builder.format(method + '( ' + input + ' )', outputType, output);\n    }\n  }\n};\n\nColorSpaceNode.prototype.fromEncoding = function (encoding) {\n  var components = ColorSpaceNode.getEncodingComponents(encoding);\n  this.method = 'LinearTo' + components[0];\n  this.factor = components[1];\n};\n\nColorSpaceNode.prototype.fromDecoding = function (encoding) {\n  var components = ColorSpaceNode.getEncodingComponents(encoding);\n  this.method = components[0] + 'ToLinear';\n  this.factor = components[1];\n};\n\nColorSpaceNode.prototype.copy = function (source) {\n  TempNode.prototype.copy.call(this, source);\n  this.input = source.input;\n  this.method = source.method;\n  return this;\n};\n\nColorSpaceNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.input = this.input.toJSON(meta).uuid;\n    data.method = this.method;\n  }\n\n  return data;\n};\n\nexport { ColorSpaceNode };","map":{"version":3,"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/three-stdlib/nodes/utils/ColorSpaceNode.js"],"names":["sRGBEncoding","LinearEncoding","TempNode","ConstNode","FunctionNode","ColorSpaceNode","input","method","call","LINEAR_TO_LINEAR","Nodes","LinearToLinear","join","sRGBToLinear","LinearTosRGB","cLogLuvM","LinearToLogLuv","cLogLuvInverseM","LogLuvToLinear","SRGB_TO_LINEAR","LINEAR_TO_SRGB","RGBE_TO_LINEAR","LINEAR_TO_RGBE","LINEAR_TO_LOG_LUV","LOG_LUV_TO_LINEAR","getEncodingComponents","encoding","prototype","Object","create","constructor","nodeType","hashProperties","generate","builder","output","build","outputType","getType","methodNode","include","format","inputs","length","factor","fromEncoding","components","fromDecoding","copy","source","toJSON","meta","data","getJSONNode","createJSONNode","uuid"],"mappings":"AAAA,SAASA,YAAT,EAAuBC,cAAvB,QAA6C,OAA7C;AACA,SAASC,QAAT,QAAyB,qBAAzB;AACA,SAASC,SAAT,QAA0B,sBAA1B;AACA,SAASC,YAAT,QAA6B,yBAA7B;;AAEA,SAASC,cAAT,CAAwBC,KAAxB,EAA+BC,MAA/B,EAAuC;AACrCL,EAAAA,QAAQ,CAACM,IAAT,CAAc,IAAd,EAAoB,IAApB;AACA,OAAKF,KAAL,GAAaA,KAAb;AACA,OAAKC,MAAL,GAAcA,MAAM,IAAIF,cAAc,CAACI,gBAAvC;AACD;;AAEDJ,cAAc,CAACK,KAAf,GAAuB,YAAY;AACjC,MAAIC,cAAc,GAAG,IAAIP,YAAJ,CAAiB,CAAC,wCAAD,EAA2C,gBAA3C,EAA6D,GAA7D,EAAkEQ,IAAlE,CAAuE,IAAvE,CAAjB,CAArB;AACA,MAAIC,YAAY,GAAG,IAAIT,YAAJ,CAAiB,CAAC,sCAAD,EAAyC,qLAAzC,EAAgO,GAAhO,EAAqOQ,IAArO,CAA0O,IAA1O,CAAjB,CAAnB;AACA,MAAIE,YAAY,GAAG,IAAIV,YAAJ,CAAiB,CAAC,sCAAD,EAAyC,sKAAzC,EAAiN,GAAjN,EAAsNQ,IAAtN,CAA2N,IAA3N,CAAjB,CAAnB,CAHiC,CAGsO;AACvQ;;AAEA,MAAIG,QAAQ,GAAG,IAAIZ,SAAJ,CAAc,uGAAd,CAAf;AACA,MAAIa,cAAc,GAAG,IAAIZ,YAAJ,CAAiB,CAAC,wCAAD,EAA2C,yCAA3C,EAAsF,sDAAtF,EAA8I,gBAA9I,EAAgK,2CAAhK,EAA6M,8CAA7M,EAA6P,yBAA7P,EAAwR,2DAAxR,EAAqV,kBAArV,EAAyW,GAAzW,EAA8WQ,IAA9W,CAAmX,IAAnX,CAAjB,EAA2Y,CAACG,QAAD,CAA3Y,CAArB,CAPiC,CAO4Y;;AAE7a,MAAIE,eAAe,GAAG,IAAId,SAAJ,CAAc,mHAAd,CAAtB;AACA,MAAIe,cAAc,GAAG,IAAId,YAAJ,CAAiB,CAAC,wCAAD,EAA2C,wCAA3C,EAAqF,kBAArF,EAAyG,0CAAzG,EAAqJ,uCAArJ,EAA8L,uCAA9L,EAAuO,+CAAvO,EAAwR,sCAAxR,EAAgU,GAAhU,EAAqUQ,IAArU,CAA0U,IAA1U,CAAjB,EAAkW,CAACK,eAAD,CAAlW,CAArB;AACA,SAAO;AACLN,IAAAA,cAAc,EAAEA,cADX;AAELE,IAAAA,YAAY,EAAEA,YAFT;AAGLC,IAAAA,YAAY,EAAEA,YAHT;AAILC,IAAAA,QAAQ,EAAEA,QAJL;AAKLC,IAAAA,cAAc,EAAEA,cALX;AAMLC,IAAAA,eAAe,EAAEA,eANZ;AAOLC,IAAAA,cAAc,EAAEA;AAPX,GAAP;AASD,CApBsB,EAAvB;;AAsBAb,cAAc,CAACI,gBAAf,GAAkC,gBAAlC;AACAJ,cAAc,CAACc,cAAf,GAAgC,cAAhC;AACAd,cAAc,CAACe,cAAf,GAAgC,cAAhC;AACAf,cAAc,CAACgB,cAAf,GAAgC,cAAhC;AACAhB,cAAc,CAACiB,cAAf,GAAgC,cAAhC;AACAjB,cAAc,CAACkB,iBAAf,GAAmC,gBAAnC;AACAlB,cAAc,CAACmB,iBAAf,GAAmC,gBAAnC;;AAEAnB,cAAc,CAACoB,qBAAf,GAAuC,UAAUC,QAAV,EAAoB;AACzD,UAAQA,QAAR;AACE,SAAKzB,cAAL;AACE,aAAO,CAAC,QAAD,CAAP;;AAEF,SAAKD,YAAL;AACE,aAAO,CAAC,MAAD,CAAP;AALJ;AAOD,CARD;;AAUAK,cAAc,CAACsB,SAAf,GAA2BC,MAAM,CAACC,MAAP,CAAc3B,QAAQ,CAACyB,SAAvB,CAA3B;AACAtB,cAAc,CAACsB,SAAf,CAAyBG,WAAzB,GAAuCzB,cAAvC;AACAA,cAAc,CAACsB,SAAf,CAAyBI,QAAzB,GAAoC,YAApC;AACA1B,cAAc,CAACsB,SAAf,CAAyBK,cAAzB,GAA0C,CAAC,QAAD,CAA1C;;AAEA3B,cAAc,CAACsB,SAAf,CAAyBM,QAAzB,GAAoC,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC7D,MAAI7B,KAAK,GAAG,KAAKA,KAAL,CAAW8B,KAAX,CAAiBF,OAAjB,EAA0B,IAA1B,CAAZ;AACA,MAAIG,UAAU,GAAG,KAAKC,OAAL,CAAaJ,OAAb,CAAjB;AACA,MAAIK,UAAU,GAAGlC,cAAc,CAACK,KAAf,CAAqB,KAAKH,MAA1B,CAAjB;AACA,MAAIA,MAAM,GAAG2B,OAAO,CAACM,OAAR,CAAgBD,UAAhB,CAAb;;AAEA,MAAIhC,MAAM,KAAKF,cAAc,CAACI,gBAA9B,EAAgD;AAC9C,WAAOyB,OAAO,CAACO,MAAR,CAAenC,KAAf,EAAsB+B,UAAtB,EAAkCF,MAAlC,CAAP;AACD,GAFD,MAEO;AACL,QAAII,UAAU,CAACG,MAAX,CAAkBC,MAAlB,KAA6B,CAAjC,EAAoC;AAClC,UAAIC,MAAM,GAAG,KAAKA,MAAL,CAAYR,KAAZ,CAAkBF,OAAlB,EAA2B,GAA3B,CAAb;AACA,aAAOA,OAAO,CAACO,MAAR,CAAelC,MAAM,GAAG,IAAT,GAAgBD,KAAhB,GAAwB,IAAxB,GAA+BsC,MAA/B,GAAwC,IAAvD,EAA6DP,UAA7D,EAAyEF,MAAzE,CAAP;AACD,KAHD,MAGO;AACL,aAAOD,OAAO,CAACO,MAAR,CAAelC,MAAM,GAAG,IAAT,GAAgBD,KAAhB,GAAwB,IAAvC,EAA6C+B,UAA7C,EAAyDF,MAAzD,CAAP;AACD;AACF;AACF,CAhBD;;AAkBA9B,cAAc,CAACsB,SAAf,CAAyBkB,YAAzB,GAAwC,UAAUnB,QAAV,EAAoB;AAC1D,MAAIoB,UAAU,GAAGzC,cAAc,CAACoB,qBAAf,CAAqCC,QAArC,CAAjB;AACA,OAAKnB,MAAL,GAAc,aAAauC,UAAU,CAAC,CAAD,CAArC;AACA,OAAKF,MAAL,GAAcE,UAAU,CAAC,CAAD,CAAxB;AACD,CAJD;;AAMAzC,cAAc,CAACsB,SAAf,CAAyBoB,YAAzB,GAAwC,UAAUrB,QAAV,EAAoB;AAC1D,MAAIoB,UAAU,GAAGzC,cAAc,CAACoB,qBAAf,CAAqCC,QAArC,CAAjB;AACA,OAAKnB,MAAL,GAAcuC,UAAU,CAAC,CAAD,CAAV,GAAgB,UAA9B;AACA,OAAKF,MAAL,GAAcE,UAAU,CAAC,CAAD,CAAxB;AACD,CAJD;;AAMAzC,cAAc,CAACsB,SAAf,CAAyBqB,IAAzB,GAAgC,UAAUC,MAAV,EAAkB;AAChD/C,EAAAA,QAAQ,CAACyB,SAAT,CAAmBqB,IAAnB,CAAwBxC,IAAxB,CAA6B,IAA7B,EAAmCyC,MAAnC;AACA,OAAK3C,KAAL,GAAa2C,MAAM,CAAC3C,KAApB;AACA,OAAKC,MAAL,GAAc0C,MAAM,CAAC1C,MAArB;AACA,SAAO,IAAP;AACD,CALD;;AAOAF,cAAc,CAACsB,SAAf,CAAyBuB,MAAzB,GAAkC,UAAUC,IAAV,EAAgB;AAChD,MAAIC,IAAI,GAAG,KAAKC,WAAL,CAAiBF,IAAjB,CAAX;;AAEA,MAAI,CAACC,IAAL,EAAW;AACTA,IAAAA,IAAI,GAAG,KAAKE,cAAL,CAAoBH,IAApB,CAAP;AACAC,IAAAA,IAAI,CAAC9C,KAAL,GAAa,KAAKA,KAAL,CAAW4C,MAAX,CAAkBC,IAAlB,EAAwBI,IAArC;AACAH,IAAAA,IAAI,CAAC7C,MAAL,GAAc,KAAKA,MAAnB;AACD;;AAED,SAAO6C,IAAP;AACD,CAVD;;AAYA,SAAS/C,cAAT","sourcesContent":["import { sRGBEncoding, LinearEncoding } from 'three';\nimport { TempNode } from '../core/TempNode.js';\nimport { ConstNode } from '../core/ConstNode.js';\nimport { FunctionNode } from '../core/FunctionNode.js';\n\nfunction ColorSpaceNode(input, method) {\n  TempNode.call(this, 'v4');\n  this.input = input;\n  this.method = method || ColorSpaceNode.LINEAR_TO_LINEAR;\n}\n\nColorSpaceNode.Nodes = function () {\n  var LinearToLinear = new FunctionNode(['vec4 LinearToLinear( in vec4 value ) {', '\treturn value;', '}'].join('\\n'));\n  var sRGBToLinear = new FunctionNode(['vec4 sRGBToLinear( in vec4 value ) {', '\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );', '}'].join('\\n'));\n  var LinearTosRGB = new FunctionNode(['vec4 LinearTosRGB( in vec4 value ) {', '\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );', '}'].join('\\n')); // LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\n  // M matrix, for encoding\n\n  var cLogLuvM = new ConstNode('const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );');\n  var LinearToLogLuv = new FunctionNode(['vec4 LinearToLogLuv( in vec4 value ) {', '\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;', '\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));', '\tvec4 vResult;', '\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;', '\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;', '\tvResult.w = fract(Le);', '\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;', '\treturn vResult;', '}'].join('\\n'), [cLogLuvM]); // Inverse M matrix, for decoding\n\n  var cLogLuvInverseM = new ConstNode('const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );');\n  var LogLuvToLinear = new FunctionNode(['vec4 LogLuvToLinear( in vec4 value ) {', '\tfloat Le = value.z * 255.0 + value.w;', '\tvec3 Xp_Y_XYZp;', '\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);', '\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;', '\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;', '\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;', '\treturn vec4( max(vRGB, 0.0), 1.0 );', '}'].join('\\n'), [cLogLuvInverseM]);\n  return {\n    LinearToLinear: LinearToLinear,\n    sRGBToLinear: sRGBToLinear,\n    LinearTosRGB: LinearTosRGB,\n    cLogLuvM: cLogLuvM,\n    LinearToLogLuv: LinearToLogLuv,\n    cLogLuvInverseM: cLogLuvInverseM,\n    LogLuvToLinear: LogLuvToLinear\n  };\n}();\n\nColorSpaceNode.LINEAR_TO_LINEAR = 'LinearToLinear';\nColorSpaceNode.SRGB_TO_LINEAR = 'sRGBToLinear';\nColorSpaceNode.LINEAR_TO_SRGB = 'LinearTosRGB';\nColorSpaceNode.RGBE_TO_LINEAR = 'RGBEToLinear';\nColorSpaceNode.LINEAR_TO_RGBE = 'LinearToRGBE';\nColorSpaceNode.LINEAR_TO_LOG_LUV = 'LinearToLogLuv';\nColorSpaceNode.LOG_LUV_TO_LINEAR = 'LogLuvToLinear';\n\nColorSpaceNode.getEncodingComponents = function (encoding) {\n  switch (encoding) {\n    case LinearEncoding:\n      return ['Linear'];\n\n    case sRGBEncoding:\n      return ['sRGB'];\n  }\n};\n\nColorSpaceNode.prototype = Object.create(TempNode.prototype);\nColorSpaceNode.prototype.constructor = ColorSpaceNode;\nColorSpaceNode.prototype.nodeType = 'ColorSpace';\nColorSpaceNode.prototype.hashProperties = ['method'];\n\nColorSpaceNode.prototype.generate = function (builder, output) {\n  var input = this.input.build(builder, 'v4');\n  var outputType = this.getType(builder);\n  var methodNode = ColorSpaceNode.Nodes[this.method];\n  var method = builder.include(methodNode);\n\n  if (method === ColorSpaceNode.LINEAR_TO_LINEAR) {\n    return builder.format(input, outputType, output);\n  } else {\n    if (methodNode.inputs.length === 2) {\n      var factor = this.factor.build(builder, 'f');\n      return builder.format(method + '( ' + input + ', ' + factor + ' )', outputType, output);\n    } else {\n      return builder.format(method + '( ' + input + ' )', outputType, output);\n    }\n  }\n};\n\nColorSpaceNode.prototype.fromEncoding = function (encoding) {\n  var components = ColorSpaceNode.getEncodingComponents(encoding);\n  this.method = 'LinearTo' + components[0];\n  this.factor = components[1];\n};\n\nColorSpaceNode.prototype.fromDecoding = function (encoding) {\n  var components = ColorSpaceNode.getEncodingComponents(encoding);\n  this.method = components[0] + 'ToLinear';\n  this.factor = components[1];\n};\n\nColorSpaceNode.prototype.copy = function (source) {\n  TempNode.prototype.copy.call(this, source);\n  this.input = source.input;\n  this.method = source.method;\n  return this;\n};\n\nColorSpaceNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.input = this.input.toJSON(meta).uuid;\n    data.method = this.method;\n  }\n\n  return data;\n};\n\nexport { ColorSpaceNode };\n"]},"metadata":{},"sourceType":"module"}