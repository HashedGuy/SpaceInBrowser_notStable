{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultGrammarValidatorErrorProvider = exports.defaultGrammarResolverErrorProvider = exports.defaultParserErrorProvider = void 0;\n\nvar tokens_public_1 = require(\"../scan/tokens_public\");\n\nvar utils = require(\"@chevrotain/utils\");\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar gast_public_1 = require(\"./grammar/gast/gast_public\");\n\nvar gast_1 = require(\"./grammar/gast/gast\");\n\nexports.defaultParserErrorProvider = {\n  buildMismatchTokenMessage: function buildMismatchTokenMessage(_a) {\n    var expected = _a.expected,\n        actual = _a.actual,\n        previous = _a.previous,\n        ruleName = _a.ruleName;\n    var hasLabel = (0, tokens_public_1.hasTokenLabel)(expected);\n    var expectedMsg = hasLabel ? \"--> \" + (0, tokens_public_1.tokenLabel)(expected) + \" <--\" : \"token of type --> \" + expected.name + \" <--\";\n    var msg = \"Expecting \" + expectedMsg + \" but found --> '\" + actual.image + \"' <--\";\n    return msg;\n  },\n  buildNotAllInputParsedMessage: function buildNotAllInputParsedMessage(_a) {\n    var firstRedundant = _a.firstRedundant,\n        ruleName = _a.ruleName;\n    return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n  },\n  buildNoViableAltMessage: function buildNoViableAltMessage(_a) {\n    var expectedPathsPerAlt = _a.expectedPathsPerAlt,\n        actual = _a.actual,\n        previous = _a.previous,\n        customUserDescription = _a.customUserDescription,\n        ruleName = _a.ruleName;\n    var errPrefix = \"Expecting: \"; // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n\n    var actualText = (0, utils_1.first)(actual).image;\n    var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      var allLookAheadPaths = (0, utils_1.reduce)(expectedPathsPerAlt, function (result, currAltPaths) {\n        return result.concat(currAltPaths);\n      }, []);\n      var nextValidTokenSequences = (0, utils_1.map)(allLookAheadPaths, function (currPath) {\n        return \"[\" + (0, utils_1.map)(currPath, function (currTokenType) {\n          return (0, tokens_public_1.tokenLabel)(currTokenType);\n        }).join(\", \") + \"]\";\n      });\n      var nextValidSequenceItems = (0, utils_1.map)(nextValidTokenSequences, function (itemMsg, idx) {\n        return \"  \" + (idx + 1) + \". \" + itemMsg;\n      });\n      var calculatedDescription = \"one of these possible Token sequences:\\n\" + nextValidSequenceItems.join(\"\\n\");\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  },\n  buildEarlyExitMessage: function buildEarlyExitMessage(_a) {\n    var expectedIterationPaths = _a.expectedIterationPaths,\n        actual = _a.actual,\n        customUserDescription = _a.customUserDescription,\n        ruleName = _a.ruleName;\n    var errPrefix = \"Expecting: \"; // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n\n    var actualText = (0, utils_1.first)(actual).image;\n    var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      var nextValidTokenSequences = (0, utils_1.map)(expectedIterationPaths, function (currPath) {\n        return \"[\" + (0, utils_1.map)(currPath, function (currTokenType) {\n          return (0, tokens_public_1.tokenLabel)(currTokenType);\n        }).join(\",\") + \"]\";\n      });\n      var calculatedDescription = \"expecting at least one iteration which starts with one of these possible Token sequences::\\n  \" + (\"<\" + nextValidTokenSequences.join(\" ,\") + \">\");\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  }\n};\nObject.freeze(exports.defaultParserErrorProvider);\nexports.defaultGrammarResolverErrorProvider = {\n  buildRuleNotFoundError: function buildRuleNotFoundError(topLevelRule, undefinedRule) {\n    var msg = \"Invalid grammar, reference to a rule which is not defined: ->\" + undefinedRule.nonTerminalName + \"<-\\n\" + \"inside top level rule: ->\" + topLevelRule.name + \"<-\";\n    return msg;\n  }\n};\nexports.defaultGrammarValidatorErrorProvider = {\n  buildDuplicateFoundError: function buildDuplicateFoundError(topLevelRule, duplicateProds) {\n    function getExtraProductionArgument(prod) {\n      if (prod instanceof gast_public_1.Terminal) {\n        return prod.terminalType.name;\n      } else if (prod instanceof gast_public_1.NonTerminal) {\n        return prod.nonTerminalName;\n      } else {\n        return \"\";\n      }\n    }\n\n    var topLevelName = topLevelRule.name;\n    var duplicateProd = (0, utils_1.first)(duplicateProds);\n    var index = duplicateProd.idx;\n    var dslName = (0, gast_1.getProductionDslName)(duplicateProd);\n    var extraArgument = getExtraProductionArgument(duplicateProd);\n    var hasExplicitIndex = index > 0;\n    var msg = \"->\" + dslName + (hasExplicitIndex ? index : \"\") + \"<- \" + (extraArgument ? \"with argument: ->\" + extraArgument + \"<-\" : \"\") + \"\\n                  appears more than once (\" + duplicateProds.length + \" times) in the top level rule: ->\" + topLevelName + \"<-.                  \\n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \\n                  \"; // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n\n    msg = msg.replace(/[ \\t]+/g, \" \");\n    msg = msg.replace(/\\s\\s+/g, \"\\n\");\n    return msg;\n  },\n  buildNamespaceConflictError: function buildNamespaceConflictError(rule) {\n    var errMsg = \"Namespace conflict found in grammar.\\n\" + (\"The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <\" + rule.name + \">.\\n\") + \"To resolve this make sure each Terminal and Non-Terminal names are unique\\n\" + \"This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n\" + \"and Non-Terminal names start with a lower case letter.\";\n    return errMsg;\n  },\n  buildAlternationPrefixAmbiguityError: function buildAlternationPrefixAmbiguityError(options) {\n    var pathMsg = (0, utils_1.map)(options.prefixPath, function (currTok) {\n      return (0, tokens_public_1.tokenLabel)(currTok);\n    }).join(\", \");\n    var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    var errMsg = \"Ambiguous alternatives: <\" + options.ambiguityIndices.join(\" ,\") + \"> due to common lookahead prefix\\n\" + (\"in <OR\" + occurrence + \"> inside <\" + options.topLevelRule.name + \"> Rule,\\n\") + (\"<\" + pathMsg + \"> may appears as a prefix path in all these alternatives.\\n\") + \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n\" + \"For Further details.\";\n    return errMsg;\n  },\n  buildAlternationAmbiguityError: function buildAlternationAmbiguityError(options) {\n    var pathMsg = (0, utils_1.map)(options.prefixPath, function (currtok) {\n      return (0, tokens_public_1.tokenLabel)(currtok);\n    }).join(\", \");\n    var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    var currMessage = \"Ambiguous Alternatives Detected: <\" + options.ambiguityIndices.join(\" ,\") + \"> in <OR\" + occurrence + \">\" + (\" inside <\" + options.topLevelRule.name + \"> Rule,\\n\") + (\"<\" + pathMsg + \"> may appears as a prefix path in all these alternatives.\\n\");\n    currMessage = currMessage + \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n\" + \"For Further details.\";\n    return currMessage;\n  },\n  buildEmptyRepetitionError: function buildEmptyRepetitionError(options) {\n    var dslName = (0, gast_1.getProductionDslName)(options.repetition);\n\n    if (options.repetition.idx !== 0) {\n      dslName += options.repetition.idx;\n    }\n\n    var errMsg = \"The repetition <\" + dslName + \"> within Rule <\" + options.topLevelRule.name + \"> can never consume any tokens.\\n\" + \"This could lead to an infinite loop.\";\n    return errMsg;\n  },\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildTokenNameError: function buildTokenNameError(options) {\n    /* istanbul ignore next */\n    return \"deprecated\";\n  },\n  buildEmptyAlternationError: function buildEmptyAlternationError(options) {\n    var errMsg = \"Ambiguous empty alternative: <\" + (options.emptyChoiceIdx + 1) + \">\" + (\" in <OR\" + options.alternation.idx + \"> inside <\" + options.topLevelRule.name + \"> Rule.\\n\") + \"Only the last alternative may be an empty alternative.\";\n    return errMsg;\n  },\n  buildTooManyAlternativesError: function buildTooManyAlternativesError(options) {\n    var errMsg = \"An Alternation cannot have more than 256 alternatives:\\n\" + (\"<OR\" + options.alternation.idx + \"> inside <\" + options.topLevelRule.name + \"> Rule.\\n has \" + (options.alternation.definition.length + 1) + \" alternatives.\");\n    return errMsg;\n  },\n  buildLeftRecursionError: function buildLeftRecursionError(options) {\n    var ruleName = options.topLevelRule.name;\n    var pathNames = utils.map(options.leftRecursionPath, function (currRule) {\n      return currRule.name;\n    });\n    var leftRecursivePath = ruleName + \" --> \" + pathNames.concat([ruleName]).join(\" --> \");\n    var errMsg = \"Left Recursion found in grammar.\\n\" + (\"rule: <\" + ruleName + \"> can be invoked from itself (directly or indirectly)\\n\") + (\"without consuming any Tokens. The grammar path that causes this is: \\n \" + leftRecursivePath + \"\\n\") + \" To fix this refactor your grammar to remove the left recursion.\\n\" + \"see: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.\";\n    return errMsg;\n  },\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildInvalidRuleNameError: function buildInvalidRuleNameError(options) {\n    /* istanbul ignore next */\n    return \"deprecated\";\n  },\n  buildDuplicateRuleNameError: function buildDuplicateRuleNameError(options) {\n    var ruleName;\n\n    if (options.topLevelRule instanceof gast_public_1.Rule) {\n      ruleName = options.topLevelRule.name;\n    } else {\n      ruleName = options.topLevelRule;\n    }\n\n    var errMsg = \"Duplicate definition, rule: ->\" + ruleName + \"<- is already defined in the grammar: ->\" + options.grammarName + \"<-\";\n    return errMsg;\n  }\n};","map":{"version":3,"mappings":"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","names":["exports","buildMismatchTokenMessage","_a","expected","actual","previous","ruleName","hasLabel","expectedMsg","name","msg","image","buildNotAllInputParsedMessage","firstRedundant","buildNoViableAltMessage","expectedPathsPerAlt","customUserDescription","errPrefix","actualText","errSuffix","allLookAheadPaths","result","currAltPaths","concat","nextValidTokenSequences","currPath","currTokenType","join","nextValidSequenceItems","itemMsg","idx","calculatedDescription","buildEarlyExitMessage","expectedIterationPaths","Object","freeze","buildRuleNotFoundError","topLevelRule","undefinedRule","nonTerminalName","buildDuplicateFoundError","duplicateProds","getExtraProductionArgument","prod","gast_public_1","terminalType","topLevelName","duplicateProd","index","dslName","extraArgument","hasExplicitIndex","length","replace","buildNamespaceConflictError","rule","errMsg","buildAlternationPrefixAmbiguityError","options","pathMsg","prefixPath","currTok","occurrence","alternation","ambiguityIndices","buildAlternationAmbiguityError","currtok","currMessage","buildEmptyRepetitionError","repetition","buildTokenNameError","buildEmptyAlternationError","emptyChoiceIdx","buildTooManyAlternativesError","definition","buildLeftRecursionError","pathNames","utils","map","leftRecursionPath","currRule","leftRecursivePath","buildInvalidRuleNameError","buildDuplicateRuleNameError","grammarName"],"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/chevrotain/src/parse/errors_public.ts"],"sourcesContent":["import { hasTokenLabel, tokenLabel } from \"../scan/tokens_public\"\nimport * as utils from \"@chevrotain/utils\"\nimport { first, map, reduce } from \"@chevrotain/utils\"\nimport {\n  Alternation,\n  NonTerminal,\n  Rule,\n  Terminal\n} from \"./grammar/gast/gast_public\"\nimport { getProductionDslName } from \"./grammar/gast/gast\"\nimport {\n  IParserErrorMessageProvider,\n  IProductionWithOccurrence,\n  TokenType\n} from \"@chevrotain/types\"\nimport {\n  IGrammarResolverErrorMessageProvider,\n  IGrammarValidatorErrorMessageProvider\n} from \"./grammar/types\"\n\nexport const defaultParserErrorProvider: IParserErrorMessageProvider = {\n  buildMismatchTokenMessage({ expected, actual, previous, ruleName }): string {\n    const hasLabel = hasTokenLabel(expected)\n    const expectedMsg = hasLabel\n      ? `--> ${tokenLabel(expected)} <--`\n      : `token of type --> ${expected.name} <--`\n\n    const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`\n\n    return msg\n  },\n\n  buildNotAllInputParsedMessage({ firstRedundant, ruleName }): string {\n    return \"Redundant input, expecting EOF but found: \" + firstRedundant.image\n  },\n\n  buildNoViableAltMessage({\n    expectedPathsPerAlt,\n    actual,\n    previous,\n    customUserDescription,\n    ruleName\n  }): string {\n    const errPrefix = \"Expecting: \"\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    const actualText = first(actual).image\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\"\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix\n    } else {\n      const allLookAheadPaths = reduce(\n        expectedPathsPerAlt,\n        (result, currAltPaths) => result.concat(currAltPaths),\n        []\n      )\n      const nextValidTokenSequences = map(\n        allLookAheadPaths,\n        (currPath) =>\n          `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\n            \", \"\n          )}]`\n      )\n      const nextValidSequenceItems = map(\n        nextValidTokenSequences,\n        (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`\n      )\n      const calculatedDescription = `one of these possible Token sequences:\\n${nextValidSequenceItems.join(\n        \"\\n\"\n      )}`\n\n      return errPrefix + calculatedDescription + errSuffix\n    }\n  },\n\n  buildEarlyExitMessage({\n    expectedIterationPaths,\n    actual,\n    customUserDescription,\n    ruleName\n  }): string {\n    const errPrefix = \"Expecting: \"\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    const actualText = first(actual).image\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\"\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix\n    } else {\n      const nextValidTokenSequences = map(\n        expectedIterationPaths,\n        (currPath) =>\n          `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\n            \",\"\n          )}]`\n      )\n      const calculatedDescription =\n        `expecting at least one iteration which starts with one of these possible Token sequences::\\n  ` +\n        `<${nextValidTokenSequences.join(\" ,\")}>`\n\n      return errPrefix + calculatedDescription + errSuffix\n    }\n  }\n}\n\nObject.freeze(defaultParserErrorProvider)\n\nexport const defaultGrammarResolverErrorProvider: IGrammarResolverErrorMessageProvider =\n  {\n    buildRuleNotFoundError(\n      topLevelRule: Rule,\n      undefinedRule: NonTerminal\n    ): string {\n      const msg =\n        \"Invalid grammar, reference to a rule which is not defined: ->\" +\n        undefinedRule.nonTerminalName +\n        \"<-\\n\" +\n        \"inside top level rule: ->\" +\n        topLevelRule.name +\n        \"<-\"\n      return msg\n    }\n  }\n\nexport const defaultGrammarValidatorErrorProvider: IGrammarValidatorErrorMessageProvider =\n  {\n    buildDuplicateFoundError(\n      topLevelRule: Rule,\n      duplicateProds: IProductionWithOccurrence[]\n    ): string {\n      function getExtraProductionArgument(\n        prod: IProductionWithOccurrence\n      ): string {\n        if (prod instanceof Terminal) {\n          return prod.terminalType.name\n        } else if (prod instanceof NonTerminal) {\n          return prod.nonTerminalName\n        } else {\n          return \"\"\n        }\n      }\n\n      const topLevelName = topLevelRule.name\n      const duplicateProd = first(duplicateProds)\n      const index = duplicateProd.idx\n      const dslName = getProductionDslName(duplicateProd)\n      const extraArgument = getExtraProductionArgument(duplicateProd)\n\n      const hasExplicitIndex = index > 0\n      let msg = `->${dslName}${hasExplicitIndex ? index : \"\"}<- ${\n        extraArgument ? `with argument: ->${extraArgument}<-` : \"\"\n      }\n                  appears more than once (${\n                    duplicateProds.length\n                  } times) in the top level rule: ->${topLevelName}<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  `\n\n      // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n      msg = msg.replace(/[ \\t]+/g, \" \")\n      msg = msg.replace(/\\s\\s+/g, \"\\n\")\n\n      return msg\n    },\n\n    buildNamespaceConflictError(rule: Rule): string {\n      const errMsg =\n        `Namespace conflict found in grammar.\\n` +\n        `The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\\n` +\n        `To resolve this make sure each Terminal and Non-Terminal names are unique\\n` +\n        `This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n` +\n        `and Non-Terminal names start with a lower case letter.`\n\n      return errMsg\n    },\n\n    buildAlternationPrefixAmbiguityError(options: {\n      topLevelRule: Rule\n      prefixPath: TokenType[]\n      ambiguityIndices: number[]\n      alternation: Alternation\n    }): string {\n      const pathMsg = map(options.prefixPath, (currTok) =>\n        tokenLabel(currTok)\n      ).join(\", \")\n      const occurrence =\n        options.alternation.idx === 0 ? \"\" : options.alternation.idx\n      const errMsg =\n        `Ambiguous alternatives: <${options.ambiguityIndices.join(\n          \" ,\"\n        )}> due to common lookahead prefix\\n` +\n        `in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n` +\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n` +\n        `For Further details.`\n\n      return errMsg\n    },\n\n    buildAlternationAmbiguityError(options: {\n      topLevelRule: Rule\n      prefixPath: TokenType[]\n      ambiguityIndices: number[]\n      alternation: Alternation\n    }): string {\n      const pathMsg = map(options.prefixPath, (currtok) =>\n        tokenLabel(currtok)\n      ).join(\", \")\n      const occurrence =\n        options.alternation.idx === 0 ? \"\" : options.alternation.idx\n      let currMessage =\n        `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\n          \" ,\"\n        )}> in <OR${occurrence}>` +\n        ` inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`\n\n      currMessage =\n        currMessage +\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\n        `For Further details.`\n      return currMessage\n    },\n\n    buildEmptyRepetitionError(options: {\n      topLevelRule: Rule\n      repetition: IProductionWithOccurrence\n    }): string {\n      let dslName = getProductionDslName(options.repetition)\n      if (options.repetition.idx !== 0) {\n        dslName += options.repetition.idx\n      }\n\n      const errMsg =\n        `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\\n` +\n        `This could lead to an infinite loop.`\n\n      return errMsg\n    },\n\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildTokenNameError(options: {\n      tokenType: TokenType\n      expectedPattern: RegExp\n    }): string {\n      /* istanbul ignore next */\n      return \"deprecated\"\n    },\n\n    buildEmptyAlternationError(options: {\n      topLevelRule: Rule\n      alternation: Alternation\n      emptyChoiceIdx: number\n    }): string {\n      const errMsg =\n        `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}>` +\n        ` in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n` +\n        `Only the last alternative may be an empty alternative.`\n\n      return errMsg\n    },\n\n    buildTooManyAlternativesError(options: {\n      topLevelRule: Rule\n      alternation: Alternation\n    }): string {\n      const errMsg =\n        `An Alternation cannot have more than 256 alternatives:\\n` +\n        `<OR${options.alternation.idx}> inside <${\n          options.topLevelRule.name\n        }> Rule.\\n has ${\n          options.alternation.definition.length + 1\n        } alternatives.`\n\n      return errMsg\n    },\n\n    buildLeftRecursionError(options: {\n      topLevelRule: Rule\n      leftRecursionPath: Rule[]\n    }): string {\n      const ruleName = options.topLevelRule.name\n      const pathNames = utils.map(\n        options.leftRecursionPath,\n        (currRule) => currRule.name\n      )\n      const leftRecursivePath = `${ruleName} --> ${pathNames\n        .concat([ruleName])\n        .join(\" --> \")}`\n      const errMsg =\n        `Left Recursion found in grammar.\\n` +\n        `rule: <${ruleName}> can be invoked from itself (directly or indirectly)\\n` +\n        `without consuming any Tokens. The grammar path that causes this is: \\n ${leftRecursivePath}\\n` +\n        ` To fix this refactor your grammar to remove the left recursion.\\n` +\n        `see: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.`\n\n      return errMsg\n    },\n\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildInvalidRuleNameError(options: {\n      topLevelRule: Rule\n      expectedPattern: RegExp\n    }): string {\n      /* istanbul ignore next */\n      return \"deprecated\"\n    },\n\n    buildDuplicateRuleNameError(options: {\n      topLevelRule: Rule | string\n      grammarName: string\n    }): string {\n      let ruleName\n      if (options.topLevelRule instanceof Rule) {\n        ruleName = options.topLevelRule.name\n      } else {\n        ruleName = options.topLevelRule\n      }\n\n      const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`\n\n      return errMsg\n    }\n  }\n"]},"metadata":{},"sourceType":"script"}