{"ast":null,"code":"import _classCallCheck from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { CompressedTextureLoader, RGBAFormat, RGB_ETC1_Format, RGBA_S3TC_DXT5_Format, RGBA_S3TC_DXT3_Format, RGB_S3TC_DXT1_Format } from 'three';\n\nvar DDSLoader = /*#__PURE__*/function (_CompressedTextureLoa) {\n  _inherits(DDSLoader, _CompressedTextureLoa);\n\n  var _super = _createSuper(DDSLoader);\n\n  function DDSLoader(manager) {\n    _classCallCheck(this, DDSLoader);\n\n    return _super.call(this, manager);\n  }\n\n  _createClass(DDSLoader, [{\n    key: \"parse\",\n    value: function parse(buffer, loadMipmaps) {\n      var dds = {\n        mipmaps: [],\n        width: 0,\n        height: 0,\n        format: null,\n        mipmapCount: 1\n      }; // Adapted from @toji's DDS utils\n      // https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n      // All values and structures referenced from:\n      // http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\n      var DDS_MAGIC = 0x20534444; // let DDSD_CAPS = 0x1;\n      // let DDSD_HEIGHT = 0x2;\n      // let DDSD_WIDTH = 0x4;\n      // let DDSD_PITCH = 0x8;\n      // let DDSD_PIXELFORMAT = 0x1000;\n\n      var DDSD_MIPMAPCOUNT = 0x20000; // let DDSD_LINEARSIZE = 0x80000;\n      // let DDSD_DEPTH = 0x800000;\n      // let DDSCAPS_COMPLEX = 0x8;\n      // let DDSCAPS_MIPMAP = 0x400000;\n      // let DDSCAPS_TEXTURE = 0x1000;\n\n      var DDSCAPS2_CUBEMAP = 0x200;\n      var DDSCAPS2_CUBEMAP_POSITIVEX = 0x400;\n      var DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800;\n      var DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000;\n      var DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000;\n      var DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000;\n      var DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000; // let DDSCAPS2_VOLUME = 0x200000;\n      // let DDPF_ALPHAPIXELS = 0x1;\n      // let DDPF_ALPHA = 0x2;\n\n      var DDPF_FOURCC = 0x4; // let DDPF_RGB = 0x40;\n      // let DDPF_YUV = 0x200;\n      // let DDPF_LUMINANCE = 0x20000;\n\n      function fourCCToInt32(value) {\n        return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\n      }\n\n      function int32ToFourCC(value) {\n        return String.fromCharCode(value & 0xff, value >> 8 & 0xff, value >> 16 & 0xff, value >> 24 & 0xff);\n      }\n\n      function loadARGBMip(buffer, dataOffset, width, height) {\n        var dataLength = width * height * 4;\n        var srcBuffer = new Uint8Array(buffer, dataOffset, dataLength);\n        var byteArray = new Uint8Array(dataLength);\n        var dst = 0;\n        var src = 0;\n\n        for (var y = 0; y < height; y++) {\n          for (var x = 0; x < width; x++) {\n            var b = srcBuffer[src];\n            src++;\n            var g = srcBuffer[src];\n            src++;\n            var r = srcBuffer[src];\n            src++;\n            var a = srcBuffer[src];\n            src++;\n            byteArray[dst] = r;\n            dst++; //r\n\n            byteArray[dst] = g;\n            dst++; //g\n\n            byteArray[dst] = b;\n            dst++; //b\n\n            byteArray[dst] = a;\n            dst++; //a\n          }\n        }\n\n        return byteArray;\n      }\n\n      var FOURCC_DXT1 = fourCCToInt32('DXT1');\n      var FOURCC_DXT3 = fourCCToInt32('DXT3');\n      var FOURCC_DXT5 = fourCCToInt32('DXT5');\n      var FOURCC_ETC1 = fourCCToInt32('ETC1');\n      var headerLengthInt = 31; // The header length in 32 bit ints\n      // Offsets into the header array\n\n      var off_magic = 0;\n      var off_size = 1;\n      var off_flags = 2;\n      var off_height = 3;\n      var off_width = 4;\n      var off_mipmapCount = 7;\n      var off_pfFlags = 20;\n      var off_pfFourCC = 21;\n      var off_RGBBitCount = 22;\n      var off_RBitMask = 23;\n      var off_GBitMask = 24;\n      var off_BBitMask = 25;\n      var off_ABitMask = 26; // let off_caps = 27;\n\n      var off_caps2 = 28; // let off_caps3 = 29;\n      // let off_caps4 = 30;\n      // Parse header\n\n      var header = new Int32Array(buffer, 0, headerLengthInt);\n\n      if (header[off_magic] !== DDS_MAGIC) {\n        console.error('THREE.DDSLoader.parse: Invalid magic number in DDS header.');\n        return dds;\n      }\n\n      if (!header[off_pfFlags] & DDPF_FOURCC) {\n        console.error('THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.');\n        return dds;\n      }\n\n      var blockBytes;\n      var fourCC = header[off_pfFourCC];\n      var isRGBAUncompressed = false;\n\n      switch (fourCC) {\n        case FOURCC_DXT1:\n          blockBytes = 8;\n          dds.format = RGB_S3TC_DXT1_Format;\n          break;\n\n        case FOURCC_DXT3:\n          blockBytes = 16;\n          dds.format = RGBA_S3TC_DXT3_Format;\n          break;\n\n        case FOURCC_DXT5:\n          blockBytes = 16;\n          dds.format = RGBA_S3TC_DXT5_Format;\n          break;\n\n        case FOURCC_ETC1:\n          blockBytes = 8;\n          dds.format = RGB_ETC1_Format;\n          break;\n\n        default:\n          if (header[off_RGBBitCount] === 32 && header[off_RBitMask] & 0xff0000 && header[off_GBitMask] & 0xff00 && header[off_BBitMask] & 0xff && header[off_ABitMask] & 0xff000000) {\n            isRGBAUncompressed = true;\n            blockBytes = 64;\n            dds.format = RGBAFormat;\n          } else {\n            console.error('THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC(fourCC));\n            return dds;\n          }\n\n      }\n\n      dds.mipmapCount = 1;\n\n      if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\n        dds.mipmapCount = Math.max(1, header[off_mipmapCount]);\n      }\n\n      var caps2 = header[off_caps2];\n      dds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;\n\n      if (dds.isCubemap && (!(caps2 & DDSCAPS2_CUBEMAP_POSITIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ))) {\n        console.error('THREE.DDSLoader.parse: Incomplete cubemap faces');\n        return dds;\n      }\n\n      dds.width = header[off_width];\n      dds.height = header[off_height];\n      var dataOffset = header[off_size] + 4; // Extract mipmaps buffers\n\n      var faces = dds.isCubemap ? 6 : 1;\n\n      for (var face = 0; face < faces; face++) {\n        var width = dds.width;\n        var height = dds.height;\n\n        for (var i = 0; i < dds.mipmapCount; i++) {\n          var byteArray = void 0,\n              dataLength = void 0;\n\n          if (isRGBAUncompressed) {\n            byteArray = loadARGBMip(buffer, dataOffset, width, height);\n            dataLength = byteArray.length;\n          } else {\n            dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;\n            byteArray = new Uint8Array(buffer, dataOffset, dataLength);\n          }\n\n          var mipmap = {\n            data: byteArray,\n            width: width,\n            height: height\n          };\n          dds.mipmaps.push(mipmap);\n          dataOffset += dataLength;\n          width = Math.max(width >> 1, 1);\n          height = Math.max(height >> 1, 1);\n        }\n      }\n\n      return dds;\n    }\n  }]);\n\n  return DDSLoader;\n}(CompressedTextureLoader);\n\nexport { DDSLoader };","map":{"version":3,"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/three-stdlib/loaders/DDSLoader.js"],"names":["CompressedTextureLoader","RGBAFormat","RGB_ETC1_Format","RGBA_S3TC_DXT5_Format","RGBA_S3TC_DXT3_Format","RGB_S3TC_DXT1_Format","DDSLoader","manager","buffer","loadMipmaps","dds","mipmaps","width","height","format","mipmapCount","DDS_MAGIC","DDSD_MIPMAPCOUNT","DDSCAPS2_CUBEMAP","DDSCAPS2_CUBEMAP_POSITIVEX","DDSCAPS2_CUBEMAP_NEGATIVEX","DDSCAPS2_CUBEMAP_POSITIVEY","DDSCAPS2_CUBEMAP_NEGATIVEY","DDSCAPS2_CUBEMAP_POSITIVEZ","DDSCAPS2_CUBEMAP_NEGATIVEZ","DDPF_FOURCC","fourCCToInt32","value","charCodeAt","int32ToFourCC","String","fromCharCode","loadARGBMip","dataOffset","dataLength","srcBuffer","Uint8Array","byteArray","dst","src","y","x","b","g","r","a","FOURCC_DXT1","FOURCC_DXT3","FOURCC_DXT5","FOURCC_ETC1","headerLengthInt","off_magic","off_size","off_flags","off_height","off_width","off_mipmapCount","off_pfFlags","off_pfFourCC","off_RGBBitCount","off_RBitMask","off_GBitMask","off_BBitMask","off_ABitMask","off_caps2","header","Int32Array","console","error","blockBytes","fourCC","isRGBAUncompressed","Math","max","caps2","isCubemap","faces","face","i","length","mipmap","data","push"],"mappings":"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","sourcesContent":["import { CompressedTextureLoader, RGBAFormat, RGB_ETC1_Format, RGBA_S3TC_DXT5_Format, RGBA_S3TC_DXT3_Format, RGB_S3TC_DXT1_Format } from 'three';\n\nclass DDSLoader extends CompressedTextureLoader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  parse(buffer, loadMipmaps) {\n    const dds = {\n      mipmaps: [],\n      width: 0,\n      height: 0,\n      format: null,\n      mipmapCount: 1\n    }; // Adapted from @toji's DDS utils\n    // https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n    // All values and structures referenced from:\n    // http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\n    const DDS_MAGIC = 0x20534444; // let DDSD_CAPS = 0x1;\n    // let DDSD_HEIGHT = 0x2;\n    // let DDSD_WIDTH = 0x4;\n    // let DDSD_PITCH = 0x8;\n    // let DDSD_PIXELFORMAT = 0x1000;\n\n    const DDSD_MIPMAPCOUNT = 0x20000; // let DDSD_LINEARSIZE = 0x80000;\n    // let DDSD_DEPTH = 0x800000;\n    // let DDSCAPS_COMPLEX = 0x8;\n    // let DDSCAPS_MIPMAP = 0x400000;\n    // let DDSCAPS_TEXTURE = 0x1000;\n\n    const DDSCAPS2_CUBEMAP = 0x200;\n    const DDSCAPS2_CUBEMAP_POSITIVEX = 0x400;\n    const DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800;\n    const DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000;\n    const DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000;\n    const DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000;\n    const DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000; // let DDSCAPS2_VOLUME = 0x200000;\n    // let DDPF_ALPHAPIXELS = 0x1;\n    // let DDPF_ALPHA = 0x2;\n\n    const DDPF_FOURCC = 0x4; // let DDPF_RGB = 0x40;\n    // let DDPF_YUV = 0x200;\n    // let DDPF_LUMINANCE = 0x20000;\n\n    function fourCCToInt32(value) {\n      return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\n    }\n\n    function int32ToFourCC(value) {\n      return String.fromCharCode(value & 0xff, value >> 8 & 0xff, value >> 16 & 0xff, value >> 24 & 0xff);\n    }\n\n    function loadARGBMip(buffer, dataOffset, width, height) {\n      const dataLength = width * height * 4;\n      const srcBuffer = new Uint8Array(buffer, dataOffset, dataLength);\n      const byteArray = new Uint8Array(dataLength);\n      let dst = 0;\n      let src = 0;\n\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const b = srcBuffer[src];\n          src++;\n          const g = srcBuffer[src];\n          src++;\n          const r = srcBuffer[src];\n          src++;\n          const a = srcBuffer[src];\n          src++;\n          byteArray[dst] = r;\n          dst++; //r\n\n          byteArray[dst] = g;\n          dst++; //g\n\n          byteArray[dst] = b;\n          dst++; //b\n\n          byteArray[dst] = a;\n          dst++; //a\n        }\n      }\n\n      return byteArray;\n    }\n\n    const FOURCC_DXT1 = fourCCToInt32('DXT1');\n    const FOURCC_DXT3 = fourCCToInt32('DXT3');\n    const FOURCC_DXT5 = fourCCToInt32('DXT5');\n    const FOURCC_ETC1 = fourCCToInt32('ETC1');\n    const headerLengthInt = 31; // The header length in 32 bit ints\n    // Offsets into the header array\n\n    const off_magic = 0;\n    const off_size = 1;\n    const off_flags = 2;\n    const off_height = 3;\n    const off_width = 4;\n    const off_mipmapCount = 7;\n    const off_pfFlags = 20;\n    const off_pfFourCC = 21;\n    const off_RGBBitCount = 22;\n    const off_RBitMask = 23;\n    const off_GBitMask = 24;\n    const off_BBitMask = 25;\n    const off_ABitMask = 26; // let off_caps = 27;\n\n    const off_caps2 = 28; // let off_caps3 = 29;\n    // let off_caps4 = 30;\n    // Parse header\n\n    const header = new Int32Array(buffer, 0, headerLengthInt);\n\n    if (header[off_magic] !== DDS_MAGIC) {\n      console.error('THREE.DDSLoader.parse: Invalid magic number in DDS header.');\n      return dds;\n    }\n\n    if (!header[off_pfFlags] & DDPF_FOURCC) {\n      console.error('THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.');\n      return dds;\n    }\n\n    let blockBytes;\n    const fourCC = header[off_pfFourCC];\n    let isRGBAUncompressed = false;\n\n    switch (fourCC) {\n      case FOURCC_DXT1:\n        blockBytes = 8;\n        dds.format = RGB_S3TC_DXT1_Format;\n        break;\n\n      case FOURCC_DXT3:\n        blockBytes = 16;\n        dds.format = RGBA_S3TC_DXT3_Format;\n        break;\n\n      case FOURCC_DXT5:\n        blockBytes = 16;\n        dds.format = RGBA_S3TC_DXT5_Format;\n        break;\n\n      case FOURCC_ETC1:\n        blockBytes = 8;\n        dds.format = RGB_ETC1_Format;\n        break;\n\n      default:\n        if (header[off_RGBBitCount] === 32 && header[off_RBitMask] & 0xff0000 && header[off_GBitMask] & 0xff00 && header[off_BBitMask] & 0xff && header[off_ABitMask] & 0xff000000) {\n          isRGBAUncompressed = true;\n          blockBytes = 64;\n          dds.format = RGBAFormat;\n        } else {\n          console.error('THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC(fourCC));\n          return dds;\n        }\n\n    }\n\n    dds.mipmapCount = 1;\n\n    if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\n      dds.mipmapCount = Math.max(1, header[off_mipmapCount]);\n    }\n\n    const caps2 = header[off_caps2];\n    dds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;\n\n    if (dds.isCubemap && (!(caps2 & DDSCAPS2_CUBEMAP_POSITIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ))) {\n      console.error('THREE.DDSLoader.parse: Incomplete cubemap faces');\n      return dds;\n    }\n\n    dds.width = header[off_width];\n    dds.height = header[off_height];\n    let dataOffset = header[off_size] + 4; // Extract mipmaps buffers\n\n    const faces = dds.isCubemap ? 6 : 1;\n\n    for (let face = 0; face < faces; face++) {\n      let width = dds.width;\n      let height = dds.height;\n\n      for (let i = 0; i < dds.mipmapCount; i++) {\n        let byteArray, dataLength;\n\n        if (isRGBAUncompressed) {\n          byteArray = loadARGBMip(buffer, dataOffset, width, height);\n          dataLength = byteArray.length;\n        } else {\n          dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;\n          byteArray = new Uint8Array(buffer, dataOffset, dataLength);\n        }\n\n        const mipmap = {\n          data: byteArray,\n          width: width,\n          height: height\n        };\n        dds.mipmaps.push(mipmap);\n        dataOffset += dataLength;\n        width = Math.max(width >> 1, 1);\n        height = Math.max(height >> 1, 1);\n      }\n    }\n\n    return dds;\n  }\n\n}\n\nexport { DDSLoader };\n"]},"metadata":{},"sourceType":"module"}