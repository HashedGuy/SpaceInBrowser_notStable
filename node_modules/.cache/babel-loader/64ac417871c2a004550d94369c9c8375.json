{"ast":null,"code":"import _classCallCheck from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Mesh, Vector3, Matrix3 } from 'three';\n/**\n * https://github.com/gkjohnson/ply-exporter-js\n *\n * Usage:\n *  const exporter = new PLYExporter();\n *\n *  // second argument is a list of options\n *  exporter.parse(mesh, data => console.log(data), { binary: true, excludeAttributes: [ 'color' ], littleEndian: true });\n *\n * Format Definition:\n * http://paulbourke.net/dataformats/ply/\n */\n\nvar PLYExporter = /*#__PURE__*/function () {\n  function PLYExporter() {\n    _classCallCheck(this, PLYExporter);\n  }\n\n  _createClass(PLYExporter, [{\n    key: \"parse\",\n    value: function parse(object, onDone, options) {\n      if (onDone && typeof onDone === 'object') {\n        console.warn('THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.');\n        options = onDone;\n        onDone = undefined;\n      } // Default options\n\n\n      var defaultOptions = {\n        binary: false,\n        excludeAttributes: [],\n        // normal, uv, color, index\n        littleEndian: false\n      };\n      options = Object.assign(defaultOptions, options);\n      var excludeAttributes = options.excludeAttributes;\n      var includeNormals = false;\n      var includeColors = false;\n      var includeUVs = false; // count the vertices, check which properties are used,\n      // and cache the BufferGeometry\n\n      var vertexCount = 0;\n      var faceCount = 0;\n      object.traverse(function (child) {\n        if (child instanceof Mesh && child.isMesh) {\n          var mesh = child;\n          var geometry = mesh.geometry;\n\n          if (!geometry.isBufferGeometry) {\n            throw new Error('THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.');\n          }\n\n          var vertices = geometry.getAttribute('position');\n          var normals = geometry.getAttribute('normal');\n          var uvs = geometry.getAttribute('uv');\n          var colors = geometry.getAttribute('color');\n          var indices = geometry.getIndex();\n\n          if (vertices === undefined) {\n            return;\n          }\n\n          vertexCount += vertices.count;\n          faceCount += indices ? indices.count / 3 : vertices.count / 3;\n          if (normals !== undefined) includeNormals = true;\n          if (uvs !== undefined) includeUVs = true;\n          if (colors !== undefined) includeColors = true;\n        }\n      });\n      var includeIndices = (excludeAttributes === null || excludeAttributes === void 0 ? void 0 : excludeAttributes.indexOf('index')) === -1;\n      includeNormals = includeNormals && (excludeAttributes === null || excludeAttributes === void 0 ? void 0 : excludeAttributes.indexOf('normal')) === -1;\n      includeColors = includeColors && (excludeAttributes === null || excludeAttributes === void 0 ? void 0 : excludeAttributes.indexOf('color')) === -1;\n      includeUVs = includeUVs && (excludeAttributes === null || excludeAttributes === void 0 ? void 0 : excludeAttributes.indexOf('uv')) === -1;\n\n      if (includeIndices && faceCount !== Math.floor(faceCount)) {\n        // point cloud meshes will not have an index array and may not have a\n        // number of vertices that is divisble by 3 (and therefore representable\n        // as triangles)\n        console.error('PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' + 'number of indices is not divisible by 3.');\n        return null;\n      }\n\n      var indexByteCount = 4;\n      var header = 'ply\\n' + \"format \".concat(options.binary ? options.littleEndian ? 'binary_little_endian' : 'binary_big_endian' : 'ascii', \" 1.0\\n\") + \"element vertex \".concat(vertexCount, \"\\n\") + // position\n      'property float x\\n' + 'property float y\\n' + 'property float z\\n';\n\n      if (includeNormals) {\n        // normal\n        header += 'property float nx\\n' + 'property float ny\\n' + 'property float nz\\n';\n      }\n\n      if (includeUVs) {\n        // uvs\n        header += 'property float s\\n' + 'property float t\\n';\n      }\n\n      if (includeColors) {\n        // colors\n        header += 'property uchar red\\n' + 'property uchar green\\n' + 'property uchar blue\\n';\n      }\n\n      if (includeIndices) {\n        // faces\n        header += \"\".concat(\"element face \".concat(faceCount, \"\\n\"), \"property list uchar int vertex_index\\n\");\n      }\n\n      header += 'end_header\\n'; // Generate attribute data\n\n      var vertex = new Vector3();\n      var normalMatrixWorld = new Matrix3();\n      var result = null;\n\n      if (options.binary) {\n        // Binary File Generation\n        var headerBin = new TextEncoder().encode(header); // 3 position values at 4 bytes\n        // 3 normal values at 4 bytes\n        // 3 color channels with 1 byte\n        // 2 uv values at 4 bytes\n\n        var vertexListLength = vertexCount * (4 * 3 + (includeNormals ? 4 * 3 : 0) + (includeColors ? 3 : 0) + (includeUVs ? 4 * 2 : 0)); // 1 byte shape desciptor\n        // 3 vertex indices at ${indexByteCount} bytes\n\n        var faceListLength = includeIndices ? faceCount * (indexByteCount * 3 + 1) : 0;\n        var output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength));\n        new Uint8Array(output.buffer).set(headerBin, 0);\n        var vOffset = headerBin.length;\n        var fOffset = headerBin.length + vertexListLength;\n        var writtenVertices = 0;\n        this.traverseMeshes(object, function (mesh, geometry) {\n          var vertices = geometry.getAttribute('position');\n          var normals = geometry.getAttribute('normal');\n          var uvs = geometry.getAttribute('uv');\n          var colors = geometry.getAttribute('color');\n          var indices = geometry.getIndex();\n          normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n\n          for (var i = 0, l = vertices.count; i < l; i++) {\n            vertex.x = vertices.getX(i);\n            vertex.y = vertices.getY(i);\n            vertex.z = vertices.getZ(i);\n            vertex.applyMatrix4(mesh.matrixWorld); // Position information\n\n            output.setFloat32(vOffset, vertex.x, options.littleEndian);\n            vOffset += 4;\n            output.setFloat32(vOffset, vertex.y, options.littleEndian);\n            vOffset += 4;\n            output.setFloat32(vOffset, vertex.z, options.littleEndian);\n            vOffset += 4; // Normal information\n\n            if (includeNormals) {\n              if (normals != null) {\n                vertex.x = normals.getX(i);\n                vertex.y = normals.getY(i);\n                vertex.z = normals.getZ(i);\n                vertex.applyMatrix3(normalMatrixWorld).normalize();\n                output.setFloat32(vOffset, vertex.x, options.littleEndian);\n                vOffset += 4;\n                output.setFloat32(vOffset, vertex.y, options.littleEndian);\n                vOffset += 4;\n                output.setFloat32(vOffset, vertex.z, options.littleEndian);\n                vOffset += 4;\n              } else {\n                output.setFloat32(vOffset, 0, options.littleEndian);\n                vOffset += 4;\n                output.setFloat32(vOffset, 0, options.littleEndian);\n                vOffset += 4;\n                output.setFloat32(vOffset, 0, options.littleEndian);\n                vOffset += 4;\n              }\n            } // UV information\n\n\n            if (includeUVs) {\n              if (uvs != null) {\n                output.setFloat32(vOffset, uvs.getX(i), options.littleEndian);\n                vOffset += 4;\n                output.setFloat32(vOffset, uvs.getY(i), options.littleEndian);\n                vOffset += 4;\n              } else if (!includeUVs) {\n                output.setFloat32(vOffset, 0, options.littleEndian);\n                vOffset += 4;\n                output.setFloat32(vOffset, 0, options.littleEndian);\n                vOffset += 4;\n              }\n            } // Color information\n\n\n            if (includeColors) {\n              if (colors != null) {\n                output.setUint8(vOffset, Math.floor(colors.getX(i) * 255));\n                vOffset += 1;\n                output.setUint8(vOffset, Math.floor(colors.getY(i) * 255));\n                vOffset += 1;\n                output.setUint8(vOffset, Math.floor(colors.getZ(i) * 255));\n                vOffset += 1;\n              } else {\n                output.setUint8(vOffset, 255);\n                vOffset += 1;\n                output.setUint8(vOffset, 255);\n                vOffset += 1;\n                output.setUint8(vOffset, 255);\n                vOffset += 1;\n              }\n            }\n          }\n\n          if (includeIndices) {\n            // Create the face list\n            if (indices !== null) {\n              for (var _i = 0, _l = indices.count; _i < _l; _i += 3) {\n                output.setUint8(fOffset, 3);\n                fOffset += 1;\n                output.setUint32(fOffset, indices.getX(_i + 0) + writtenVertices, options.littleEndian);\n                fOffset += indexByteCount;\n                output.setUint32(fOffset, indices.getX(_i + 1) + writtenVertices, options.littleEndian);\n                fOffset += indexByteCount;\n                output.setUint32(fOffset, indices.getX(_i + 2) + writtenVertices, options.littleEndian);\n                fOffset += indexByteCount;\n              }\n            } else {\n              for (var _i2 = 0, _l2 = vertices.count; _i2 < _l2; _i2 += 3) {\n                output.setUint8(fOffset, 3);\n                fOffset += 1;\n                output.setUint32(fOffset, writtenVertices + _i2, options.littleEndian);\n                fOffset += indexByteCount;\n                output.setUint32(fOffset, writtenVertices + _i2 + 1, options.littleEndian);\n                fOffset += indexByteCount;\n                output.setUint32(fOffset, writtenVertices + _i2 + 2, options.littleEndian);\n                fOffset += indexByteCount;\n              }\n            }\n          } // Save the amount of verts we've already written so we can offset\n          // the face index on the next mesh\n\n\n          writtenVertices += vertices.count;\n        });\n        result = output.buffer;\n      } else {\n        // Ascii File Generation\n        // count the number of vertices\n        var _writtenVertices = 0;\n        var vertexList = '';\n        var faceList = '';\n        this.traverseMeshes(object, function (mesh, geometry) {\n          var vertices = geometry.getAttribute('position');\n          var normals = geometry.getAttribute('normal');\n          var uvs = geometry.getAttribute('uv');\n          var colors = geometry.getAttribute('color');\n          var indices = geometry.getIndex();\n          normalMatrixWorld.getNormalMatrix(mesh.matrixWorld); // form each line\n\n          for (var i = 0, l = vertices.count; i < l; i++) {\n            vertex.x = vertices.getX(i);\n            vertex.y = vertices.getY(i);\n            vertex.z = vertices.getZ(i);\n            vertex.applyMatrix4(mesh.matrixWorld); // Position information\n\n            var line = vertex.x + ' ' + vertex.y + ' ' + vertex.z; // Normal information\n\n            if (includeNormals) {\n              if (normals != null) {\n                vertex.x = normals.getX(i);\n                vertex.y = normals.getY(i);\n                vertex.z = normals.getZ(i);\n                vertex.applyMatrix3(normalMatrixWorld).normalize();\n                line += ' ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z;\n              } else {\n                line += ' 0 0 0';\n              }\n            } // UV information\n\n\n            if (includeUVs) {\n              if (uvs != null) {\n                line += ' ' + uvs.getX(i) + ' ' + uvs.getY(i);\n              } else if (includeUVs) {\n                line += ' 0 0';\n              }\n            } // Color information\n\n\n            if (includeColors) {\n              if (colors != null) {\n                line += ' ' + Math.floor(colors.getX(i) * 255) + ' ' + Math.floor(colors.getY(i) * 255) + ' ' + Math.floor(colors.getZ(i) * 255);\n              } else {\n                line += ' 255 255 255';\n              }\n            }\n\n            vertexList += line + '\\n';\n          } // Create the face list\n\n\n          if (includeIndices) {\n            if (indices !== null) {\n              for (var _i3 = 0, _l3 = indices.count; _i3 < _l3; _i3 += 3) {\n                faceList += \"3 \".concat(indices.getX(_i3 + 0) + _writtenVertices);\n                faceList += \" \".concat(indices.getX(_i3 + 1) + _writtenVertices);\n                faceList += \" \".concat(indices.getX(_i3 + 2) + _writtenVertices, \"\\n\");\n              }\n            } else {\n              for (var _i4 = 0, _l4 = vertices.count; _i4 < _l4; _i4 += 3) {\n                faceList += \"3 \".concat(_writtenVertices + _i4, \" \").concat(_writtenVertices + _i4 + 1, \" \").concat(_writtenVertices + _i4 + 2, \"\\n\");\n              }\n            }\n\n            faceCount += indices ? indices.count / 3 : vertices.count / 3;\n          }\n\n          _writtenVertices += vertices.count;\n        });\n        result = \"\".concat(header).concat(vertexList).concat(includeIndices ? \"\".concat(faceList, \"\\n\") : '\\n');\n      }\n\n      if (typeof onDone === 'function') {\n        requestAnimationFrame(function () {\n          return onDone && onDone(typeof result === 'string' ? result : '');\n        });\n      }\n\n      return result;\n    } // Iterate over the valid meshes in the object\n\n  }, {\n    key: \"traverseMeshes\",\n    value: function traverseMeshes(object, cb) {\n      object.traverse(function (child) {\n        if (child instanceof Mesh && child.isMesh) {\n          var mesh = child;\n          var geometry = mesh.geometry;\n\n          if (!geometry.isBufferGeometry) {\n            throw new Error('THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.');\n          }\n\n          if (geometry.hasAttribute('position')) {\n            cb(mesh, geometry);\n          }\n        }\n      });\n    }\n  }]);\n\n  return PLYExporter;\n}();\n\nexport { PLYExporter };","map":{"version":3,"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/three-stdlib/exporters/PLYExporter.js"],"names":["Mesh","Vector3","Matrix3","PLYExporter","object","onDone","options","console","warn","undefined","defaultOptions","binary","excludeAttributes","littleEndian","Object","assign","includeNormals","includeColors","includeUVs","vertexCount","faceCount","traverse","child","isMesh","mesh","geometry","isBufferGeometry","Error","vertices","getAttribute","normals","uvs","colors","indices","getIndex","count","includeIndices","indexOf","Math","floor","error","indexByteCount","header","vertex","normalMatrixWorld","result","headerBin","TextEncoder","encode","vertexListLength","faceListLength","output","DataView","ArrayBuffer","length","Uint8Array","buffer","set","vOffset","fOffset","writtenVertices","traverseMeshes","getNormalMatrix","matrixWorld","i","l","x","getX","y","getY","z","getZ","applyMatrix4","setFloat32","applyMatrix3","normalize","setUint8","setUint32","vertexList","faceList","line","requestAnimationFrame","cb","hasAttribute"],"mappings":"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","sourcesContent":["import { Mesh, Vector3, Matrix3 } from 'three';\n\n/**\n * https://github.com/gkjohnson/ply-exporter-js\n *\n * Usage:\n *  const exporter = new PLYExporter();\n *\n *  // second argument is a list of options\n *  exporter.parse(mesh, data => console.log(data), { binary: true, excludeAttributes: [ 'color' ], littleEndian: true });\n *\n * Format Definition:\n * http://paulbourke.net/dataformats/ply/\n */\n\nclass PLYExporter {\n  parse(object, onDone, options) {\n    if (onDone && typeof onDone === 'object') {\n      console.warn('THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.');\n      options = onDone;\n      onDone = undefined;\n    } // Default options\n\n\n    const defaultOptions = {\n      binary: false,\n      excludeAttributes: [],\n      // normal, uv, color, index\n      littleEndian: false\n    };\n    options = Object.assign(defaultOptions, options);\n    const excludeAttributes = options.excludeAttributes;\n    let includeNormals = false;\n    let includeColors = false;\n    let includeUVs = false; // count the vertices, check which properties are used,\n    // and cache the BufferGeometry\n\n    let vertexCount = 0;\n    let faceCount = 0;\n    object.traverse(function (child) {\n      if (child instanceof Mesh && child.isMesh) {\n        const mesh = child;\n        const geometry = mesh.geometry;\n\n        if (!geometry.isBufferGeometry) {\n          throw new Error('THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.');\n        }\n\n        const vertices = geometry.getAttribute('position');\n        const normals = geometry.getAttribute('normal');\n        const uvs = geometry.getAttribute('uv');\n        const colors = geometry.getAttribute('color');\n        const indices = geometry.getIndex();\n\n        if (vertices === undefined) {\n          return;\n        }\n\n        vertexCount += vertices.count;\n        faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        if (normals !== undefined) includeNormals = true;\n        if (uvs !== undefined) includeUVs = true;\n        if (colors !== undefined) includeColors = true;\n      }\n    });\n    const includeIndices = (excludeAttributes === null || excludeAttributes === void 0 ? void 0 : excludeAttributes.indexOf('index')) === -1;\n    includeNormals = includeNormals && (excludeAttributes === null || excludeAttributes === void 0 ? void 0 : excludeAttributes.indexOf('normal')) === -1;\n    includeColors = includeColors && (excludeAttributes === null || excludeAttributes === void 0 ? void 0 : excludeAttributes.indexOf('color')) === -1;\n    includeUVs = includeUVs && (excludeAttributes === null || excludeAttributes === void 0 ? void 0 : excludeAttributes.indexOf('uv')) === -1;\n\n    if (includeIndices && faceCount !== Math.floor(faceCount)) {\n      // point cloud meshes will not have an index array and may not have a\n      // number of vertices that is divisble by 3 (and therefore representable\n      // as triangles)\n      console.error('PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' + 'number of indices is not divisible by 3.');\n      return null;\n    }\n\n    const indexByteCount = 4;\n    let header = 'ply\\n' + `format ${options.binary ? options.littleEndian ? 'binary_little_endian' : 'binary_big_endian' : 'ascii'} 1.0\\n` + `element vertex ${vertexCount}\\n` + // position\n    'property float x\\n' + 'property float y\\n' + 'property float z\\n';\n\n    if (includeNormals) {\n      // normal\n      header += 'property float nx\\n' + 'property float ny\\n' + 'property float nz\\n';\n    }\n\n    if (includeUVs) {\n      // uvs\n      header += 'property float s\\n' + 'property float t\\n';\n    }\n\n    if (includeColors) {\n      // colors\n      header += 'property uchar red\\n' + 'property uchar green\\n' + 'property uchar blue\\n';\n    }\n\n    if (includeIndices) {\n      // faces\n      header += `${`element face ${faceCount}\\n`}property list uchar int vertex_index\\n`;\n    }\n\n    header += 'end_header\\n'; // Generate attribute data\n\n    const vertex = new Vector3();\n    const normalMatrixWorld = new Matrix3();\n    let result = null;\n\n    if (options.binary) {\n      // Binary File Generation\n      const headerBin = new TextEncoder().encode(header); // 3 position values at 4 bytes\n      // 3 normal values at 4 bytes\n      // 3 color channels with 1 byte\n      // 2 uv values at 4 bytes\n\n      const vertexListLength = vertexCount * (4 * 3 + (includeNormals ? 4 * 3 : 0) + (includeColors ? 3 : 0) + (includeUVs ? 4 * 2 : 0)); // 1 byte shape desciptor\n      // 3 vertex indices at ${indexByteCount} bytes\n\n      const faceListLength = includeIndices ? faceCount * (indexByteCount * 3 + 1) : 0;\n      const output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength));\n      new Uint8Array(output.buffer).set(headerBin, 0);\n      let vOffset = headerBin.length;\n      let fOffset = headerBin.length + vertexListLength;\n      let writtenVertices = 0;\n      this.traverseMeshes(object, function (mesh, geometry) {\n        const vertices = geometry.getAttribute('position');\n        const normals = geometry.getAttribute('normal');\n        const uvs = geometry.getAttribute('uv');\n        const colors = geometry.getAttribute('color');\n        const indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i);\n          vertex.applyMatrix4(mesh.matrixWorld); // Position information\n\n          output.setFloat32(vOffset, vertex.x, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.y, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.z, options.littleEndian);\n          vOffset += 4; // Normal information\n\n          if (includeNormals) {\n            if (normals != null) {\n              vertex.x = normals.getX(i);\n              vertex.y = normals.getY(i);\n              vertex.z = normals.getZ(i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              output.setFloat32(vOffset, vertex.x, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.y, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.z, options.littleEndian);\n              vOffset += 4;\n            } else {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          } // UV information\n\n\n          if (includeUVs) {\n            if (uvs != null) {\n              output.setFloat32(vOffset, uvs.getX(i), options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, uvs.getY(i), options.littleEndian);\n              vOffset += 4;\n            } else if (!includeUVs) {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          } // Color information\n\n\n          if (includeColors) {\n            if (colors != null) {\n              output.setUint8(vOffset, Math.floor(colors.getX(i) * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(colors.getY(i) * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(colors.getZ(i) * 255));\n              vOffset += 1;\n            } else {\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n            }\n          }\n        }\n\n        if (includeIndices) {\n          // Create the face list\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, indices.getX(i + 0) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(i + 1) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(i + 2) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, writtenVertices + i, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + i + 1, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + i + 2, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          }\n        } // Save the amount of verts we've already written so we can offset\n        // the face index on the next mesh\n\n\n        writtenVertices += vertices.count;\n      });\n      result = output.buffer;\n    } else {\n      // Ascii File Generation\n      // count the number of vertices\n      let writtenVertices = 0;\n      let vertexList = '';\n      let faceList = '';\n      this.traverseMeshes(object, function (mesh, geometry) {\n        const vertices = geometry.getAttribute('position');\n        const normals = geometry.getAttribute('normal');\n        const uvs = geometry.getAttribute('uv');\n        const colors = geometry.getAttribute('color');\n        const indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld); // form each line\n\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i);\n          vertex.applyMatrix4(mesh.matrixWorld); // Position information\n\n          let line = vertex.x + ' ' + vertex.y + ' ' + vertex.z; // Normal information\n\n          if (includeNormals) {\n            if (normals != null) {\n              vertex.x = normals.getX(i);\n              vertex.y = normals.getY(i);\n              vertex.z = normals.getZ(i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              line += ' ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z;\n            } else {\n              line += ' 0 0 0';\n            }\n          } // UV information\n\n\n          if (includeUVs) {\n            if (uvs != null) {\n              line += ' ' + uvs.getX(i) + ' ' + uvs.getY(i);\n            } else if (includeUVs) {\n              line += ' 0 0';\n            }\n          } // Color information\n\n\n          if (includeColors) {\n            if (colors != null) {\n              line += ' ' + Math.floor(colors.getX(i) * 255) + ' ' + Math.floor(colors.getY(i) * 255) + ' ' + Math.floor(colors.getZ(i) * 255);\n            } else {\n              line += ' 255 255 255';\n            }\n          }\n\n          vertexList += line + '\\n';\n        } // Create the face list\n\n\n        if (includeIndices) {\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              faceList += `3 ${indices.getX(i + 0) + writtenVertices}`;\n              faceList += ` ${indices.getX(i + 1) + writtenVertices}`;\n              faceList += ` ${indices.getX(i + 2) + writtenVertices}\\n`;\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              faceList += `3 ${writtenVertices + i} ${writtenVertices + i + 1} ${writtenVertices + i + 2}\\n`;\n            }\n          }\n\n          faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        }\n\n        writtenVertices += vertices.count;\n      });\n      result = `${header}${vertexList}${includeIndices ? `${faceList}\\n` : '\\n'}`;\n    }\n\n    if (typeof onDone === 'function') {\n      requestAnimationFrame(() => onDone && onDone(typeof result === 'string' ? result : ''));\n    }\n\n    return result;\n  } // Iterate over the valid meshes in the object\n\n\n  traverseMeshes(object, cb) {\n    object.traverse(function (child) {\n      if (child instanceof Mesh && child.isMesh) {\n        const mesh = child;\n        const geometry = mesh.geometry;\n\n        if (!geometry.isBufferGeometry) {\n          throw new Error('THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.');\n        }\n\n        if (geometry.hasAttribute('position')) {\n          cb(mesh, geometry);\n        }\n      }\n    });\n  }\n\n}\n\nexport { PLYExporter };\n"]},"metadata":{},"sourceType":"module"}