{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GastRecorder = void 0;\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar gast_public_1 = require(\"../../grammar/gast/gast_public\");\n\nvar lexer_public_1 = require(\"../../../scan/lexer_public\");\n\nvar tokens_1 = require(\"../../../scan/tokens\");\n\nvar tokens_public_1 = require(\"../../../scan/tokens_public\");\n\nvar parser_1 = require(\"../parser\");\n\nvar keys_1 = require(\"../../grammar/keys\");\n\nvar RECORDING_NULL_OBJECT = {\n  description: \"This Object indicates the Parser is during Recording Phase\"\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nvar HANDLE_SEPARATOR = true;\nvar MAX_METHOD_IDX = Math.pow(2, keys_1.BITS_FOR_OCCURRENCE_IDX) - 1;\nvar RFT = (0, tokens_public_1.createToken)({\n  name: \"RECORDING_PHASE_TOKEN\",\n  pattern: lexer_public_1.Lexer.NA\n});\n(0, tokens_1.augmentTokenTypes)([RFT]);\nvar RECORDING_PHASE_TOKEN = (0, tokens_public_1.createTokenInstance)(RFT, \"This IToken indicates the Parser is in Recording Phase\\n\\t\" + \"\" + \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\", // Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n-1, -1, -1, -1, -1, -1);\nObject.freeze(RECORDING_PHASE_TOKEN);\nvar RECORDING_PHASE_CSTNODE = {\n  name: \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" + \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  children: {}\n};\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\n\nvar GastRecorder =\n/** @class */\nfunction () {\n  function GastRecorder() {}\n\n  GastRecorder.prototype.initGastRecorder = function (config) {\n    this.recordingProdStack = [];\n    this.RECORDING_PHASE = false;\n  };\n\n  GastRecorder.prototype.enableRecording = function () {\n    var _this = this;\n\n    this.RECORDING_PHASE = true;\n    this.TRACE_INIT(\"Enable Recording\", function () {\n      var _loop_1 = function _loop_1(i) {\n        var idx = i > 0 ? i : \"\";\n\n        _this[\"CONSUME\" + idx] = function (arg1, arg2) {\n          return this.consumeInternalRecord(arg1, i, arg2);\n        };\n\n        _this[\"SUBRULE\" + idx] = function (arg1, arg2) {\n          return this.subruleInternalRecord(arg1, i, arg2);\n        };\n\n        _this[\"OPTION\" + idx] = function (arg1) {\n          return this.optionInternalRecord(arg1, i);\n        };\n\n        _this[\"OR\" + idx] = function (arg1) {\n          return this.orInternalRecord(arg1, i);\n        };\n\n        _this[\"MANY\" + idx] = function (arg1) {\n          this.manyInternalRecord(i, arg1);\n        };\n\n        _this[\"MANY_SEP\" + idx] = function (arg1) {\n          this.manySepFirstInternalRecord(i, arg1);\n        };\n\n        _this[\"AT_LEAST_ONE\" + idx] = function (arg1) {\n          this.atLeastOneInternalRecord(i, arg1);\n        };\n\n        _this[\"AT_LEAST_ONE_SEP\" + idx] = function (arg1) {\n          this.atLeastOneSepFirstInternalRecord(i, arg1);\n        };\n      };\n      /**\n       * Warning Dark Voodoo Magic upcoming!\n       * We are \"replacing\" the public parsing DSL methods API\n       * With **new** alternative implementations on the Parser **instance**\n       *\n       * So far this is the only way I've found to avoid performance regressions during parsing time.\n       * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n       *   implementations directly instead.\n       */\n\n\n      for (var i = 0; i < 10; i++) {\n        _loop_1(i);\n      } // DSL methods with the idx(suffix) as an argument\n\n\n      _this[\"consume\"] = function (idx, arg1, arg2) {\n        return this.consumeInternalRecord(arg1, idx, arg2);\n      };\n\n      _this[\"subrule\"] = function (idx, arg1, arg2) {\n        return this.subruleInternalRecord(arg1, idx, arg2);\n      };\n\n      _this[\"option\"] = function (idx, arg1) {\n        return this.optionInternalRecord(arg1, idx);\n      };\n\n      _this[\"or\"] = function (idx, arg1) {\n        return this.orInternalRecord(arg1, idx);\n      };\n\n      _this[\"many\"] = function (idx, arg1) {\n        this.manyInternalRecord(idx, arg1);\n      };\n\n      _this[\"atLeastOne\"] = function (idx, arg1) {\n        this.atLeastOneInternalRecord(idx, arg1);\n      };\n\n      _this.ACTION = _this.ACTION_RECORD;\n      _this.BACKTRACK = _this.BACKTRACK_RECORD;\n      _this.LA = _this.LA_RECORD;\n    });\n  };\n\n  GastRecorder.prototype.disableRecording = function () {\n    var _this = this;\n\n    this.RECORDING_PHASE = false; // By deleting these **instance** properties, any future invocation\n    // will be deferred to the original methods on the **prototype** object\n    // This seems to get rid of any incorrect optimizations that V8 may\n    // do during the recording phase.\n\n    this.TRACE_INIT(\"Deleting Recording methods\", function () {\n      for (var i = 0; i < 10; i++) {\n        var idx = i > 0 ? i : \"\";\n        delete _this[\"CONSUME\" + idx];\n        delete _this[\"SUBRULE\" + idx];\n        delete _this[\"OPTION\" + idx];\n        delete _this[\"OR\" + idx];\n        delete _this[\"MANY\" + idx];\n        delete _this[\"MANY_SEP\" + idx];\n        delete _this[\"AT_LEAST_ONE\" + idx];\n        delete _this[\"AT_LEAST_ONE_SEP\" + idx];\n      }\n\n      delete _this[\"consume\"];\n      delete _this[\"subrule\"];\n      delete _this[\"option\"];\n      delete _this[\"or\"];\n      delete _this[\"many\"];\n      delete _this[\"atLeastOne\"];\n      delete _this.ACTION;\n      delete _this.BACKTRACK;\n      delete _this.LA;\n    });\n  }; // TODO: is there any way to use this method to check no\n  //   Parser methods are called inside an ACTION?\n  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n\n\n  GastRecorder.prototype.ACTION_RECORD = function (impl) {\n    // NO-OP during recording\n    return;\n  }; // Executing backtracking logic will break our recording logic assumptions\n\n\n  GastRecorder.prototype.BACKTRACK_RECORD = function (grammarRule, args) {\n    return function () {\n      return true;\n    };\n  }; // LA is part of the official API and may be used for custom lookahead logic\n  // by end users who may forget to wrap it in ACTION or inside a GATE\n\n\n  GastRecorder.prototype.LA_RECORD = function (howMuch) {\n    // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n    // On LA return EOF at the end of the input so an infinite loop may occur.\n    return parser_1.END_OF_FILE;\n  };\n\n  GastRecorder.prototype.topLevelRuleRecord = function (name, def) {\n    try {\n      var newTopLevelRule = new gast_public_1.Rule({\n        definition: [],\n        name: name\n      });\n      newTopLevelRule.name = name;\n      this.recordingProdStack.push(newTopLevelRule);\n      def.call(this);\n      this.recordingProdStack.pop();\n      return newTopLevelRule;\n    } catch (originalError) {\n      if (originalError.KNOWN_RECORDER_ERROR !== true) {\n        try {\n          originalError.message = originalError.message + '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' + \"https://chevrotain.io/docs/guide/internals.html#grammar-recording\";\n        } catch (mutabilityError) {\n          // We may not be able to modify the original error object\n          throw originalError;\n        }\n      }\n\n      throw originalError;\n    }\n  }; // Implementation of parsing DSL\n\n\n  GastRecorder.prototype.optionInternalRecord = function (actionORMethodDef, occurrence) {\n    return recordProd.call(this, gast_public_1.Option, actionORMethodDef, occurrence);\n  };\n\n  GastRecorder.prototype.atLeastOneInternalRecord = function (occurrence, actionORMethodDef) {\n    recordProd.call(this, gast_public_1.RepetitionMandatory, actionORMethodDef, occurrence);\n  };\n\n  GastRecorder.prototype.atLeastOneSepFirstInternalRecord = function (occurrence, options) {\n    recordProd.call(this, gast_public_1.RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n  };\n\n  GastRecorder.prototype.manyInternalRecord = function (occurrence, actionORMethodDef) {\n    recordProd.call(this, gast_public_1.Repetition, actionORMethodDef, occurrence);\n  };\n\n  GastRecorder.prototype.manySepFirstInternalRecord = function (occurrence, options) {\n    recordProd.call(this, gast_public_1.RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n  };\n\n  GastRecorder.prototype.orInternalRecord = function (altsOrOpts, occurrence) {\n    return recordOrProd.call(this, altsOrOpts, occurrence);\n  };\n\n  GastRecorder.prototype.subruleInternalRecord = function (ruleToCall, occurrence, options) {\n    assertMethodIdxIsValid(occurrence);\n\n    if (!ruleToCall || (0, utils_1.has)(ruleToCall, \"ruleName\") === false) {\n      var error = new Error(\"<SUBRULE\" + getIdxSuffix(occurrence) + \"> argument is invalid\" + (\" expecting a Parser method reference but got: <\" + JSON.stringify(ruleToCall) + \">\") + (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n\n    var prevProd = (0, utils_1.peek)(this.recordingProdStack);\n    var ruleName = ruleToCall[\"ruleName\"];\n    var newNoneTerminal = new gast_public_1.NonTerminal({\n      idx: occurrence,\n      nonTerminalName: ruleName,\n      label: options === null || options === void 0 ? void 0 : options.LABEL,\n      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n      referencedRule: undefined\n    });\n    prevProd.definition.push(newNoneTerminal);\n    return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;\n  };\n\n  GastRecorder.prototype.consumeInternalRecord = function (tokType, occurrence, options) {\n    assertMethodIdxIsValid(occurrence);\n\n    if (!(0, tokens_1.hasShortKeyProperty)(tokType)) {\n      var error = new Error(\"<CONSUME\" + getIdxSuffix(occurrence) + \"> argument is invalid\" + (\" expecting a TokenType reference but got: <\" + JSON.stringify(tokType) + \">\") + (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n\n    var prevProd = (0, utils_1.peek)(this.recordingProdStack);\n    var newNoneTerminal = new gast_public_1.Terminal({\n      idx: occurrence,\n      terminalType: tokType,\n      label: options === null || options === void 0 ? void 0 : options.LABEL\n    });\n    prevProd.definition.push(newNoneTerminal);\n    return RECORDING_PHASE_TOKEN;\n  };\n\n  return GastRecorder;\n}();\n\nexports.GastRecorder = GastRecorder;\n\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {\n  if (handleSep === void 0) {\n    handleSep = false;\n  }\n\n  assertMethodIdxIsValid(occurrence);\n  var prevProd = (0, utils_1.peek)(this.recordingProdStack);\n  var grammarAction = (0, utils_1.isFunction)(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n  var newProd = new prodConstructor({\n    definition: [],\n    idx: occurrence\n  });\n\n  if (handleSep) {\n    newProd.separator = mainProdArg.SEP;\n  }\n\n  if ((0, utils_1.has)(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n\n  this.recordingProdStack.push(newProd);\n  grammarAction.call(this);\n  prevProd.definition.push(newProd);\n  this.recordingProdStack.pop();\n  return RECORDING_NULL_OBJECT;\n}\n\nfunction recordOrProd(mainProdArg, occurrence) {\n  var _this = this;\n\n  assertMethodIdxIsValid(occurrence);\n  var prevProd = (0, utils_1.peek)(this.recordingProdStack); // Only an array of alternatives\n\n  var hasOptions = (0, utils_1.isArray)(mainProdArg) === false;\n  var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n  var newOrProd = new gast_public_1.Alternation({\n    definition: [],\n    idx: occurrence,\n    ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n  });\n\n  if ((0, utils_1.has)(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n\n  var hasPredicates = (0, utils_1.some)(alts, function (currAlt) {\n    return (0, utils_1.isFunction)(currAlt.GATE);\n  });\n  newOrProd.hasPredicates = hasPredicates;\n  prevProd.definition.push(newOrProd);\n  (0, utils_1.forEach)(alts, function (currAlt) {\n    var currAltFlat = new gast_public_1.Alternative({\n      definition: []\n    });\n    newOrProd.definition.push(currAltFlat);\n\n    if ((0, utils_1.has)(currAlt, \"IGNORE_AMBIGUITIES\")) {\n      currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;\n    } // **implicit** ignoreAmbiguities due to usage of gate\n    else if ((0, utils_1.has)(currAlt, \"GATE\")) {\n      currAltFlat.ignoreAmbiguities = true;\n    }\n\n    _this.recordingProdStack.push(currAltFlat);\n\n    currAlt.ALT.call(_this);\n\n    _this.recordingProdStack.pop();\n  });\n  return RECORDING_NULL_OBJECT;\n}\n\nfunction getIdxSuffix(idx) {\n  return idx === 0 ? \"\" : \"\" + idx;\n}\n\nfunction assertMethodIdxIsValid(idx) {\n  if (idx < 0 || idx > MAX_METHOD_IDX) {\n    var error = new Error( // The stack trace will contain all the needed details\n    \"Invalid DSL Method idx value: <\" + idx + \">\\n\\t\" + (\"Idx value must be a none negative value smaller than \" + (MAX_METHOD_IDX + 1)));\n    error.KNOWN_RECORDER_ERROR = true;\n    throw error;\n  }\n}","map":{"version":3,"mappings":"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","names":["RECORDING_NULL_OBJECT","description","Object","freeze","HANDLE_SEPARATOR","MAX_METHOD_IDX","Math","pow","keys_1","RFT","name","pattern","lexer_public_1","NA","RECORDING_PHASE_TOKEN","RECORDING_PHASE_CSTNODE","children","GastRecorder","config","recordingProdStack","RECORDING_PHASE","TRACE_INIT","i","idx","_this","arg1","arg2","consumeInternalRecord","subruleInternalRecord","optionInternalRecord","orInternalRecord","manyInternalRecord","manySepFirstInternalRecord","atLeastOneInternalRecord","atLeastOneSepFirstInternalRecord","ACTION","ACTION_RECORD","BACKTRACK","BACKTRACK_RECORD","LA","LA_RECORD","impl","grammarRule","args","howMuch","parser_1","def","newTopLevelRule","gast_public_1","definition","push","call","pop","originalError","KNOWN_RECORDER_ERROR","message","mutabilityError","actionORMethodDef","occurrence","recordProd","options","altsOrOpts","recordOrProd","ruleToCall","assertMethodIdxIsValid","error","Error","getIdxSuffix","JSON","stringify","prevProd","ruleName","newNoneTerminal","nonTerminalName","label","LABEL","referencedRule","undefined","outputCst","tokType","terminalType","exports","prodConstructor","mainProdArg","handleSep","grammarAction","DEF","newProd","separator","SEP","maxLookahead","MAX_LOOKAHEAD","hasOptions","alts","newOrProd","ignoreAmbiguities","IGNORE_AMBIGUITIES","hasPredicates","currAlt","GATE","currAltFlat","ALT"],"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/chevrotain/src/parse/parser/traits/gast_recorder.ts"],"sourcesContent":["import {\n  AtLeastOneSepMethodOpts,\n  ConsumeMethodOpts,\n  CstNode,\n  DSLMethodOpts,\n  DSLMethodOptsWithErr,\n  GrammarAction,\n  IOrAlt,\n  IParserConfig,\n  IProduction,\n  IToken,\n  ManySepMethodOpts,\n  OrMethodOpts,\n  SubruleMethodOpts,\n  TokenType\n} from \"@chevrotain/types\"\nimport {\n  forEach,\n  has,\n  isArray,\n  isFunction,\n  peek,\n  some\n} from \"@chevrotain/utils\"\nimport { MixedInParser } from \"./parser_traits\"\nimport {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal\n} from \"../../grammar/gast/gast_public\"\nimport { Lexer } from \"../../../scan/lexer_public\"\nimport { augmentTokenTypes, hasShortKeyProperty } from \"../../../scan/tokens\"\nimport { createToken, createTokenInstance } from \"../../../scan/tokens_public\"\nimport { END_OF_FILE } from \"../parser\"\nimport { BITS_FOR_OCCURRENCE_IDX } from \"../../grammar/keys\"\n\ntype ProdWithDef = IProduction & { definition?: IProduction[] }\nconst RECORDING_NULL_OBJECT = {\n  description: \"This Object indicates the Parser is during Recording Phase\"\n}\nObject.freeze(RECORDING_NULL_OBJECT)\n\nconst HANDLE_SEPARATOR = true\nconst MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1\n\nconst RFT = createToken({ name: \"RECORDING_PHASE_TOKEN\", pattern: Lexer.NA })\naugmentTokenTypes([RFT])\nconst RECORDING_PHASE_TOKEN = createTokenInstance(\n  RFT,\n  \"This IToken indicates the Parser is in Recording Phase\\n\\t\" +\n    \"\" +\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  // Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n  // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1\n)\nObject.freeze(RECORDING_PHASE_TOKEN)\n\nconst RECORDING_PHASE_CSTNODE: CstNode = {\n  name:\n    \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" +\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  children: {}\n}\n\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\nexport class GastRecorder {\n  recordingProdStack: ProdWithDef[]\n  RECORDING_PHASE: boolean\n\n  initGastRecorder(this: MixedInParser, config: IParserConfig): void {\n    this.recordingProdStack = []\n    this.RECORDING_PHASE = false\n  }\n\n  enableRecording(this: MixedInParser): void {\n    this.RECORDING_PHASE = true\n\n    this.TRACE_INIT(\"Enable Recording\", () => {\n      /**\n       * Warning Dark Voodoo Magic upcoming!\n       * We are \"replacing\" the public parsing DSL methods API\n       * With **new** alternative implementations on the Parser **instance**\n       *\n       * So far this is the only way I've found to avoid performance regressions during parsing time.\n       * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n       *   implementations directly instead.\n       */\n      for (let i = 0; i < 10; i++) {\n        const idx = i > 0 ? i : \"\"\n        this[`CONSUME${idx}`] = function (arg1, arg2) {\n          return this.consumeInternalRecord(arg1, i, arg2)\n        }\n        this[`SUBRULE${idx}`] = function (arg1, arg2) {\n          return this.subruleInternalRecord(arg1, i, arg2)\n        }\n        this[`OPTION${idx}`] = function (arg1) {\n          return this.optionInternalRecord(arg1, i)\n        }\n        this[`OR${idx}`] = function (arg1) {\n          return this.orInternalRecord(arg1, i)\n        }\n        this[`MANY${idx}`] = function (arg1) {\n          this.manyInternalRecord(i, arg1)\n        }\n        this[`MANY_SEP${idx}`] = function (arg1) {\n          this.manySepFirstInternalRecord(i, arg1)\n        }\n        this[`AT_LEAST_ONE${idx}`] = function (arg1) {\n          this.atLeastOneInternalRecord(i, arg1)\n        }\n        this[`AT_LEAST_ONE_SEP${idx}`] = function (arg1) {\n          this.atLeastOneSepFirstInternalRecord(i, arg1)\n        }\n      }\n\n      // DSL methods with the idx(suffix) as an argument\n      this[`consume`] = function (idx, arg1, arg2) {\n        return this.consumeInternalRecord(arg1, idx, arg2)\n      }\n      this[`subrule`] = <any>function (idx, arg1, arg2) {\n        return this.subruleInternalRecord(arg1, idx, arg2)\n      }\n      this[`option`] = function (idx, arg1) {\n        return this.optionInternalRecord(arg1, idx)\n      }\n      this[`or`] = function (idx, arg1) {\n        return this.orInternalRecord(arg1, idx)\n      }\n      this[`many`] = function (idx, arg1) {\n        this.manyInternalRecord(idx, arg1)\n      }\n      this[`atLeastOne`] = function (idx, arg1) {\n        this.atLeastOneInternalRecord(idx, arg1)\n      }\n\n      this.ACTION = this.ACTION_RECORD\n      this.BACKTRACK = this.BACKTRACK_RECORD\n      this.LA = this.LA_RECORD\n    })\n  }\n\n  disableRecording(this: MixedInParser) {\n    this.RECORDING_PHASE = false\n    // By deleting these **instance** properties, any future invocation\n    // will be deferred to the original methods on the **prototype** object\n    // This seems to get rid of any incorrect optimizations that V8 may\n    // do during the recording phase.\n    this.TRACE_INIT(\"Deleting Recording methods\", () => {\n      for (let i = 0; i < 10; i++) {\n        const idx = i > 0 ? i : \"\"\n        delete this[`CONSUME${idx}`]\n        delete this[`SUBRULE${idx}`]\n        delete this[`OPTION${idx}`]\n        delete this[`OR${idx}`]\n        delete this[`MANY${idx}`]\n        delete this[`MANY_SEP${idx}`]\n        delete this[`AT_LEAST_ONE${idx}`]\n        delete this[`AT_LEAST_ONE_SEP${idx}`]\n      }\n\n      delete this[`consume`]\n      delete this[`subrule`]\n      delete this[`option`]\n      delete this[`or`]\n      delete this[`many`]\n      delete this[`atLeastOne`]\n\n      delete this.ACTION\n      delete this.BACKTRACK\n      delete this.LA\n    })\n  }\n\n  // TODO: is there any way to use this method to check no\n  //   Parser methods are called inside an ACTION?\n  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n  ACTION_RECORD<T>(this: MixedInParser, impl: () => T): T {\n    // NO-OP during recording\n    return\n  }\n\n  // Executing backtracking logic will break our recording logic assumptions\n  BACKTRACK_RECORD<T>(\n    grammarRule: (...args: any[]) => T,\n    args?: any[]\n  ): () => boolean {\n    return () => true\n  }\n\n  // LA is part of the official API and may be used for custom lookahead logic\n  // by end users who may forget to wrap it in ACTION or inside a GATE\n  LA_RECORD(howMuch: number): IToken {\n    // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n    // On LA return EOF at the end of the input so an infinite loop may occur.\n    return END_OF_FILE\n  }\n\n  topLevelRuleRecord(name: string, def: Function): Rule {\n    try {\n      const newTopLevelRule = new Rule({ definition: [], name: name })\n      newTopLevelRule.name = name\n      this.recordingProdStack.push(newTopLevelRule)\n      def.call(this)\n      this.recordingProdStack.pop()\n      return newTopLevelRule\n    } catch (originalError) {\n      if (originalError.KNOWN_RECORDER_ERROR !== true) {\n        try {\n          originalError.message =\n            originalError.message +\n            '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' +\n            \"https://chevrotain.io/docs/guide/internals.html#grammar-recording\"\n        } catch (mutabilityError) {\n          // We may not be able to modify the original error object\n          throw originalError\n        }\n      }\n      throw originalError\n    }\n  }\n\n  // Implementation of parsing DSL\n  optionInternalRecord<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    occurrence: number\n  ): OUT {\n    return recordProd.call(this, Option, actionORMethodDef, occurrence)\n  }\n\n  atLeastOneInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence)\n  }\n\n  atLeastOneSepFirstInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    recordProd.call(\n      this,\n      RepetitionMandatoryWithSeparator,\n      options,\n      occurrence,\n      HANDLE_SEPARATOR\n    )\n  }\n\n  manyInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    recordProd.call(this, Repetition, actionORMethodDef, occurrence)\n  }\n\n  manySepFirstInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    options: ManySepMethodOpts<OUT>\n  ): void {\n    recordProd.call(\n      this,\n      RepetitionWithSeparator,\n      options,\n      occurrence,\n      HANDLE_SEPARATOR\n    )\n  }\n\n  orInternalRecord<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n    occurrence: number\n  ): T {\n    return recordOrProd.call(this, altsOrOpts, occurrence)\n  }\n\n  subruleInternalRecord<T>(\n    this: MixedInParser,\n    ruleToCall: (idx: number) => T,\n    occurrence: number,\n    options?: SubruleMethodOpts\n  ): T | CstNode {\n    assertMethodIdxIsValid(occurrence)\n    if (!ruleToCall || has(ruleToCall, \"ruleName\") === false) {\n      const error: any = new Error(\n        `<SUBRULE${getIdxSuffix(occurrence)}> argument is invalid` +\n          ` expecting a Parser method reference but got: <${JSON.stringify(\n            ruleToCall\n          )}>` +\n          `\\n inside top level rule: <${\n            (<Rule>this.recordingProdStack[0]).name\n          }>`\n      )\n      error.KNOWN_RECORDER_ERROR = true\n      throw error\n    }\n\n    const prevProd: any = peek(this.recordingProdStack)\n    const ruleName = ruleToCall[\"ruleName\"]\n    const newNoneTerminal = new NonTerminal({\n      idx: occurrence,\n      nonTerminalName: ruleName,\n      label: options?.LABEL,\n      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n      referencedRule: undefined\n    })\n    prevProd.definition.push(newNoneTerminal)\n\n    return this.outputCst ? RECORDING_PHASE_CSTNODE : <any>RECORDING_NULL_OBJECT\n  }\n\n  consumeInternalRecord(\n    this: MixedInParser,\n    tokType: TokenType,\n    occurrence: number,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    assertMethodIdxIsValid(occurrence)\n    if (!hasShortKeyProperty(tokType)) {\n      const error: any = new Error(\n        `<CONSUME${getIdxSuffix(occurrence)}> argument is invalid` +\n          ` expecting a TokenType reference but got: <${JSON.stringify(\n            tokType\n          )}>` +\n          `\\n inside top level rule: <${\n            (<Rule>this.recordingProdStack[0]).name\n          }>`\n      )\n      error.KNOWN_RECORDER_ERROR = true\n      throw error\n    }\n    const prevProd: any = peek(this.recordingProdStack)\n    const newNoneTerminal = new Terminal({\n      idx: occurrence,\n      terminalType: tokType,\n      label: options?.LABEL\n    })\n    prevProd.definition.push(newNoneTerminal)\n\n    return RECORDING_PHASE_TOKEN\n  }\n}\n\nfunction recordProd(\n  prodConstructor: any,\n  mainProdArg: any,\n  occurrence: number,\n  handleSep: boolean = false\n): any {\n  assertMethodIdxIsValid(occurrence)\n  const prevProd: any = peek(this.recordingProdStack)\n  const grammarAction = isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF\n\n  const newProd = new prodConstructor({ definition: [], idx: occurrence })\n  if (handleSep) {\n    newProd.separator = mainProdArg.SEP\n  }\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD\n  }\n\n  this.recordingProdStack.push(newProd)\n  grammarAction.call(this)\n  prevProd.definition.push(newProd)\n  this.recordingProdStack.pop()\n\n  return RECORDING_NULL_OBJECT\n}\n\nfunction recordOrProd(mainProdArg: any, occurrence: number): any {\n  assertMethodIdxIsValid(occurrence)\n  const prevProd: any = peek(this.recordingProdStack)\n  // Only an array of alternatives\n  const hasOptions = isArray(mainProdArg) === false\n  const alts = hasOptions === false ? mainProdArg : mainProdArg.DEF\n\n  const newOrProd = new Alternation({\n    definition: [],\n    idx: occurrence,\n    ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n  })\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD\n  }\n\n  const hasPredicates = some(alts, (currAlt: any) => isFunction(currAlt.GATE))\n  newOrProd.hasPredicates = hasPredicates\n\n  prevProd.definition.push(newOrProd)\n\n  forEach(alts, (currAlt) => {\n    const currAltFlat = new Alternative({ definition: [] })\n    newOrProd.definition.push(currAltFlat)\n    if (has(currAlt, \"IGNORE_AMBIGUITIES\")) {\n      currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES\n    }\n    // **implicit** ignoreAmbiguities due to usage of gate\n    else if (has(currAlt, \"GATE\")) {\n      currAltFlat.ignoreAmbiguities = true\n    }\n    this.recordingProdStack.push(currAltFlat)\n    currAlt.ALT.call(this)\n    this.recordingProdStack.pop()\n  })\n  return RECORDING_NULL_OBJECT\n}\n\nfunction getIdxSuffix(idx: number): string {\n  return idx === 0 ? \"\" : `${idx}`\n}\n\nfunction assertMethodIdxIsValid(idx): void {\n  if (idx < 0 || idx > MAX_METHOD_IDX) {\n    const error: any = new Error(\n      // The stack trace will contain all the needed details\n      `Invalid DSL Method idx value: <${idx}>\\n\\t` +\n        `Idx value must be a none negative value smaller than ${\n          MAX_METHOD_IDX + 1\n        }`\n    )\n    error.KNOWN_RECORDER_ERROR = true\n    throw error\n  }\n}\n"]},"metadata":{},"sourceType":"script"}