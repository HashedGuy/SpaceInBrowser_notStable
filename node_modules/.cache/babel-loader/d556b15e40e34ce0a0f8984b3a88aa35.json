{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ContentAssist = void 0;\n\nvar interpreter_1 = require(\"../../grammar/interpreter\");\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar ContentAssist =\n/** @class */\nfunction () {\n  function ContentAssist() {}\n\n  ContentAssist.prototype.initContentAssist = function () {};\n\n  ContentAssist.prototype.computeContentAssist = function (startRuleName, precedingInput) {\n    var startRuleGast = this.gastProductionsCache[startRuleName];\n\n    if ((0, utils_1.isUndefined)(startRuleGast)) {\n      throw Error(\"Rule ->\" + startRuleName + \"<- does not exist in this grammar.\");\n    }\n\n    return (0, interpreter_1.nextPossibleTokensAfter)([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);\n  }; // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\n  // TODO: should this be more explicitly part of the public API?\n\n\n  ContentAssist.prototype.getNextPossibleTokenTypes = function (grammarPath) {\n    var topRuleName = (0, utils_1.first)(grammarPath.ruleStack);\n    var gastProductions = this.getGAstProductions();\n    var topProduction = gastProductions[topRuleName];\n    var nextPossibleTokenTypes = new interpreter_1.NextAfterTokenWalker(topProduction, grammarPath).startWalking();\n    return nextPossibleTokenTypes;\n  };\n\n  return ContentAssist;\n}();\n\nexports.ContentAssist = ContentAssist;","map":{"version":3,"mappings":";;;;;;;AAMA;;AAIA;;AAGA;AAAA;AAAA;AAAA,4BAqCC;;AApCCA,2DAAsB,CAAtB;;AAEOA,iDAAP,UAEEC,aAFF,EAGEC,cAHF,EAG0B;AAExB,QAAMC,aAAa,GAAG,KAAKC,oBAAL,CAA0BH,aAA1B,CAAtB;;AAEA,QAAI,yBAAYE,aAAZ,CAAJ,EAAgC;AAC9B,YAAME,KAAK,CAAC,YAAUJ,aAAV,GAAuB,oCAAxB,CAAX;AACD;;AAED,WAAO,2CACL,CAACE,aAAD,CADK,EAELD,cAFK,EAGL,KAAKI,YAHA,EAIL,KAAKC,YAJA,CAAP;AAMD,GAjBM,CAHT,CAsBE;AACA;;;AACOP,sDAAP,UAEEQ,WAFF,EAEgC;AAE9B,QAAMC,WAAW,GAAG,mBAAMD,WAAW,CAACE,SAAlB,CAApB;AACA,QAAMC,eAAe,GAAG,KAAKC,kBAAL,EAAxB;AACA,QAAMC,aAAa,GAAGF,eAAe,CAACF,WAAD,CAArC;AACA,QAAMK,sBAAsB,GAAG,IAAIC,kCAAJ,CAC7BF,aAD6B,EAE7BL,WAF6B,EAG7BQ,YAH6B,EAA/B;AAIA,WAAOF,sBAAP;AACD,GAZM;;AAaT;AAAC,CArCD;;AAAaG","names":["ContentAssist","startRuleName","precedingInput","startRuleGast","gastProductionsCache","Error","tokenMatcher","maxLookahead","grammarPath","topRuleName","ruleStack","gastProductions","getGAstProductions","topProduction","nextPossibleTokenTypes","interpreter_1","startWalking","exports"],"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/chevrotain/src/parse/parser/traits/context_assist.ts"],"sourcesContent":["import {\n  ISyntacticContentAssistPath,\n  IToken,\n  ITokenGrammarPath,\n  TokenType\n} from \"@chevrotain/types\"\nimport {\n  NextAfterTokenWalker,\n  nextPossibleTokensAfter\n} from \"../../grammar/interpreter\"\nimport { first, isUndefined } from \"@chevrotain/utils\"\nimport { MixedInParser } from \"./parser_traits\"\n\nexport class ContentAssist {\n  initContentAssist() {}\n\n  public computeContentAssist(\n    this: MixedInParser,\n    startRuleName: string,\n    precedingInput: IToken[]\n  ): ISyntacticContentAssistPath[] {\n    const startRuleGast = this.gastProductionsCache[startRuleName]\n\n    if (isUndefined(startRuleGast)) {\n      throw Error(`Rule ->${startRuleName}<- does not exist in this grammar.`)\n    }\n\n    return nextPossibleTokensAfter(\n      [startRuleGast],\n      precedingInput,\n      this.tokenMatcher,\n      this.maxLookahead\n    )\n  }\n\n  // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\n  // TODO: should this be more explicitly part of the public API?\n  public getNextPossibleTokenTypes(\n    this: MixedInParser,\n    grammarPath: ITokenGrammarPath\n  ): TokenType[] {\n    const topRuleName = first(grammarPath.ruleStack)\n    const gastProductions = this.getGAstProductions()\n    const topProduction = gastProductions[topRuleName]\n    const nextPossibleTokenTypes = new NextAfterTokenWalker(\n      topProduction,\n      grammarPath\n    ).startWalking()\n    return nextPossibleTokenTypes\n  }\n}\n"]},"metadata":{},"sourceType":"script"}