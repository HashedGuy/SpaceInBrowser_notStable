{"ast":null,"code":"import _classCallCheck from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { DataTexture, FloatType, UnsignedIntType, RGBAFormat, RGIntegerFormat, NearestFilter } from 'three';\nimport { FloatVertexAttributeTexture, UIntVertexAttributeTexture } from './VertexAttributeTexture.js';\nimport { BYTES_PER_NODE } from '../core/Constants.js';\nimport { BOUNDING_DATA_INDEX, COUNT, IS_LEAF, RIGHT_NODE, OFFSET, SPLIT_AXIS } from '../core/nodeBufferFunctions.js';\n\nfunction bvhToTextures(bvh, boundsTexture, contentsTexture) {\n  var roots = bvh._roots;\n\n  if (roots.length !== 1) {\n    throw new Error('MeshBVHUniformStruct: Multi-root BVHs not supported.');\n  }\n\n  var root = roots[0];\n  var uint16Array = new Uint16Array(root);\n  var uint32Array = new Uint32Array(root);\n  var float32Array = new Float32Array(root); // Both bounds need two elements per node so compute the height so it's twice as long as\n  // the width so we can expand the row by two and still have a square texture\n\n  var nodeCount = root.byteLength / BYTES_PER_NODE;\n  var boundsDimension = 2 * Math.ceil(Math.sqrt(nodeCount / 2));\n  var boundsArray = new Float32Array(4 * boundsDimension * boundsDimension);\n  var contentsDimension = Math.ceil(Math.sqrt(nodeCount));\n  var contentsArray = new Uint32Array(2 * contentsDimension * contentsDimension);\n\n  for (var i = 0; i < nodeCount; i++) {\n    var nodeIndex32 = i * BYTES_PER_NODE / 4;\n    var nodeIndex16 = nodeIndex32 * 2;\n    var boundsIndex = BOUNDING_DATA_INDEX(nodeIndex32);\n\n    for (var b = 0; b < 3; b++) {\n      boundsArray[8 * i + 0 + b] = float32Array[boundsIndex + 0 + b];\n      boundsArray[8 * i + 4 + b] = float32Array[boundsIndex + 3 + b];\n    }\n\n    if (IS_LEAF(nodeIndex16, uint16Array)) {\n      var count = COUNT(nodeIndex16, uint16Array);\n      var offset = OFFSET(nodeIndex32, uint32Array);\n      var mergedLeafCount = 0xffff0000 | count;\n      contentsArray[i * 2 + 0] = mergedLeafCount;\n      contentsArray[i * 2 + 1] = offset;\n    } else {\n      var rightIndex = 4 * RIGHT_NODE(nodeIndex32, uint32Array) / BYTES_PER_NODE;\n      var splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);\n      contentsArray[i * 2 + 0] = splitAxis;\n      contentsArray[i * 2 + 1] = rightIndex;\n    }\n  }\n\n  boundsTexture.image.data = boundsArray;\n  boundsTexture.image.width = boundsDimension;\n  boundsTexture.image.height = boundsDimension;\n  boundsTexture.format = RGBAFormat;\n  boundsTexture.type = FloatType;\n  boundsTexture.internalFormat = 'RGBA32F';\n  boundsTexture.minFilter = NearestFilter;\n  boundsTexture.magFilter = NearestFilter;\n  boundsTexture.generateMipmaps = false;\n  boundsTexture.needsUpdate = true;\n  contentsTexture.image.data = contentsArray;\n  contentsTexture.image.width = contentsDimension;\n  contentsTexture.image.height = contentsDimension;\n  contentsTexture.format = RGIntegerFormat;\n  contentsTexture.type = UnsignedIntType;\n  contentsTexture.internalFormat = 'RG32UI';\n  contentsTexture.minFilter = NearestFilter;\n  contentsTexture.magFilter = NearestFilter;\n  contentsTexture.generateMipmaps = false;\n  contentsTexture.needsUpdate = true;\n}\n\nexport var MeshBVHUniformStruct = /*#__PURE__*/function () {\n  function MeshBVHUniformStruct() {\n    _classCallCheck(this, MeshBVHUniformStruct);\n\n    this.autoDispose = true;\n    this.index = new UIntVertexAttributeTexture();\n    this.position = new FloatVertexAttributeTexture();\n    this.bvhBounds = new DataTexture();\n    this.bvhContents = new DataTexture();\n    this.index.overrideItemSize = 3;\n  }\n\n  _createClass(MeshBVHUniformStruct, [{\n    key: \"updateFrom\",\n    value: function updateFrom(bvh) {\n      var geometry = bvh.geometry;\n      bvhToTextures(bvh, this.bvhBounds, this.bvhContents);\n      this.index.updateFrom(geometry.index);\n      this.position.updateFrom(geometry.attributes.position);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var index = this.index,\n          position = this.position,\n          bvhBounds = this.bvhBounds,\n          bvhContents = this.bvhContents;\n      if (index) index.dispose();\n      if (position) position.dispose();\n      if (bvhBounds) bvhBounds.dispose();\n      if (bvhContents) bvhContents.dispose();\n    }\n  }]);\n\n  return MeshBVHUniformStruct;\n}();","map":{"version":3,"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/three-mesh-bvh/src/gpu/MeshBVHUniformStruct.js"],"names":["DataTexture","FloatType","UnsignedIntType","RGBAFormat","RGIntegerFormat","NearestFilter","FloatVertexAttributeTexture","UIntVertexAttributeTexture","BYTES_PER_NODE","BOUNDING_DATA_INDEX","COUNT","IS_LEAF","RIGHT_NODE","OFFSET","SPLIT_AXIS","bvhToTextures","bvh","boundsTexture","contentsTexture","roots","_roots","length","Error","root","uint16Array","Uint16Array","uint32Array","Uint32Array","float32Array","Float32Array","nodeCount","byteLength","boundsDimension","Math","ceil","sqrt","boundsArray","contentsDimension","contentsArray","i","nodeIndex32","nodeIndex16","boundsIndex","b","count","offset","mergedLeafCount","rightIndex","splitAxis","image","data","width","height","format","type","internalFormat","minFilter","magFilter","generateMipmaps","needsUpdate","MeshBVHUniformStruct","autoDispose","index","position","bvhBounds","bvhContents","overrideItemSize","geometry","updateFrom","attributes","dispose"],"mappings":"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","sourcesContent":["import {\r\n\tDataTexture,\r\n\tFloatType,\r\n\tUnsignedIntType,\r\n\tRGBAFormat,\r\n\tRGIntegerFormat,\r\n\tNearestFilter,\r\n} from 'three';\r\nimport {\r\n\tFloatVertexAttributeTexture,\r\n\tUIntVertexAttributeTexture,\r\n} from './VertexAttributeTexture.js';\r\nimport { BYTES_PER_NODE } from '../core/Constants.js';\r\nimport {\r\n\tBOUNDING_DATA_INDEX,\r\n\tCOUNT,\r\n\tIS_LEAF,\r\n\tRIGHT_NODE,\r\n\tOFFSET,\r\n\tSPLIT_AXIS,\r\n} from '../core/nodeBufferFunctions.js';\r\n\r\nfunction bvhToTextures( bvh, boundsTexture, contentsTexture ) {\r\n\r\n\tconst roots = bvh._roots;\r\n\r\n\tif ( roots.length !== 1 ) {\r\n\r\n\t\tthrow new Error( 'MeshBVHUniformStruct: Multi-root BVHs not supported.' );\r\n\r\n\t}\r\n\r\n\tconst root = roots[ 0 ];\r\n\tconst uint16Array = new Uint16Array( root );\r\n\tconst uint32Array = new Uint32Array( root );\r\n\tconst float32Array = new Float32Array( root );\r\n\r\n\t// Both bounds need two elements per node so compute the height so it's twice as long as\r\n\t// the width so we can expand the row by two and still have a square texture\r\n\tconst nodeCount = root.byteLength / BYTES_PER_NODE;\r\n\tconst boundsDimension = 2 * Math.ceil( Math.sqrt( nodeCount / 2 ) );\r\n\tconst boundsArray = new Float32Array( 4 * boundsDimension * boundsDimension );\r\n\r\n\tconst contentsDimension = Math.ceil( Math.sqrt( nodeCount ) );\r\n\tconst contentsArray = new Uint32Array( 2 * contentsDimension * contentsDimension );\r\n\r\n\tfor ( let i = 0; i < nodeCount; i ++ ) {\r\n\r\n\t\tconst nodeIndex32 = i * BYTES_PER_NODE / 4;\r\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\r\n\t\tconst boundsIndex = BOUNDING_DATA_INDEX( nodeIndex32 );\r\n\t\tfor ( let b = 0; b < 3; b ++ ) {\r\n\r\n\t\t\tboundsArray[ 8 * i + 0 + b ] = float32Array[ boundsIndex + 0 + b ];\r\n\t\t\tboundsArray[ 8 * i + 4 + b ] = float32Array[ boundsIndex + 3 + b ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( IS_LEAF( nodeIndex16, uint16Array ) ) {\r\n\r\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\r\n\t\t\tconst mergedLeafCount = 0xffff0000 | count;\r\n\t\t\tcontentsArray[ i * 2 + 0 ] = mergedLeafCount;\r\n\t\t\tcontentsArray[ i * 2 + 1 ] = offset;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst rightIndex = 4 * RIGHT_NODE( nodeIndex32, uint32Array ) / BYTES_PER_NODE;\r\n\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\r\n\r\n\t\t\tcontentsArray[ i * 2 + 0 ] = splitAxis;\r\n\t\t\tcontentsArray[ i * 2 + 1 ] = rightIndex;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tboundsTexture.image.data = boundsArray;\r\n\tboundsTexture.image.width = boundsDimension;\r\n\tboundsTexture.image.height = boundsDimension;\r\n\tboundsTexture.format = RGBAFormat;\r\n\tboundsTexture.type = FloatType;\r\n\tboundsTexture.internalFormat = 'RGBA32F';\r\n\tboundsTexture.minFilter = NearestFilter;\r\n\tboundsTexture.magFilter = NearestFilter;\r\n\tboundsTexture.generateMipmaps = false;\r\n\tboundsTexture.needsUpdate = true;\r\n\r\n\tcontentsTexture.image.data = contentsArray;\r\n\tcontentsTexture.image.width = contentsDimension;\r\n\tcontentsTexture.image.height = contentsDimension;\r\n\tcontentsTexture.format = RGIntegerFormat;\r\n\tcontentsTexture.type = UnsignedIntType;\r\n\tcontentsTexture.internalFormat = 'RG32UI';\r\n\tcontentsTexture.minFilter = NearestFilter;\r\n\tcontentsTexture.magFilter = NearestFilter;\r\n\tcontentsTexture.generateMipmaps = false;\r\n\tcontentsTexture.needsUpdate = true;\r\n\r\n}\r\n\r\nexport class MeshBVHUniformStruct {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.autoDispose = true;\r\n\t\tthis.index = new UIntVertexAttributeTexture();\r\n\t\tthis.position = new FloatVertexAttributeTexture();\r\n\t\tthis.bvhBounds = new DataTexture();\r\n\t\tthis.bvhContents = new DataTexture();\r\n\r\n\t\tthis.index.overrideItemSize = 3;\r\n\r\n\t}\r\n\r\n\tupdateFrom( bvh ) {\r\n\r\n\t\tconst { geometry } = bvh;\r\n\r\n\t\tbvhToTextures( bvh, this.bvhBounds, this.bvhContents );\r\n\r\n\t\tthis.index.updateFrom( geometry.index );\r\n\t\tthis.position.updateFrom( geometry.attributes.position );\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tconst { index, position, bvhBounds, bvhContents } = this;\r\n\r\n\t\tif ( index ) index.dispose();\r\n\t\tif ( position ) position.dispose();\r\n\t\tif ( bvhBounds ) bvhBounds.dispose();\r\n\t\tif ( bvhContents ) bvhContents.dispose();\r\n\r\n\t}\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}