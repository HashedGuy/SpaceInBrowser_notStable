{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.serializeProduction = exports.serializeGrammar = exports.Terminal = exports.Alternation = exports.RepetitionWithSeparator = exports.Repetition = exports.RepetitionMandatoryWithSeparator = exports.RepetitionMandatory = exports.Option = exports.Alternative = exports.Rule = exports.NonTerminal = exports.AbstractProduction = void 0;\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar tokens_public_1 = require(\"../../../scan/tokens_public\");\n\nvar AbstractProduction =\n/** @class */\nfunction () {\n  function AbstractProduction(_definition) {\n    this._definition = _definition;\n  }\n\n  Object.defineProperty(AbstractProduction.prototype, \"definition\", {\n    get: function get() {\n      return this._definition;\n    },\n    set: function set(value) {\n      this._definition = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AbstractProduction.prototype.accept = function (visitor) {\n    visitor.visit(this);\n    (0, utils_1.forEach)(this.definition, function (prod) {\n      prod.accept(visitor);\n    });\n  };\n\n  return AbstractProduction;\n}();\n\nexports.AbstractProduction = AbstractProduction;\n\nvar NonTerminal =\n/** @class */\nfunction (_super) {\n  __extends(NonTerminal, _super);\n\n  function NonTerminal(options) {\n    var _this = _super.call(this, []) || this;\n\n    _this.idx = 1;\n    (0, utils_1.assign)(_this, (0, utils_1.pick)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n\n  Object.defineProperty(NonTerminal.prototype, \"definition\", {\n    get: function get() {\n      if (this.referencedRule !== undefined) {\n        return this.referencedRule.definition;\n      }\n\n      return [];\n    },\n    set: function set(definition) {// immutable\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  NonTerminal.prototype.accept = function (visitor) {\n    visitor.visit(this); // don't visit children of a reference, we will get cyclic infinite loops if we do so\n  };\n\n  return NonTerminal;\n}(AbstractProduction);\n\nexports.NonTerminal = NonTerminal;\n\nvar Rule =\n/** @class */\nfunction (_super) {\n  __extends(Rule, _super);\n\n  function Rule(options) {\n    var _this = _super.call(this, options.definition) || this;\n\n    _this.orgText = \"\";\n    (0, utils_1.assign)(_this, (0, utils_1.pick)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n\n  return Rule;\n}(AbstractProduction);\n\nexports.Rule = Rule;\n\nvar Alternative =\n/** @class */\nfunction (_super) {\n  __extends(Alternative, _super);\n\n  function Alternative(options) {\n    var _this = _super.call(this, options.definition) || this;\n\n    _this.ignoreAmbiguities = false;\n    (0, utils_1.assign)(_this, (0, utils_1.pick)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n\n  return Alternative;\n}(AbstractProduction);\n\nexports.Alternative = Alternative;\n\nvar Option =\n/** @class */\nfunction (_super) {\n  __extends(Option, _super);\n\n  function Option(options) {\n    var _this = _super.call(this, options.definition) || this;\n\n    _this.idx = 1;\n    (0, utils_1.assign)(_this, (0, utils_1.pick)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n\n  return Option;\n}(AbstractProduction);\n\nexports.Option = Option;\n\nvar RepetitionMandatory =\n/** @class */\nfunction (_super) {\n  __extends(RepetitionMandatory, _super);\n\n  function RepetitionMandatory(options) {\n    var _this = _super.call(this, options.definition) || this;\n\n    _this.idx = 1;\n    (0, utils_1.assign)(_this, (0, utils_1.pick)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n\n  return RepetitionMandatory;\n}(AbstractProduction);\n\nexports.RepetitionMandatory = RepetitionMandatory;\n\nvar RepetitionMandatoryWithSeparator =\n/** @class */\nfunction (_super) {\n  __extends(RepetitionMandatoryWithSeparator, _super);\n\n  function RepetitionMandatoryWithSeparator(options) {\n    var _this = _super.call(this, options.definition) || this;\n\n    _this.idx = 1;\n    (0, utils_1.assign)(_this, (0, utils_1.pick)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n\n  return RepetitionMandatoryWithSeparator;\n}(AbstractProduction);\n\nexports.RepetitionMandatoryWithSeparator = RepetitionMandatoryWithSeparator;\n\nvar Repetition =\n/** @class */\nfunction (_super) {\n  __extends(Repetition, _super);\n\n  function Repetition(options) {\n    var _this = _super.call(this, options.definition) || this;\n\n    _this.idx = 1;\n    (0, utils_1.assign)(_this, (0, utils_1.pick)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n\n  return Repetition;\n}(AbstractProduction);\n\nexports.Repetition = Repetition;\n\nvar RepetitionWithSeparator =\n/** @class */\nfunction (_super) {\n  __extends(RepetitionWithSeparator, _super);\n\n  function RepetitionWithSeparator(options) {\n    var _this = _super.call(this, options.definition) || this;\n\n    _this.idx = 1;\n    (0, utils_1.assign)(_this, (0, utils_1.pick)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n\n  return RepetitionWithSeparator;\n}(AbstractProduction);\n\nexports.RepetitionWithSeparator = RepetitionWithSeparator;\n\nvar Alternation =\n/** @class */\nfunction (_super) {\n  __extends(Alternation, _super);\n\n  function Alternation(options) {\n    var _this = _super.call(this, options.definition) || this;\n\n    _this.idx = 1;\n    _this.ignoreAmbiguities = false;\n    _this.hasPredicates = false;\n    (0, utils_1.assign)(_this, (0, utils_1.pick)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n\n  Object.defineProperty(Alternation.prototype, \"definition\", {\n    get: function get() {\n      return this._definition;\n    },\n    set: function set(value) {\n      this._definition = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return Alternation;\n}(AbstractProduction);\n\nexports.Alternation = Alternation;\n\nvar Terminal =\n/** @class */\nfunction () {\n  function Terminal(options) {\n    this.idx = 1;\n    (0, utils_1.assign)(this, (0, utils_1.pick)(options, function (v) {\n      return v !== undefined;\n    }));\n  }\n\n  Terminal.prototype.accept = function (visitor) {\n    visitor.visit(this);\n  };\n\n  return Terminal;\n}();\n\nexports.Terminal = Terminal;\n\nfunction serializeGrammar(topRules) {\n  return (0, utils_1.map)(topRules, serializeProduction);\n}\n\nexports.serializeGrammar = serializeGrammar;\n\nfunction serializeProduction(node) {\n  function convertDefinition(definition) {\n    return (0, utils_1.map)(definition, serializeProduction);\n  }\n  /* istanbul ignore else */\n\n\n  if (node instanceof NonTerminal) {\n    var serializedNonTerminal = {\n      type: \"NonTerminal\",\n      name: node.nonTerminalName,\n      idx: node.idx\n    };\n\n    if ((0, utils_1.isString)(node.label)) {\n      serializedNonTerminal.label = node.label;\n    }\n\n    return serializedNonTerminal;\n  } else if (node instanceof Alternative) {\n    return {\n      type: \"Alternative\",\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Option) {\n    return {\n      type: \"Option\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionMandatory) {\n    return {\n      type: \"RepetitionMandatory\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionMandatoryWithSeparator) {\n    return {\n      type: \"RepetitionMandatoryWithSeparator\",\n      idx: node.idx,\n      separator: serializeProduction(new Terminal({\n        terminalType: node.separator\n      })),\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionWithSeparator) {\n    return {\n      type: \"RepetitionWithSeparator\",\n      idx: node.idx,\n      separator: serializeProduction(new Terminal({\n        terminalType: node.separator\n      })),\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Repetition) {\n    return {\n      type: \"Repetition\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Alternation) {\n    return {\n      type: \"Alternation\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Terminal) {\n    var serializedTerminal = {\n      type: \"Terminal\",\n      name: node.terminalType.name,\n      label: (0, tokens_public_1.tokenLabel)(node.terminalType),\n      idx: node.idx\n    };\n\n    if ((0, utils_1.isString)(node.label)) {\n      serializedTerminal.terminalLabel = node.label;\n    }\n\n    var pattern = node.terminalType.PATTERN;\n\n    if (node.terminalType.PATTERN) {\n      serializedTerminal.pattern = (0, utils_1.isRegExp)(pattern) ? pattern.source : pattern;\n    }\n\n    return serializedTerminal;\n  } else if (node instanceof Rule) {\n    return {\n      type: \"Rule\",\n      name: node.name,\n      orgText: node.orgText,\n      definition: convertDefinition(node.definition)\n    };\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nexports.serializeProduction = serializeProduction;","map":{"version":3,"mappings":"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","names":["_definition","Object","AbstractProduction","value","visitor","visit","definition","prod","accept","exports","__extends","options","_super","_this","v","undefined","NonTerminal","referencedRule","Alternation","Terminal","serializeGrammar","topRules","serializeProduction","node","convertDefinition","serializedNonTerminal","type","name","nonTerminalName","idx","label","Alternative","Option","RepetitionMandatory","RepetitionMandatoryWithSeparator","separator","terminalType","RepetitionWithSeparator","Repetition","serializedTerminal","terminalLabel","pattern","PATTERN","source","Rule","orgText","Error"],"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/chevrotain/src/parse/grammar/gast/gast_public.ts"],"sourcesContent":["import {\n  assign,\n  forEach,\n  isRegExp,\n  isString,\n  map,\n  pick\n} from \"@chevrotain/utils\"\nimport { tokenLabel } from \"../../../scan/tokens_public\"\nimport {\n  IGASTVisitor,\n  IProduction,\n  IProductionWithOccurrence,\n  ISerializedGast,\n  TokenType\n} from \"@chevrotain/types\"\n\nexport abstract class AbstractProduction<T extends IProduction = IProduction>\n  implements IProduction\n{\n  public get definition(): T[] {\n    return this._definition\n  }\n  public set definition(value: T[]) {\n    this._definition = value\n  }\n\n  constructor(protected _definition: T[]) {}\n\n  accept(visitor: IGASTVisitor): void {\n    visitor.visit(this)\n    forEach(this.definition, (prod) => {\n      prod.accept(visitor)\n    })\n  }\n}\n\nexport class NonTerminal\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public nonTerminalName: string\n  public label?: string\n  public referencedRule: Rule\n  public idx: number = 1\n\n  constructor(options: {\n    nonTerminalName: string\n    label?: string\n    referencedRule?: Rule\n    idx?: number\n  }) {\n    super([])\n    assign(\n      this,\n      pick(options, (v) => v !== undefined)\n    )\n  }\n\n  set definition(definition: IProduction[]) {\n    // immutable\n  }\n\n  get definition(): IProduction[] {\n    if (this.referencedRule !== undefined) {\n      return this.referencedRule.definition\n    }\n    return []\n  }\n\n  accept(visitor: IGASTVisitor): void {\n    visitor.visit(this)\n    // don't visit children of a reference, we will get cyclic infinite loops if we do so\n  }\n}\n\nexport class Rule extends AbstractProduction {\n  public name: string\n  public orgText: string = \"\"\n\n  constructor(options: {\n    name: string\n    definition: IProduction[]\n    orgText?: string\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pick(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Alternative extends AbstractProduction {\n  public ignoreAmbiguities: boolean = false\n\n  constructor(options: {\n    definition: IProduction[]\n    ignoreAmbiguities?: boolean\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pick(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Option\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public idx: number = 1\n  public maxLookahead?: number\n\n  constructor(options: {\n    definition: IProduction[]\n    idx?: number\n    maxLookahead?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pick(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class RepetitionMandatory\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public idx: number = 1\n  public maxLookahead?: number\n\n  constructor(options: {\n    definition: IProduction[]\n    idx?: number\n    maxLookahead?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pick(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class RepetitionMandatoryWithSeparator\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public separator: TokenType\n  public idx: number = 1\n\n  constructor(options: {\n    definition: IProduction[]\n    separator: TokenType\n    idx?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pick(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Repetition\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public separator: TokenType\n  public idx: number = 1\n  public maxLookahead?: number\n\n  constructor(options: {\n    definition: IProduction[]\n    idx?: number\n    maxLookahead?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pick(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class RepetitionWithSeparator\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public separator: TokenType\n  public idx: number = 1\n\n  constructor(options: {\n    definition: IProduction[]\n    separator: TokenType\n    idx?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pick(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Alternation\n  extends AbstractProduction<Alternative>\n  implements IProductionWithOccurrence\n{\n  public idx: number = 1\n  public ignoreAmbiguities: boolean = false\n  public hasPredicates: boolean = false\n  public maxLookahead?: number\n\n  public get definition(): Alternative[] {\n    return this._definition\n  }\n  public set definition(value: Alternative[]) {\n    this._definition = value\n  }\n\n  constructor(options: {\n    definition: Alternative[]\n    idx?: number\n    ignoreAmbiguities?: boolean\n    hasPredicates?: boolean\n    maxLookahead?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pick(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Terminal implements IProductionWithOccurrence {\n  public terminalType: TokenType\n  public label?: string\n  public idx: number = 1\n\n  constructor(options: {\n    terminalType: TokenType\n    label?: string\n    idx?: number\n  }) {\n    assign(\n      this,\n      pick(options, (v) => v !== undefined)\n    )\n  }\n\n  accept(visitor: IGASTVisitor): void {\n    visitor.visit(this)\n  }\n}\n\nexport interface ISerializedBasic extends ISerializedGast {\n  type:\n    | \"Alternative\"\n    | \"Option\"\n    | \"RepetitionMandatory\"\n    | \"Repetition\"\n    | \"Alternation\"\n  idx?: number\n}\n\nexport interface ISerializedGastRule extends ISerializedGast {\n  type: \"Rule\"\n  name: string\n  orgText: string\n}\n\nexport interface ISerializedNonTerminal extends ISerializedGast {\n  type: \"NonTerminal\"\n  name: string\n  label?: string\n  idx: number\n}\n\nexport interface ISerializedTerminal extends ISerializedGast {\n  type: \"Terminal\"\n  name: string\n  terminalLabel?: string\n  label?: string\n  pattern?: string\n  idx: number\n}\n\nexport interface ISerializedTerminalWithSeparator extends ISerializedGast {\n  type: \"RepetitionMandatoryWithSeparator\" | \"RepetitionWithSeparator\"\n  idx: number\n  separator: ISerializedTerminal\n}\n\nexport type ISerializedGastAny =\n  | ISerializedBasic\n  | ISerializedGastRule\n  | ISerializedNonTerminal\n  | ISerializedTerminal\n  | ISerializedTerminalWithSeparator\n\nexport function serializeGrammar(topRules: Rule[]): ISerializedGast[] {\n  return map(topRules, serializeProduction)\n}\n\nexport function serializeProduction(node: IProduction): ISerializedGast {\n  function convertDefinition(definition: IProduction[]): ISerializedGast[] {\n    return map(definition, serializeProduction)\n  }\n  /* istanbul ignore else */\n  if (node instanceof NonTerminal) {\n    const serializedNonTerminal: ISerializedNonTerminal = {\n      type: \"NonTerminal\",\n      name: node.nonTerminalName,\n      idx: node.idx\n    }\n\n    if (isString(node.label)) {\n      serializedNonTerminal.label = node.label\n    }\n\n    return serializedNonTerminal\n  } else if (node instanceof Alternative) {\n    return <ISerializedBasic>{\n      type: \"Alternative\",\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof Option) {\n    return <ISerializedBasic>{\n      type: \"Option\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof RepetitionMandatory) {\n    return <ISerializedBasic>{\n      type: \"RepetitionMandatory\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof RepetitionMandatoryWithSeparator) {\n    return <ISerializedTerminalWithSeparator>{\n      type: \"RepetitionMandatoryWithSeparator\",\n      idx: node.idx,\n      separator: <ISerializedTerminal>(\n        serializeProduction(new Terminal({ terminalType: node.separator }))\n      ),\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof RepetitionWithSeparator) {\n    return <ISerializedTerminalWithSeparator>{\n      type: \"RepetitionWithSeparator\",\n      idx: node.idx,\n      separator: <ISerializedTerminal>(\n        serializeProduction(new Terminal({ terminalType: node.separator }))\n      ),\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof Repetition) {\n    return <ISerializedBasic>{\n      type: \"Repetition\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof Alternation) {\n    return <ISerializedBasic>{\n      type: \"Alternation\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof Terminal) {\n    const serializedTerminal = <ISerializedTerminal>{\n      type: \"Terminal\",\n      name: node.terminalType.name,\n      label: tokenLabel(node.terminalType),\n      idx: node.idx\n    }\n\n    if (isString(node.label)) {\n      serializedTerminal.terminalLabel = node.label\n    }\n\n    const pattern = node.terminalType.PATTERN\n    if (node.terminalType.PATTERN) {\n      serializedTerminal.pattern = isRegExp(pattern)\n        ? (<any>pattern).source\n        : pattern\n    }\n\n    return serializedTerminal\n  } else if (node instanceof Rule) {\n    return <ISerializedGastRule>{\n      type: \"Rule\",\n      name: node.name,\n      orgText: node.orgText,\n      definition: convertDefinition(node.definition)\n    }\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n"]},"metadata":{},"sourceType":"script"}