{"ast":null,"code":"import _createClass from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _assertThisInitialized from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/arbus/Documents/SpaceInBrowser/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Mesh, Color, PerspectiveCamera, Plane, Matrix4, WebGLRenderTarget, ShaderMaterial, UniformsUtils, Vector3, Quaternion, Vector4 } from 'three';\n\nvar Refractor = /*#__PURE__*/function (_Mesh) {\n  _inherits(Refractor, _Mesh);\n\n  var _super = _createSuper(Refractor);\n\n  function Refractor(geometry) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Refractor);\n\n    _this = _super.call(this, geometry);\n    _this.type = 'Refractor';\n\n    var scope = _assertThisInitialized(_this);\n\n    var color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n    var textureWidth = options.textureWidth || 512;\n    var textureHeight = options.textureHeight || 512;\n    var clipBias = options.clipBias || 0;\n    var shader = options.shader || Refractor.RefractorShader; //\n\n    var virtualCamera = new PerspectiveCamera();\n    virtualCamera.matrixAutoUpdate = false;\n    virtualCamera.userData.refractor = true; //\n\n    var refractorPlane = new Plane();\n    var textureMatrix = new Matrix4(); // render target\n\n    var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight); // material\n\n    _this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true // ensures, refractors are drawn from farthest to closest\n\n    });\n    _this.material.uniforms['color'].value = color;\n    _this.material.uniforms['tDiffuse'].value = renderTarget.texture;\n    _this.material.uniforms['textureMatrix'].value = textureMatrix; // functions\n\n    var visible = function () {\n      var refractorWorldPosition = new Vector3();\n      var cameraWorldPosition = new Vector3();\n      var rotationMatrix = new Matrix4();\n      var view = new Vector3();\n      var normal = new Vector3();\n      return function visible(camera) {\n        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n        view.subVectors(refractorWorldPosition, cameraWorldPosition);\n        rotationMatrix.extractRotation(scope.matrixWorld);\n        normal.set(0, 0, 1);\n        normal.applyMatrix4(rotationMatrix);\n        return view.dot(normal) < 0;\n      };\n    }();\n\n    var updateRefractorPlane = function () {\n      var normal = new Vector3();\n      var position = new Vector3();\n      var quaternion = new Quaternion();\n      var scale = new Vector3();\n      return function updateRefractorPlane() {\n        scope.matrixWorld.decompose(position, quaternion, scale);\n        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize(); // flip the normal because we want to cull everything above the plane\n\n        normal.negate();\n        refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n      };\n    }();\n\n    var updateVirtualCamera = function () {\n      var clipPlane = new Plane();\n      var clipVector = new Vector4();\n      var q = new Vector4();\n      return function updateVirtualCamera(camera) {\n        virtualCamera.matrixWorld.copy(camera.matrixWorld);\n        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n        virtualCamera.far = camera.far; // used in WebGLBackground\n        // The following code creates an oblique view frustum for clipping.\n        // see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\n        // Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\n\n        clipPlane.copy(refractorPlane);\n        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant); // calculate the clip-space corner point opposite the clipping plane and\n        // transform it into camera space by multiplying it by the inverse of the projection matrix\n\n        var projectionMatrix = virtualCamera.projectionMatrix;\n        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n        q.z = -1.0;\n        q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // calculate the scaled plane vector\n\n        clipVector.multiplyScalar(2.0 / clipVector.dot(q)); // replacing the third row of the projection matrix\n\n        projectionMatrix.elements[2] = clipVector.x;\n        projectionMatrix.elements[6] = clipVector.y;\n        projectionMatrix.elements[10] = clipVector.z + 1.0 - clipBias;\n        projectionMatrix.elements[14] = clipVector.w;\n      };\n    }(); // This will update the texture matrix that is used for projective texture mapping in the shader.\n    // see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\n\n\n    function updateTextureMatrix(camera) {\n      // this matrix does range mapping to [ 0, 1 ]\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0); // we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\n      // (matrix above) with the projection and view matrix of the virtual camera\n      // and the model matrix of the refractor\n\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    } //\n\n\n    function render(renderer, scene, camera) {\n      scope.visible = false;\n      var currentRenderTarget = renderer.getRenderTarget();\n      var currentXrEnabled = renderer.xr.enabled;\n      var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      renderer.xr.enabled = false; // avoid camera modification\n\n      renderer.shadowMap.autoUpdate = false; // avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget);\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget); // restore viewport\n\n      var viewport = camera.viewport;\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n\n      scope.visible = true;\n    } //\n\n\n    _this.onBeforeRender = function (renderer, scene, camera) {\n      // Render\n      renderTarget.texture.encoding = renderer.outputEncoding; // ensure refractors are rendered only once per frame\n\n      if (camera.userData.refractor === true) return; // avoid rendering when the refractor is viewed from behind\n\n      if (!visible(camera) === true) return; // update\n\n      updateRefractorPlane();\n      updateTextureMatrix(camera);\n      updateVirtualCamera(camera);\n      render(renderer, scene, camera);\n    };\n\n    _this.getRenderTarget = function () {\n      return renderTarget;\n    };\n\n    _this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n\n    return _this;\n  }\n\n  return _createClass(Refractor);\n}(Mesh);\n\nRefractor.prototype.isRefractor = true;\nRefractor.RefractorShader = {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader:\n  /* glsl */\n  \"\\n\\n\\t\\tuniform mat4 textureMatrix;\\n\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv = textureMatrix * vec4( position, 1.0 );\\n\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n\\t\\t}\",\n  fragmentShader:\n  /* glsl */\n  \"\\n\\n\\t\\tuniform vec3 color;\\n\\t\\tuniform sampler2D tDiffuse;\\n\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\tfloat blendOverlay( float base, float blend ) {\\n\\n\\t\\t\\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\\n\\n\\t\\t}\\n\\n\\t\\tvec3 blendOverlay( vec3 base, vec3 blend ) {\\n\\n\\t\\t\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\\n\\n\\t\\t}\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvec4 base = texture2DProj( tDiffuse, vUv );\\n\\t\\t\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\\n\\n\\t\\t}\"\n};\nexport { Refractor };","map":{"version":3,"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/three-stdlib/objects/Refractor.js"],"names":["Mesh","Color","PerspectiveCamera","Plane","Matrix4","WebGLRenderTarget","ShaderMaterial","UniformsUtils","Vector3","Quaternion","Vector4","Refractor","geometry","options","type","scope","color","undefined","textureWidth","textureHeight","clipBias","shader","RefractorShader","virtualCamera","matrixAutoUpdate","userData","refractor","refractorPlane","textureMatrix","renderTarget","material","uniforms","clone","vertexShader","fragmentShader","transparent","value","texture","visible","refractorWorldPosition","cameraWorldPosition","rotationMatrix","view","normal","camera","setFromMatrixPosition","matrixWorld","subVectors","extractRotation","set","applyMatrix4","dot","updateRefractorPlane","position","quaternion","scale","decompose","applyQuaternion","normalize","negate","setFromNormalAndCoplanarPoint","updateVirtualCamera","clipPlane","clipVector","q","copy","matrixWorldInverse","invert","projectionMatrix","far","x","y","z","constant","Math","sign","elements","w","multiplyScalar","updateTextureMatrix","multiply","render","renderer","scene","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","autoClear","clear","viewport","state","onBeforeRender","encoding","outputEncoding","dispose","prototype","isRefractor","tDiffuse"],"mappings":"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","sourcesContent":["import { Mesh, Color, PerspectiveCamera, Plane, Matrix4, WebGLRenderTarget, ShaderMaterial, UniformsUtils, Vector3, Quaternion, Vector4 } from 'three';\n\nclass Refractor extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.type = 'Refractor';\n    const scope = this;\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || Refractor.RefractorShader; //\n\n    const virtualCamera = new PerspectiveCamera();\n    virtualCamera.matrixAutoUpdate = false;\n    virtualCamera.userData.refractor = true; //\n\n    const refractorPlane = new Plane();\n    const textureMatrix = new Matrix4(); // render target\n\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight); // material\n\n    this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true // ensures, refractors are drawn from farthest to closest\n\n    });\n    this.material.uniforms['color'].value = color;\n    this.material.uniforms['tDiffuse'].value = renderTarget.texture;\n    this.material.uniforms['textureMatrix'].value = textureMatrix; // functions\n\n    const visible = function () {\n      const refractorWorldPosition = new Vector3();\n      const cameraWorldPosition = new Vector3();\n      const rotationMatrix = new Matrix4();\n      const view = new Vector3();\n      const normal = new Vector3();\n      return function visible(camera) {\n        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n        view.subVectors(refractorWorldPosition, cameraWorldPosition);\n        rotationMatrix.extractRotation(scope.matrixWorld);\n        normal.set(0, 0, 1);\n        normal.applyMatrix4(rotationMatrix);\n        return view.dot(normal) < 0;\n      };\n    }();\n\n    const updateRefractorPlane = function () {\n      const normal = new Vector3();\n      const position = new Vector3();\n      const quaternion = new Quaternion();\n      const scale = new Vector3();\n      return function updateRefractorPlane() {\n        scope.matrixWorld.decompose(position, quaternion, scale);\n        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize(); // flip the normal because we want to cull everything above the plane\n\n        normal.negate();\n        refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n      };\n    }();\n\n    const updateVirtualCamera = function () {\n      const clipPlane = new Plane();\n      const clipVector = new Vector4();\n      const q = new Vector4();\n      return function updateVirtualCamera(camera) {\n        virtualCamera.matrixWorld.copy(camera.matrixWorld);\n        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n        virtualCamera.far = camera.far; // used in WebGLBackground\n        // The following code creates an oblique view frustum for clipping.\n        // see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\n        // Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\n\n        clipPlane.copy(refractorPlane);\n        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant); // calculate the clip-space corner point opposite the clipping plane and\n        // transform it into camera space by multiplying it by the inverse of the projection matrix\n\n        const projectionMatrix = virtualCamera.projectionMatrix;\n        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n        q.z = -1.0;\n        q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // calculate the scaled plane vector\n\n        clipVector.multiplyScalar(2.0 / clipVector.dot(q)); // replacing the third row of the projection matrix\n\n        projectionMatrix.elements[2] = clipVector.x;\n        projectionMatrix.elements[6] = clipVector.y;\n        projectionMatrix.elements[10] = clipVector.z + 1.0 - clipBias;\n        projectionMatrix.elements[14] = clipVector.w;\n      };\n    }(); // This will update the texture matrix that is used for projective texture mapping in the shader.\n    // see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\n\n\n    function updateTextureMatrix(camera) {\n      // this matrix does range mapping to [ 0, 1 ]\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0); // we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\n      // (matrix above) with the projection and view matrix of the virtual camera\n      // and the model matrix of the refractor\n\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    } //\n\n\n    function render(renderer, scene, camera) {\n      scope.visible = false;\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      renderer.xr.enabled = false; // avoid camera modification\n\n      renderer.shadowMap.autoUpdate = false; // avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget);\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget); // restore viewport\n\n      const viewport = camera.viewport;\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n\n      scope.visible = true;\n    } //\n\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      // Render\n      renderTarget.texture.encoding = renderer.outputEncoding; // ensure refractors are rendered only once per frame\n\n      if (camera.userData.refractor === true) return; // avoid rendering when the refractor is viewed from behind\n\n      if (!visible(camera) === true) return; // update\n\n      updateRefractorPlane();\n      updateTextureMatrix(camera);\n      updateVirtualCamera(camera);\n      render(renderer, scene, camera);\n    };\n\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n\n    this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n\n}\n\nRefractor.prototype.isRefractor = true;\nRefractor.RefractorShader = {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n  fragmentShader:\n  /* glsl */\n  `\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t}`\n};\n\nexport { Refractor };\n"]},"metadata":{},"sourceType":"module"}