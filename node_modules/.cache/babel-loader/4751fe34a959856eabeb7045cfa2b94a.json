{"ast":null,"code":"import { Ray, Matrix4, Mesh } from 'three';\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\nvar ray = /* @__PURE__ */new Ray();\nvar tmpInverseMatrix = /* @__PURE__ */new Matrix4();\nvar origMeshRaycastFunc = Mesh.prototype.raycast;\nexport function acceleratedRaycast(raycaster, intersects) {\n  if (this.geometry.boundsTree) {\n    if (this.material === undefined) return;\n    tmpInverseMatrix.copy(this.matrixWorld).invert();\n    ray.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);\n    var bvh = this.geometry.boundsTree;\n\n    if (raycaster.firstHitOnly === true) {\n      var hit = convertRaycastIntersect(bvh.raycastFirst(ray, this.material), this, raycaster);\n\n      if (hit) {\n        intersects.push(hit);\n      }\n    } else {\n      var hits = bvh.raycast(ray, this.material);\n\n      for (var i = 0, l = hits.length; i < l; i++) {\n        var _hit = convertRaycastIntersect(hits[i], this, raycaster);\n\n        if (_hit) {\n          intersects.push(_hit);\n        }\n      }\n    }\n  } else {\n    origMeshRaycastFunc.call(this, raycaster, intersects);\n  }\n}\nexport function computeBoundsTree(options) {\n  this.boundsTree = new MeshBVH(this, options);\n  return this.boundsTree;\n}\nexport function disposeBoundsTree() {\n  this.boundsTree = null;\n}","map":{"version":3,"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js"],"names":["Ray","Matrix4","Mesh","convertRaycastIntersect","MeshBVH","ray","tmpInverseMatrix","origMeshRaycastFunc","prototype","raycast","acceleratedRaycast","raycaster","intersects","geometry","boundsTree","material","undefined","copy","matrixWorld","invert","applyMatrix4","bvh","firstHitOnly","hit","raycastFirst","push","hits","i","l","length","call","computeBoundsTree","options","disposeBoundsTree"],"mappings":"AAAA,SAASA,GAAT,EAAcC,OAAd,EAAuBC,IAAvB,QAAmC,OAAnC;AACA,SAASC,uBAAT,QAAwC,oCAAxC;AACA,SAASC,OAAT,QAAwB,oBAAxB;AAEA,IAAMC,GAAG,GAAG,eAAgB,IAAIL,GAAJ,EAA5B;AACA,IAAMM,gBAAgB,GAAG,eAAgB,IAAIL,OAAJ,EAAzC;AACA,IAAMM,mBAAmB,GAAGL,IAAI,CAACM,SAAL,CAAeC,OAA3C;AAEA,OAAO,SAASC,kBAAT,CAA6BC,SAA7B,EAAwCC,UAAxC,EAAqD;AAE3D,MAAK,KAAKC,QAAL,CAAcC,UAAnB,EAAgC;AAE/B,QAAK,KAAKC,QAAL,KAAkBC,SAAvB,EAAmC;AAEnCV,IAAAA,gBAAgB,CAACW,IAAjB,CAAuB,KAAKC,WAA5B,EAA0CC,MAA1C;AACAd,IAAAA,GAAG,CAACY,IAAJ,CAAUN,SAAS,CAACN,GAApB,EAA0Be,YAA1B,CAAwCd,gBAAxC;AAEA,QAAMe,GAAG,GAAG,KAAKR,QAAL,CAAcC,UAA1B;;AACA,QAAKH,SAAS,CAACW,YAAV,KAA2B,IAAhC,EAAuC;AAEtC,UAAMC,GAAG,GAAGpB,uBAAuB,CAAEkB,GAAG,CAACG,YAAJ,CAAkBnB,GAAlB,EAAuB,KAAKU,QAA5B,CAAF,EAA0C,IAA1C,EAAgDJ,SAAhD,CAAnC;;AACA,UAAKY,GAAL,EAAW;AAEVX,QAAAA,UAAU,CAACa,IAAX,CAAiBF,GAAjB;AAEA;AAED,KATD,MASO;AAEN,UAAMG,IAAI,GAAGL,GAAG,CAACZ,OAAJ,CAAaJ,GAAb,EAAkB,KAAKU,QAAvB,CAAb;;AACA,WAAM,IAAIY,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGF,IAAI,CAACG,MAA1B,EAAkCF,CAAC,GAAGC,CAAtC,EAAyCD,CAAC,EAA1C,EAAgD;AAE/C,YAAMJ,IAAG,GAAGpB,uBAAuB,CAAEuB,IAAI,CAAEC,CAAF,CAAN,EAAa,IAAb,EAAmBhB,SAAnB,CAAnC;;AACA,YAAKY,IAAL,EAAW;AAEVX,UAAAA,UAAU,CAACa,IAAX,CAAiBF,IAAjB;AAEA;AAED;AAED;AAED,GAjCD,MAiCO;AAENhB,IAAAA,mBAAmB,CAACuB,IAApB,CAA0B,IAA1B,EAAgCnB,SAAhC,EAA2CC,UAA3C;AAEA;AAED;AAED,OAAO,SAASmB,iBAAT,CAA4BC,OAA5B,EAAsC;AAE5C,OAAKlB,UAAL,GAAkB,IAAIV,OAAJ,CAAa,IAAb,EAAmB4B,OAAnB,CAAlB;AACA,SAAO,KAAKlB,UAAZ;AAEA;AAED,OAAO,SAASmB,iBAAT,GAA6B;AAEnC,OAAKnB,UAAL,GAAkB,IAAlB;AAEA","sourcesContent":["import { Ray, Matrix4, Mesh } from 'three';\r\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\r\nimport { MeshBVH } from '../core/MeshBVH.js';\r\n\r\nconst ray = /* @__PURE__ */ new Ray();\r\nconst tmpInverseMatrix = /* @__PURE__ */ new Matrix4();\r\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\r\n\r\nexport function acceleratedRaycast( raycaster, intersects ) {\r\n\r\n\tif ( this.geometry.boundsTree ) {\r\n\r\n\t\tif ( this.material === undefined ) return;\r\n\r\n\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\r\n\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\r\n\r\n\t\tconst bvh = this.geometry.boundsTree;\r\n\t\tif ( raycaster.firstHitOnly === true ) {\r\n\r\n\t\t\tconst hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material ), this, raycaster );\r\n\t\t\tif ( hit ) {\r\n\r\n\t\t\t\tintersects.push( hit );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst hits = bvh.raycast( ray, this.material );\r\n\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], this, raycaster );\r\n\t\t\t\tif ( hit ) {\r\n\r\n\t\t\t\t\tintersects.push( hit );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function computeBoundsTree( options ) {\r\n\r\n\tthis.boundsTree = new MeshBVH( this, options );\r\n\treturn this.boundsTree;\r\n\r\n}\r\n\r\nexport function disposeBoundsTree() {\r\n\r\n\tthis.boundsTree = null;\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}