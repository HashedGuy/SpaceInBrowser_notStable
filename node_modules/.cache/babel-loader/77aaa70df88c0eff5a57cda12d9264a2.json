{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkPrefixAlternativesAmbiguities = exports.validateSomeNonEmptyLookaheadPath = exports.validateTooManyAlts = exports.RepetionCollector = exports.validateAmbiguousAlternationAlternatives = exports.validateEmptyOrAlternative = exports.getFirstNoneTerminal = exports.validateNoLeftRecursion = exports.validateRuleIsOverridden = exports.validateRuleDoesNotAlreadyExist = exports.OccurrenceValidationCollector = exports.identifyProductionForDuplicates = exports.validateGrammar = void 0;\n\nvar utils = require(\"@chevrotain/utils\");\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar parser_1 = require(\"../parser/parser\");\n\nvar gast_1 = require(\"./gast/gast\");\n\nvar lookahead_1 = require(\"./lookahead\");\n\nvar interpreter_1 = require(\"./interpreter\");\n\nvar gast_public_1 = require(\"./gast/gast_public\");\n\nvar gast_visitor_public_1 = require(\"./gast/gast_visitor_public\");\n\nfunction validateGrammar(topLevels, globalMaxLookahead, tokenTypes, errMsgProvider, grammarName) {\n  var duplicateErrors = utils.map(topLevels, function (currTopLevel) {\n    return validateDuplicateProductions(currTopLevel, errMsgProvider);\n  });\n  var leftRecursionErrors = utils.map(topLevels, function (currTopRule) {\n    return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);\n  });\n  var emptyAltErrors = [];\n  var ambiguousAltsErrors = [];\n  var emptyRepetitionErrors = []; // left recursion could cause infinite loops in the following validations.\n  // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n\n  if ((0, utils_1.every)(leftRecursionErrors, utils_1.isEmpty)) {\n    emptyAltErrors = (0, utils_1.map)(topLevels, function (currTopRule) {\n      return validateEmptyOrAlternative(currTopRule, errMsgProvider);\n    });\n    ambiguousAltsErrors = (0, utils_1.map)(topLevels, function (currTopRule) {\n      return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, errMsgProvider);\n    });\n    emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);\n  }\n\n  var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n  var tooManyAltsErrors = (0, utils_1.map)(topLevels, function (curRule) {\n    return validateTooManyAlts(curRule, errMsgProvider);\n  });\n  var duplicateRulesError = (0, utils_1.map)(topLevels, function (curRule) {\n    return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n  });\n  return utils.flatten(duplicateErrors.concat(emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError));\n}\n\nexports.validateGrammar = validateGrammar;\n\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n  var collectorVisitor = new OccurrenceValidationCollector();\n  topLevelRule.accept(collectorVisitor);\n  var allRuleProductions = collectorVisitor.allProductions;\n  var productionGroups = utils.groupBy(allRuleProductions, identifyProductionForDuplicates);\n  var duplicates = utils.pick(productionGroups, function (currGroup) {\n    return currGroup.length > 1;\n  });\n  var errors = utils.map(utils.values(duplicates), function (currDuplicates) {\n    var firstProd = utils.first(currDuplicates);\n    var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n    var dslName = (0, gast_1.getProductionDslName)(firstProd);\n    var defError = {\n      message: msg,\n      type: parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    };\n    var param = getExtraProductionArgument(firstProd);\n\n    if (param) {\n      defError.parameter = param;\n    }\n\n    return defError;\n  });\n  return errors;\n}\n\nfunction identifyProductionForDuplicates(prod) {\n  return (0, gast_1.getProductionDslName)(prod) + \"_#_\" + prod.idx + \"_#_\" + getExtraProductionArgument(prod);\n}\n\nexports.identifyProductionForDuplicates = identifyProductionForDuplicates;\n\nfunction getExtraProductionArgument(prod) {\n  if (prod instanceof gast_public_1.Terminal) {\n    return prod.terminalType.name;\n  } else if (prod instanceof gast_public_1.NonTerminal) {\n    return prod.nonTerminalName;\n  } else {\n    return \"\";\n  }\n}\n\nvar OccurrenceValidationCollector =\n/** @class */\nfunction (_super) {\n  __extends(OccurrenceValidationCollector, _super);\n\n  function OccurrenceValidationCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.allProductions = [];\n    return _this;\n  }\n\n  OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\n    this.allProductions.push(subrule);\n  };\n\n  OccurrenceValidationCollector.prototype.visitOption = function (option) {\n    this.allProductions.push(option);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n\n  OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\n    this.allProductions.push(or);\n  };\n\n  OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\n    this.allProductions.push(terminal);\n  };\n\n  return OccurrenceValidationCollector;\n}(gast_visitor_public_1.GAstVisitor);\n\nexports.OccurrenceValidationCollector = OccurrenceValidationCollector;\n\nfunction validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n  var errors = [];\n  var occurrences = (0, utils_1.reduce)(allRules, function (result, curRule) {\n    if (curRule.name === rule.name) {\n      return result + 1;\n    }\n\n    return result;\n  }, 0);\n\n  if (occurrences > 1) {\n    var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    });\n    errors.push({\n      message: errMsg,\n      type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    });\n  }\n\n  return errors;\n}\n\nexports.validateRuleDoesNotAlreadyExist = validateRuleDoesNotAlreadyExist; // TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\n\nfunction validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n  var errors = [];\n  var errMsg;\n\n  if (!utils.contains(definedRulesNames, ruleName)) {\n    errMsg = \"Invalid rule override, rule: ->\" + ruleName + \"<- cannot be overridden in the grammar: ->\" + className + \"<-\" + \"as it is not defined in any of the super grammars \";\n    errors.push({\n      message: errMsg,\n      type: parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    });\n  }\n\n  return errors;\n}\n\nexports.validateRuleIsOverridden = validateRuleIsOverridden;\n\nfunction validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\n  if (path === void 0) {\n    path = [];\n  }\n\n  var errors = [];\n  var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n\n  if (utils.isEmpty(nextNonTerminals)) {\n    return [];\n  } else {\n    var ruleName = topRule.name;\n    var foundLeftRecursion = utils.contains(nextNonTerminals, topRule);\n\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: parser_1.ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      });\n    } // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n\n\n    var validNextSteps = utils.difference(nextNonTerminals, path.concat([topRule]));\n    var errorsFromNextSteps = utils.map(validNextSteps, function (currRefRule) {\n      var newPath = utils.cloneArr(path);\n      newPath.push(currRefRule);\n      return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n    });\n    return errors.concat(utils.flatten(errorsFromNextSteps));\n  }\n}\n\nexports.validateNoLeftRecursion = validateNoLeftRecursion;\n\nfunction getFirstNoneTerminal(definition) {\n  var result = [];\n\n  if (utils.isEmpty(definition)) {\n    return result;\n  }\n\n  var firstProd = utils.first(definition);\n  /* istanbul ignore else */\n\n  if (firstProd instanceof gast_public_1.NonTerminal) {\n    result.push(firstProd.referencedRule);\n  } else if (firstProd instanceof gast_public_1.Alternative || firstProd instanceof gast_public_1.Option || firstProd instanceof gast_public_1.RepetitionMandatory || firstProd instanceof gast_public_1.RepetitionMandatoryWithSeparator || firstProd instanceof gast_public_1.RepetitionWithSeparator || firstProd instanceof gast_public_1.Repetition) {\n    result = result.concat(getFirstNoneTerminal(firstProd.definition));\n  } else if (firstProd instanceof gast_public_1.Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = utils.flatten(utils.map(firstProd.definition, function (currSubDef) {\n      return getFirstNoneTerminal(currSubDef.definition);\n    }));\n  } else if (firstProd instanceof gast_public_1.Terminal) {// nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n\n  var isFirstOptional = (0, gast_1.isOptionalProd)(firstProd);\n  var hasMore = definition.length > 1;\n\n  if (isFirstOptional && hasMore) {\n    var rest = utils.drop(definition);\n    return result.concat(getFirstNoneTerminal(rest));\n  } else {\n    return result;\n  }\n}\n\nexports.getFirstNoneTerminal = getFirstNoneTerminal;\n\nvar OrCollector =\n/** @class */\nfunction (_super) {\n  __extends(OrCollector, _super);\n\n  function OrCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.alternations = [];\n    return _this;\n  }\n\n  OrCollector.prototype.visitAlternation = function (node) {\n    this.alternations.push(node);\n  };\n\n  return OrCollector;\n}(gast_visitor_public_1.GAstVisitor);\n\nfunction validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = utils.reduce(ors, function (errors, currOr) {\n    var exceptLast = utils.dropRight(currOr.definition);\n    var currErrors = utils.map(exceptLast, function (currAlternative, currAltIdx) {\n      var possibleFirstInAlt = (0, interpreter_1.nextPossibleTokensAfter)([currAlternative], [], null, 1);\n\n      if (utils.isEmpty(possibleFirstInAlt)) {\n        return {\n          message: errMsgProvider.buildEmptyAlternationError({\n            topLevelRule: topLevelRule,\n            alternation: currOr,\n            emptyChoiceIdx: currAltIdx\n          }),\n          type: parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx,\n          alternative: currAltIdx + 1\n        };\n      } else {\n        return null;\n      }\n    });\n    return errors.concat(utils.compact(currErrors));\n  }, []);\n  return errors;\n}\n\nexports.validateEmptyOrAlternative = validateEmptyOrAlternative;\n\nfunction validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations; // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n\n  ors = (0, utils_1.reject)(ors, function (currOr) {\n    return currOr.ignoreAmbiguities === true;\n  });\n  var errors = utils.reduce(ors, function (result, currOr) {\n    var currOccurrence = currOr.idx;\n    var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n    var alternatives = (0, lookahead_1.getLookaheadPathsForOr)(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n    var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors);\n  }, []);\n  return errors;\n}\n\nexports.validateAmbiguousAlternationAlternatives = validateAmbiguousAlternationAlternatives;\n\nvar RepetionCollector =\n/** @class */\nfunction (_super) {\n  __extends(RepetionCollector, _super);\n\n  function RepetionCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.allProductions = [];\n    return _this;\n  }\n\n  RepetionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n\n  RepetionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n\n  RepetionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n\n  RepetionCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n\n  return RepetionCollector;\n}(gast_visitor_public_1.GAstVisitor);\n\nexports.RepetionCollector = RepetionCollector;\n\nfunction validateTooManyAlts(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = utils.reduce(ors, function (errors, currOr) {\n    if (currOr.definition.length > 255) {\n      errors.push({\n        message: errMsgProvider.buildTooManyAlternativesError({\n          topLevelRule: topLevelRule,\n          alternation: currOr\n        }),\n        type: parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,\n        ruleName: topLevelRule.name,\n        occurrence: currOr.idx\n      });\n    }\n\n    return errors;\n  }, []);\n  return errors;\n}\n\nexports.validateTooManyAlts = validateTooManyAlts;\n\nfunction validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n  var errors = [];\n  (0, utils_1.forEach)(topLevelRules, function (currTopRule) {\n    var collectorVisitor = new RepetionCollector();\n    currTopRule.accept(collectorVisitor);\n    var allRuleProductions = collectorVisitor.allProductions;\n    (0, utils_1.forEach)(allRuleProductions, function (currProd) {\n      var prodType = (0, lookahead_1.getProdType)(currProd);\n      var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n      var currOccurrence = currProd.idx;\n      var paths = (0, lookahead_1.getLookaheadPathsForOptionalProd)(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n      var pathsInsideProduction = paths[0];\n\n      if ((0, utils_1.isEmpty)((0, utils_1.flatten)(pathsInsideProduction))) {\n        var errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        });\n        errors.push({\n          message: errMsg,\n          type: parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        });\n      }\n    });\n  });\n  return errors;\n}\n\nexports.validateSomeNonEmptyLookaheadPath = validateSomeNonEmptyLookaheadPath;\n\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var foundAmbiguousPaths = [];\n  var identicalAmbiguities = (0, utils_1.reduce)(alternatives, function (result, currAlt, currAltIdx) {\n    // ignore (skip) ambiguities with this alternative\n    if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n      return result;\n    }\n\n    (0, utils_1.forEach)(currAlt, function (currPath) {\n      var altsCurrPathAppearsIn = [currAltIdx];\n      (0, utils_1.forEach)(alternatives, function (currOtherAlt, currOtherAltIdx) {\n        if (currAltIdx !== currOtherAltIdx && (0, lookahead_1.containsPath)(currOtherAlt, currPath) && // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n          altsCurrPathAppearsIn.push(currOtherAltIdx);\n        }\n      });\n\n      if (altsCurrPathAppearsIn.length > 1 && !(0, lookahead_1.containsPath)(foundAmbiguousPaths, currPath)) {\n        foundAmbiguousPaths.push(currPath);\n        result.push({\n          alts: altsCurrPathAppearsIn,\n          path: currPath\n        });\n      }\n    });\n    return result;\n  }, []);\n  var currErrors = utils.map(identicalAmbiguities, function (currAmbDescriptor) {\n    var ambgIndices = (0, utils_1.map)(currAmbDescriptor.alts, function (currAltIdx) {\n      return currAltIdx + 1;\n    });\n    var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    });\n    return {\n      message: currMessage,\n      type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: [currAmbDescriptor.alts]\n    };\n  });\n  return currErrors;\n}\n\nfunction checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var errors = []; // flatten\n\n  var pathsAndIndices = (0, utils_1.reduce)(alternatives, function (result, currAlt, idx) {\n    var currPathsAndIdx = (0, utils_1.map)(currAlt, function (currPath) {\n      return {\n        idx: idx,\n        path: currPath\n      };\n    });\n    return result.concat(currPathsAndIdx);\n  }, []);\n  (0, utils_1.forEach)(pathsAndIndices, function (currPathAndIdx) {\n    var alternativeGast = alternation.definition[currPathAndIdx.idx]; // ignore (skip) ambiguities with this alternative\n\n    if (alternativeGast.ignoreAmbiguities === true) {\n      return;\n    }\n\n    var targetIdx = currPathAndIdx.idx;\n    var targetPath = currPathAndIdx.path;\n    var prefixAmbiguitiesPathsAndIndices = (0, utils_1.findAll)(pathsAndIndices, function (searchPathAndIdx) {\n      // prefix ambiguity can only be created from lower idx (higher priority) path\n      return (// ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads\n        // will be be detected using a different validation.\n        (0, lookahead_1.isStrictPrefixOfPath)(searchPathAndIdx.path, targetPath)\n      );\n    });\n    var currPathPrefixErrors = (0, utils_1.map)(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n      var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n      var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n      var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n        topLevelRule: rule,\n        alternation: alternation,\n        ambiguityIndices: ambgIndices,\n        prefixPath: currAmbPathAndIdx.path\n      });\n      return {\n        message: message,\n        type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n        ruleName: rule.name,\n        occurrence: occurrence,\n        alternatives: ambgIndices\n      };\n    });\n    errors = errors.concat(currPathPrefixErrors);\n  });\n  return errors;\n}\n\nexports.checkPrefixAlternativesAmbiguities = checkPrefixAlternativesAmbiguities;\n\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n  var errors = [];\n  var tokenNames = (0, utils_1.map)(tokenTypes, function (currToken) {\n    return currToken.name;\n  });\n  (0, utils_1.forEach)(topLevels, function (currRule) {\n    var currRuleName = currRule.name;\n\n    if ((0, utils_1.contains)(tokenNames, currRuleName)) {\n      var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n      errors.push({\n        message: errMsg,\n        type: parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      });\n    }\n  });\n  return errors;\n}","map":{"version":3,"mappings":"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","names":["validateGrammar","topLevels","globalMaxLookahead","tokenTypes","errMsgProvider","grammarName","duplicateErrors","utils","map","currTopLevel","leftRecursionErrors","currTopRule","emptyAltErrors","ambiguousAltsErrors","emptyRepetitionErrors","utils_1","validateSomeNonEmptyLookaheadPath","termsNamespaceConflictErrors","checkTerminalAndNoneTerminalsNameSpace","tooManyAltsErrors","curRule","duplicateRulesError","flatten","concat","exports","validateDuplicateProductions","topLevelRule","collectorVisitor","OccurrenceValidationCollector","accept","allRuleProductions","allProductions","productionGroups","groupBy","identifyProductionForDuplicates","duplicates","pick","currGroup","length","errors","values","currDuplicates","firstProd","first","msg","buildDuplicateFoundError","dslName","defError","message","type","parser_1","DUPLICATE_PRODUCTIONS","ruleName","name","occurrence","idx","param","getExtraProductionArgument","parameter","prod","gast_public_1","terminalType","nonTerminalName","__extends","_this","subrule","push","option","manySep","atLeastOne","atLeastOneSep","many","or","terminal","gast_visitor_public_1","validateRuleDoesNotAlreadyExist","rule","allRules","className","occurrences","result","errMsg","buildDuplicateRuleNameError","DUPLICATE_RULE_NAME","validateRuleIsOverridden","definedRulesNames","contains","INVALID_RULE_OVERRIDE","validateNoLeftRecursion","topRule","currRule","path","nextNonTerminals","getFirstNoneTerminal","definition","isEmpty","foundLeftRecursion","buildLeftRecursionError","leftRecursionPath","LEFT_RECURSION","validNextSteps","difference","errorsFromNextSteps","currRefRule","newPath","cloneArr","referencedRule","currSubDef","Error","isFirstOptional","hasMore","rest","drop","OrCollector","node","alternations","validateEmptyOrAlternative","orCollector","ors","reduce","currOr","exceptLast","dropRight","currErrors","currAlternative","currAltIdx","possibleFirstInAlt","buildEmptyAlternationError","alternation","emptyChoiceIdx","NONE_LAST_EMPTY_ALT","alternative","compact","validateAmbiguousAlternationAlternatives","ignoreAmbiguities","currOccurrence","actualMaxLookahead","maxLookahead","alternatives","altsAmbiguityErrors","checkAlternativesAmbiguities","altsPrefixAmbiguityErrors","checkPrefixAlternativesAmbiguities","RepetionCollector","validateTooManyAlts","buildTooManyAlternativesError","TOO_MANY_ALTS","topLevelRules","currProd","prodType","paths","pathsInsideProduction","buildEmptyRepetitionError","repetition","NO_NON_EMPTY_LOOKAHEAD","foundAmbiguousPaths","identicalAmbiguities","currAlt","currPath","altsCurrPathAppearsIn","currOtherAlt","currOtherAltIdx","alts","currAmbDescriptor","ambgIndices","currMessage","buildAlternationAmbiguityError","ambiguityIndices","prefixPath","AMBIGUOUS_ALTS","pathsAndIndices","currPathsAndIdx","currPathAndIdx","alternativeGast","targetIdx","targetPath","prefixAmbiguitiesPathsAndIndices","searchPathAndIdx","currPathPrefixErrors","currAmbPathAndIdx","buildAlternationPrefixAmbiguityError","AMBIGUOUS_PREFIX_ALTS","tokenNames","currToken","currRuleName","buildNamespaceConflictError","CONFLICT_TOKENS_RULES_NAMESPACE"],"sources":["/Users/arbus/Documents/SpaceInBrowser/node_modules/chevrotain/src/parse/grammar/checks.ts"],"sourcesContent":["import * as utils from \"@chevrotain/utils\"\nimport {\n  contains,\n  every,\n  findAll,\n  flatten,\n  forEach,\n  isEmpty,\n  map,\n  reduce,\n  reject\n} from \"@chevrotain/utils\"\nimport {\n  IParserAmbiguousAlternativesDefinitionError,\n  IParserDuplicatesDefinitionError,\n  IParserEmptyAlternativeDefinitionError,\n  ParserDefinitionErrorType\n} from \"../parser/parser\"\nimport { getProductionDslName, isOptionalProd } from \"./gast/gast\"\nimport {\n  Alternative,\n  containsPath,\n  getLookaheadPathsForOptionalProd,\n  getLookaheadPathsForOr,\n  getProdType,\n  isStrictPrefixOfPath\n} from \"./lookahead\"\nimport { nextPossibleTokensAfter } from \"./interpreter\"\nimport {\n  Alternation,\n  Alternative as AlternativeGAST,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal\n} from \"./gast/gast_public\"\nimport { GAstVisitor } from \"./gast/gast_visitor_public\"\nimport {\n  IProduction,\n  IProductionWithOccurrence,\n  TokenType\n} from \"@chevrotain/types\"\nimport {\n  IGrammarValidatorErrorMessageProvider,\n  IParserDefinitionError\n} from \"./types\"\n\nexport function validateGrammar(\n  topLevels: Rule[],\n  globalMaxLookahead: number,\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  grammarName: string\n): IParserDefinitionError[] {\n  const duplicateErrors: any = utils.map(topLevels, (currTopLevel) =>\n    validateDuplicateProductions(currTopLevel, errMsgProvider)\n  )\n  const leftRecursionErrors: any = utils.map(topLevels, (currTopRule) =>\n    validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider)\n  )\n\n  let emptyAltErrors = []\n  let ambiguousAltsErrors = []\n  let emptyRepetitionErrors = []\n\n  // left recursion could cause infinite loops in the following validations.\n  // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n  if (every(leftRecursionErrors, isEmpty)) {\n    emptyAltErrors = map(topLevels, (currTopRule) =>\n      validateEmptyOrAlternative(currTopRule, errMsgProvider)\n    )\n    ambiguousAltsErrors = map(topLevels, (currTopRule) =>\n      validateAmbiguousAlternationAlternatives(\n        currTopRule,\n        globalMaxLookahead,\n        errMsgProvider\n      )\n    )\n\n    emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(\n      topLevels,\n      globalMaxLookahead,\n      errMsgProvider\n    )\n  }\n\n  const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(\n    topLevels,\n    tokenTypes,\n    errMsgProvider\n  )\n\n  const tooManyAltsErrors = map(topLevels, (curRule) =>\n    validateTooManyAlts(curRule, errMsgProvider)\n  )\n\n  const duplicateRulesError = map(topLevels, (curRule) =>\n    validateRuleDoesNotAlreadyExist(\n      curRule,\n      topLevels,\n      grammarName,\n      errMsgProvider\n    )\n  )\n\n  return <any>(\n    utils.flatten(\n      duplicateErrors.concat(\n        emptyRepetitionErrors,\n        leftRecursionErrors,\n        emptyAltErrors,\n        ambiguousAltsErrors,\n        termsNamespaceConflictErrors,\n        tooManyAltsErrors,\n        duplicateRulesError\n      )\n    )\n  )\n}\n\nfunction validateDuplicateProductions(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDuplicatesDefinitionError[] {\n  const collectorVisitor = new OccurrenceValidationCollector()\n  topLevelRule.accept(collectorVisitor)\n  const allRuleProductions = collectorVisitor.allProductions\n\n  const productionGroups = utils.groupBy(\n    allRuleProductions,\n    identifyProductionForDuplicates\n  )\n\n  const duplicates: any = utils.pick(productionGroups, (currGroup) => {\n    return currGroup.length > 1\n  })\n\n  const errors = utils.map(utils.values(duplicates), (currDuplicates: any) => {\n    const firstProd: any = utils.first(currDuplicates)\n    const msg = errMsgProvider.buildDuplicateFoundError(\n      topLevelRule,\n      currDuplicates\n    )\n    const dslName = getProductionDslName(firstProd)\n    const defError: IParserDuplicatesDefinitionError = {\n      message: msg,\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    }\n\n    const param = getExtraProductionArgument(firstProd)\n    if (param) {\n      defError.parameter = param\n    }\n\n    return defError\n  })\n  return errors\n}\n\nexport function identifyProductionForDuplicates(\n  prod: IProductionWithOccurrence\n): string {\n  return `${getProductionDslName(prod)}_#_${\n    prod.idx\n  }_#_${getExtraProductionArgument(prod)}`\n}\n\nfunction getExtraProductionArgument(prod: IProductionWithOccurrence): string {\n  if (prod instanceof Terminal) {\n    return prod.terminalType.name\n  } else if (prod instanceof NonTerminal) {\n    return prod.nonTerminalName\n  } else {\n    return \"\"\n  }\n}\n\nexport class OccurrenceValidationCollector extends GAstVisitor {\n  public allProductions: IProduction[] = []\n\n  public visitNonTerminal(subrule: NonTerminal): void {\n    this.allProductions.push(subrule)\n  }\n\n  public visitOption(option: Option): void {\n    this.allProductions.push(option)\n  }\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.allProductions.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many)\n  }\n\n  public visitAlternation(or: Alternation): void {\n    this.allProductions.push(or)\n  }\n\n  public visitTerminal(terminal: Terminal): void {\n    this.allProductions.push(terminal)\n  }\n}\n\nexport function validateRuleDoesNotAlreadyExist(\n  rule: Rule,\n  allRules: Rule[],\n  className,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors = []\n  const occurrences = reduce(\n    allRules,\n    (result, curRule) => {\n      if (curRule.name === rule.name) {\n        return result + 1\n      }\n      return result\n    },\n    0\n  )\n  if (occurrences > 1) {\n    const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    })\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    })\n  }\n\n  return errors\n}\n\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(\n  ruleName: string,\n  definedRulesNames: string[],\n  className\n): IParserDefinitionError[] {\n  const errors = []\n  let errMsg\n\n  if (!utils.contains(definedRulesNames, ruleName)) {\n    errMsg =\n      `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +\n      `as it is not defined in any of the super grammars `\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    })\n  }\n\n  return errors\n}\n\nexport function validateNoLeftRecursion(\n  topRule: Rule,\n  currRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  path: Rule[] = []\n): IParserDefinitionError[] {\n  const errors = []\n  const nextNonTerminals = getFirstNoneTerminal(currRule.definition)\n  if (utils.isEmpty(nextNonTerminals)) {\n    return []\n  } else {\n    const ruleName = topRule.name\n    const foundLeftRecursion = utils.contains(<any>nextNonTerminals, topRule)\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      })\n    }\n\n    // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n    const validNextSteps = utils.difference(\n      nextNonTerminals,\n      path.concat([topRule])\n    )\n    const errorsFromNextSteps = utils.map(validNextSteps, (currRefRule) => {\n      const newPath = utils.cloneArr(path)\n      newPath.push(currRefRule)\n      return validateNoLeftRecursion(\n        topRule,\n        currRefRule,\n        errMsgProvider,\n        newPath\n      )\n    })\n\n    return errors.concat(utils.flatten(errorsFromNextSteps))\n  }\n}\n\nexport function getFirstNoneTerminal(definition: IProduction[]): Rule[] {\n  let result = []\n  if (utils.isEmpty(definition)) {\n    return result\n  }\n  const firstProd = utils.first(definition)\n\n  /* istanbul ignore else */\n  if (firstProd instanceof NonTerminal) {\n    result.push(firstProd.referencedRule)\n  } else if (\n    firstProd instanceof AlternativeGAST ||\n    firstProd instanceof Option ||\n    firstProd instanceof RepetitionMandatory ||\n    firstProd instanceof RepetitionMandatoryWithSeparator ||\n    firstProd instanceof RepetitionWithSeparator ||\n    firstProd instanceof Repetition\n  ) {\n    result = result.concat(\n      getFirstNoneTerminal(<IProduction[]>firstProd.definition)\n    )\n  } else if (firstProd instanceof Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = utils.flatten(\n      utils.map(firstProd.definition, (currSubDef) =>\n        getFirstNoneTerminal((<AlternativeGAST>currSubDef).definition)\n      )\n    )\n  } else if (firstProd instanceof Terminal) {\n    // nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n\n  const isFirstOptional = isOptionalProd(firstProd)\n  const hasMore = definition.length > 1\n  if (isFirstOptional && hasMore) {\n    const rest = utils.drop(definition)\n    return result.concat(getFirstNoneTerminal(rest))\n  } else {\n    return result\n  }\n}\n\nclass OrCollector extends GAstVisitor {\n  public alternations = []\n\n  public visitAlternation(node: Alternation): void {\n    this.alternations.push(node)\n  }\n}\n\nexport function validateEmptyOrAlternative(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserEmptyAlternativeDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  const ors = orCollector.alternations\n\n  const errors = utils.reduce(\n    ors,\n    (errors, currOr) => {\n      const exceptLast = utils.dropRight(currOr.definition)\n      const currErrors = utils.map(\n        exceptLast,\n        (currAlternative: IProduction, currAltIdx) => {\n          const possibleFirstInAlt = nextPossibleTokensAfter(\n            [currAlternative],\n            [],\n            null,\n            1\n          )\n          if (utils.isEmpty(possibleFirstInAlt)) {\n            return {\n              message: errMsgProvider.buildEmptyAlternationError({\n                topLevelRule: topLevelRule,\n                alternation: currOr,\n                emptyChoiceIdx: currAltIdx\n              }),\n              type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n              ruleName: topLevelRule.name,\n              occurrence: currOr.idx,\n              alternative: currAltIdx + 1\n            }\n          } else {\n            return null\n          }\n        }\n      )\n      return errors.concat(utils.compact(currErrors))\n    },\n    []\n  )\n\n  return errors\n}\n\nexport function validateAmbiguousAlternationAlternatives(\n  topLevelRule: Rule,\n  globalMaxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  let ors = orCollector.alternations\n\n  // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n  ors = reject(ors, (currOr) => currOr.ignoreAmbiguities === true)\n\n  const errors = utils.reduce(\n    ors,\n    (result, currOr: Alternation) => {\n      const currOccurrence = currOr.idx\n      const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead\n      const alternatives = getLookaheadPathsForOr(\n        currOccurrence,\n        topLevelRule,\n        actualMaxLookahead,\n        currOr\n      )\n      const altsAmbiguityErrors = checkAlternativesAmbiguities(\n        alternatives,\n        currOr,\n        topLevelRule,\n        errMsgProvider\n      )\n      const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(\n        alternatives,\n        currOr,\n        topLevelRule,\n        errMsgProvider\n      )\n\n      return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors)\n    },\n    []\n  )\n\n  return errors\n}\n\nexport class RepetionCollector extends GAstVisitor {\n  public allProductions: IProduction[] = []\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.allProductions.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many)\n  }\n}\n\nexport function validateTooManyAlts(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  const ors = orCollector.alternations\n\n  const errors = utils.reduce(\n    ors,\n    (errors, currOr) => {\n      if (currOr.definition.length > 255) {\n        errors.push({\n          message: errMsgProvider.buildTooManyAlternativesError({\n            topLevelRule: topLevelRule,\n            alternation: currOr\n          }),\n          type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx\n        })\n      }\n      return errors\n    },\n    []\n  )\n\n  return errors\n}\n\nexport function validateSomeNonEmptyLookaheadPath(\n  topLevelRules: Rule[],\n  maxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors = []\n  forEach(topLevelRules, (currTopRule) => {\n    const collectorVisitor = new RepetionCollector()\n    currTopRule.accept(collectorVisitor)\n    const allRuleProductions = collectorVisitor.allProductions\n    forEach(allRuleProductions, (currProd) => {\n      const prodType = getProdType(currProd)\n      const actualMaxLookahead = currProd.maxLookahead || maxLookahead\n      const currOccurrence = currProd.idx\n      const paths = getLookaheadPathsForOptionalProd(\n        currOccurrence,\n        currTopRule,\n        prodType,\n        actualMaxLookahead\n      )\n      const pathsInsideProduction = paths[0]\n      if (isEmpty(flatten(pathsInsideProduction))) {\n        const errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        })\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        })\n      }\n    })\n  })\n\n  return errors\n}\n\nexport interface IAmbiguityDescriptor {\n  alts: number[]\n  path: TokenType[]\n}\n\nfunction checkAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  const foundAmbiguousPaths = []\n  const identicalAmbiguities = reduce(\n    alternatives,\n    (result, currAlt, currAltIdx) => {\n      // ignore (skip) ambiguities with this alternative\n      if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n        return result\n      }\n\n      forEach(currAlt, (currPath) => {\n        const altsCurrPathAppearsIn = [currAltIdx]\n        forEach(alternatives, (currOtherAlt, currOtherAltIdx) => {\n          if (\n            currAltIdx !== currOtherAltIdx &&\n            containsPath(currOtherAlt, currPath) &&\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true\n          ) {\n            altsCurrPathAppearsIn.push(currOtherAltIdx)\n          }\n        })\n\n        if (\n          altsCurrPathAppearsIn.length > 1 &&\n          !containsPath(foundAmbiguousPaths, currPath)\n        ) {\n          foundAmbiguousPaths.push(currPath)\n          result.push({\n            alts: altsCurrPathAppearsIn,\n            path: currPath\n          })\n        }\n      })\n      return result\n    },\n    []\n  )\n\n  const currErrors = utils.map(identicalAmbiguities, (currAmbDescriptor) => {\n    const ambgIndices = map(\n      currAmbDescriptor.alts,\n      (currAltIdx) => currAltIdx + 1\n    )\n\n    const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    })\n\n    return {\n      message: currMessage,\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: [currAmbDescriptor.alts]\n    }\n  })\n\n  return currErrors\n}\n\nexport function checkPrefixAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IAmbiguityDescriptor[] {\n  let errors = []\n\n  // flatten\n  const pathsAndIndices = reduce(\n    alternatives,\n    (result, currAlt, idx) => {\n      const currPathsAndIdx = map(currAlt, (currPath) => {\n        return { idx: idx, path: currPath }\n      })\n      return result.concat(currPathsAndIdx)\n    },\n    []\n  )\n\n  forEach(pathsAndIndices, (currPathAndIdx) => {\n    const alternativeGast = alternation.definition[currPathAndIdx.idx]\n    // ignore (skip) ambiguities with this alternative\n    if (alternativeGast.ignoreAmbiguities === true) {\n      return\n    }\n    const targetIdx = currPathAndIdx.idx\n    const targetPath = currPathAndIdx.path\n\n    const prefixAmbiguitiesPathsAndIndices = findAll(\n      pathsAndIndices,\n      (searchPathAndIdx) => {\n        // prefix ambiguity can only be created from lower idx (higher priority) path\n        return (\n          // ignore (skip) ambiguities with this \"other\" alternative\n          alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\n            true &&\n          searchPathAndIdx.idx < targetIdx &&\n          // checking for strict prefix because identical lookaheads\n          // will be be detected using a different validation.\n          isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n        )\n      }\n    )\n\n    const currPathPrefixErrors = map(\n      prefixAmbiguitiesPathsAndIndices,\n      (currAmbPathAndIdx) => {\n        const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1]\n        const occurrence = alternation.idx === 0 ? \"\" : alternation.idx\n\n        const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n          topLevelRule: rule,\n          alternation: alternation,\n          ambiguityIndices: ambgIndices,\n          prefixPath: currAmbPathAndIdx.path\n        })\n        return {\n          message: message,\n          type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n          ruleName: rule.name,\n          occurrence: occurrence,\n          alternatives: ambgIndices\n        }\n      }\n    )\n    errors = errors.concat(currPathPrefixErrors)\n  })\n\n  return errors\n}\n\nfunction checkTerminalAndNoneTerminalsNameSpace(\n  topLevels: Rule[],\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors = []\n\n  const tokenNames = map(tokenTypes, (currToken) => currToken.name)\n\n  forEach(topLevels, (currRule) => {\n    const currRuleName = currRule.name\n    if (contains(tokenNames, currRuleName)) {\n      const errMsg = errMsgProvider.buildNamespaceConflictError(currRule)\n\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      })\n    }\n  })\n\n  return errors\n}\n"]},"metadata":{},"sourceType":"script"}